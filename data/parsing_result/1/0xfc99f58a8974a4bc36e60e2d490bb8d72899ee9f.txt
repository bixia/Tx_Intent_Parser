{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 36, 'end_line': 44, 'offset_start': 1455, 'offset_end': 1637, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 53, 'end_line': 53, 'offset_start': 1943, 'offset_end': 2005, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 59, 'end_line': 59, 'offset_start': 2198, 'offset_end': 2257, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 78, 'end_line': 80, 'offset_start': 2902, 'offset_end': 2997, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 82, 'end_line': 84, 'offset_start': 3004, 'offset_end': 3102, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 115, 'end_line': 117, 'offset_start': 4110, 'offset_end': 4204, 'content': 'function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 119, 'end_line': 121, 'offset_start': 4211, 'offset_end': 4321, 'content': 'function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 134, 'end_line': 136, 'offset_start': 4548, 'offset_end': 4632, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 141, 'end_line': 143, 'offset_start': 4706, 'offset_end': 4835, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 152, 'end_line': 154, 'offset_start': 5171, 'offset_end': 5271, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 160, 'end_line': 163, 'offset_start': 5421, 'offset_end': 5618, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 169, 'end_line': 173, 'offset_start': 5773, 'offset_end': 5959, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 328, 'end_line': 329, 'offset_start': 14024, 'offset_end': 14082, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 331, 'end_line': 332, 'offset_start': 14089, 'offset_end': 14157, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 333, 'end_line': 335, 'offset_start': 14163, 'offset_end': 14258, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 337, 'end_line': 339, 'offset_start': 14265, 'offset_end': 14363, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Bytes.bytesToBytes32Array', 'start_line': 353, 'end_line': 368, 'offset_start': 14736, 'offset_end': 15215, 'content': 'function bytesToBytes32Array(bytes memory data)\n        internal\n        pure\n        returns (bytes32[] memory dataList)\n    {\n        uint256 N = (data.length + 31) / 32;\n        dataList = new bytes32[](N);\n        for (uint256 index = 0; index < N; index++) {\n            bytes32 element;\n            uint256 start = 32 + index * 32;\n            assembly {\n                element := mload(add(data, start))\n            }\n            dataList[index] = element;\n        }\n    }', 'contract_name': 'Bytes', 'contract_code': '{\n    function bytesToBytes32Array(bytes memory data)\n        internal\n        pure\n        returns (bytes32[] memory dataList)\n    {\n        uint256 N = (data.length + 31) / 32;\n        dataList = new bytes32[](N);\n        for (uint256 index = 0; index < N; index++) {\n            bytes32 element;\n            uint256 start = 32 + index * 32;\n            assembly {\n                element := mload(add(data, start))\n            }\n            dataList[index] = element;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 397, 'end_line': 399, 'offset_start': 16131, 'offset_end': 16193, 'content': 'constructor() {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 412, 'end_line': 414, 'offset_start': 16420, 'offset_end': 16504, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._checkOwner', 'start_line': 419, 'end_line': 421, 'offset_start': 16578, 'offset_end': 16707, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 430, 'end_line': 432, 'offset_start': 17043, 'offset_end': 17143, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 438, 'end_line': 441, 'offset_start': 17293, 'offset_end': 17490, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 447, 'end_line': 451, 'offset_start': 17645, 'offset_end': 17831, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.initialize', 'start_line': 604, 'end_line': 609, 'offset_start': 23121, 'offset_end': 23283, 'content': 'function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.tor', 'start_line': 612, 'end_line': 614, 'offset_start': 23343, 'offset_end': 23395, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._getGasReceiveAmount', 'start_line': 705, 'end_line': 717, 'offset_start': 25763, 'offset_end': 26298, 'content': 'function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._deposit', 'start_line': 727, 'end_line': 734, 'offset_start': 26760, 'offset_end': 26980, 'content': 'function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._getBalanceOf', 'start_line': 736, 'end_line': 738, 'offset_start': 26987, 'offset_end': 27115, 'content': 'function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._getBalanceOf', 'start_line': 740, 'end_line': 742, 'offset_start': 27122, 'offset_end': 27321, 'content': 'function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._transferToken', 'start_line': 751, 'end_line': 760, 'offset_start': 27643, 'offset_end': 28061, 'content': 'function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._constructExt', 'start_line': 772, 'end_line': 805, 'offset_start': 28699, 'offset_end': 30138, 'content': 'function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._bridgeToV2Internal', 'start_line': 820, 'end_line': 880, 'offset_start': 30740, 'offset_end': 33440, 'content': 'function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._swapBridgeToInternal', 'start_line': 903, 'end_line': 1026, 'offset_start': 34300, 'offset_end': 40421, 'content': 'function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._permit', 'start_line': 1033, 'end_line': 1050, 'offset_start': 40687, 'offset_end': 41497, 'content': 'function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._receiveGasTokenInternal', 'start_line': 1057, 'end_line': 1065, 'offset_start': 41840, 'offset_end': 42482, 'content': 'function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._decode', 'start_line': 1077, 'end_line': 1103, 'offset_start': 43202, 'offset_end': 44214, 'content': 'function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._verifyOracle', 'start_line': 1111, 'end_line': 1141, 'offset_start': 44586, 'offset_end': 46229, 'content': 'function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._claimInternal', 'start_line': 1148, 'end_line': 1224, 'offset_start': 46556, 'offset_end': 50898, 'content': 'function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._swapWrap', 'start_line': 1234, 'end_line': 1261, 'offset_start': 51326, 'offset_end': 52450, 'content': 'function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge._doCommission', 'start_line': 1271, 'end_line': 1307, 'offset_start': 52970, 'offset_end': 54772, 'content': 'function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.setAdmin', 'start_line': 1313, 'end_line': 1317, 'offset_start': 54894, 'offset_end': 55088, 'content': 'function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.setDexRouter', 'start_line': 1319, 'end_line': 1323, 'offset_start': 55095, 'offset_end': 55317, 'content': 'function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.pause', 'start_line': 1325, 'end_line': 1327, 'offset_start': 55324, 'offset_end': 55384, 'content': 'function pause() external onlyAdmin {\n        _pause();\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.unpause', 'start_line': 1329, 'end_line': 1331, 'offset_start': 55391, 'offset_end': 55455, 'content': 'function unpause() external onlyAdmin {\n        _unpause();\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.setAdaptors', 'start_line': 1333, 'end_line': 1339, 'offset_start': 55462, 'offset_end': 55813, 'content': 'function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.setFeeTo', 'start_line': 1341, 'end_line': 1345, 'offset_start': 55820, 'offset_end': 56014, 'content': 'function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.setMpc', 'start_line': 1347, 'end_line': 1353, 'offset_start': 56021, 'offset_end': 56339, 'content': 'function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.setSysRatio', 'start_line': 1355, 'end_line': 1358, 'offset_start': 56346, 'offset_end': 56493, 'content': 'function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.setProxies', 'start_line': 1360, 'end_line': 1369, 'offset_start': 56500, 'offset_end': 56881, 'content': 'function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.setAccessSelectorId', 'start_line': 1371, 'end_line': 1377, 'offset_start': 56888, 'offset_end': 57274, 'content': 'function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.bridgeToV2', 'start_line': 1387, 'end_line': 1394, 'offset_start': 57610, 'offset_end': 57788, 'content': 'function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None, None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.swapBridgeToV2', 'start_line': 1400, 'end_line': 1407, 'offset_start': 57993, 'offset_end': 58179, 'content': 'function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None, None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.swapBridgeToWithPermit', 'start_line': 1414, 'end_line': 1420, 'offset_start': 58467, 'offset_end': 58719, 'content': 'function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.receiveGasToken', 'start_line': 1426, 'end_line': 1435, 'offset_start': 58905, 'offset_end': 59189, 'content': 'function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.claim', 'start_line': 1441, 'end_line': 1448, 'offset_start': 59397, 'offset_end': 59559, 'content': 'function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None, None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.doBatch', 'start_line': 1455, 'end_line': 1472, 'offset_start': 59894, 'offset_end': 60563, 'content': 'function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.payerReceiver', 'start_line': 1474, 'end_line': 1476, 'offset_start': 60570, 'offset_end': 60675, 'content': 'function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'XBridge.', 'start_line': 1478, 'end_line': 1478, 'offset_start': 60682, 'offset_end': 60710, 'content': 'receive() external payable {}', 'contract_name': 'XBridge', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Struct representing the information needed for a bridge transaction\n    struct BridgeRequestV2 {\n        uint256 adaptorId;\n        address to;\n        address token;\n        uint256 toChainId; // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 amount;\n        bytes   data;      // router data\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap and bridge transaction\n    struct SwapBridgeRequestV2 {\n        address fromToken;                // the source token\n        address toToken;                  // the token to be bridged\n        address to;                       // the address to be bridged to\n        uint256 adaptorId;\n        uint256 toChainId;                // orderId[64bit] | gasFeeAmount[160] | target chainId[32bit]\n        uint256 fromTokenAmount;          // the source token amount\n        uint256 toTokenMinAmount;\n        uint256 toChainToTokenMinAmount;\n        bytes   data;                     // router data\n        bytes   dexData;                  // the call data for dexRouter\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for a swap transaction\n    struct SwapRequest {\n        address fromToken;\n        address toToken;\n        address to;\n        uint256 amount; // amount of swapped fromToken\n        uint256 gasFeeAmount; // tx gas fee slash from fromToken\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   dexData;\n        bytes   extData;\n    }\n\n    // Struct representing the information needed for receiving gas tokens on another chain\n    struct ReceiveGasRequest {\n        address to;\n        uint256 amount;\n        uint256 srcChainId;\n        bytes32 srcTxHash;\n        bytes   extData;\n    }\n\n    // Struct representing a threshold configuration for a specific address\n    struct Threshold {\n        bool    opened;\n        uint256 amount;\n    }\n\n    // Struct representing information related to an oracle, used for verifying certain transactions\n    struct OracleInfo {\n        uint256 srcChainId;\n        bytes32 txHash;\n        bytes32 to;\n        bytes32 token;\n        uint256 amount;\n        uint256 actualAmount;\n    }\n\n    //-------------------------------\n    //------- storage ---------------\n    //-------------------------------\n    mapping(uint256 => address) public adaptorInfo;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    address public approveProxy;\n\n    address public dexRouter;\n\n    address public payer;\n\n    address public receiver;\n\n    address public feeTo;\n\n    address public admin;\n\n    mapping(address => bool) public mpc;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public paidTx;\n\n    mapping(uint256 => mapping(bytes32 => bool)) public receiveGasTx;\n\n    /**\n     * @dev Set by admin\n     */\n    mapping(uint256 => uint256) public sysRatio;\n\n    /**\n     * @dev This state variable is deprecated and should not be used anymore.\n     */\n    mapping(uint256 => address) public sysAddressConfig;\n\n    mapping(address => Threshold) public thresholdConfig;\n\n    mapping(address => bool) public proxies; // oracle proxy\n\n    mapping(bytes4 => bool) public accessSelectorId; // for swap\n\n    /**\n     * @notice Initializes the XBridge contract.\n     * @dev This function is part of the Upgradable pattern and is called once to initialize contract state.\n     * It sets up the initial state by invoking the initializers of the inherited contracts.\n     * The `admin` variable is set to the address of the account that deploys the contract.\n     * Note: This function is meant to be called only once during the contract deployment.\n     */\n    function initialize() public initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        admin = msg.sender;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event DexRouterChanged(address _dexRouter);\n\n    /**\n     * @notice Event emitted when a bridge transaction occurs\n     */\n    event LogBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a swap and bridge transaction occurs\n     */\n    event LogSwapAndBridgeTo(\n        uint256 indexed _adaptorId,\n        address _from,\n        address _to,\n        address _fromToken,\n        uint256 _fromAmount,\n        address _toToken,\n        uint256 _toAmount,\n        uint256 _receiveFee,\n        bytes32[] ext\n    );\n    event FeeToChanged(address _feeTo);\n\n    event AdminChanged(address _newAdmin);\n\n    event GasTokenReceived(\n        address to,\n        uint256 amount,\n        uint256 srcChainId,\n        bytes32[] ext\n    );\n\n    /**\n     * @notice Event emitted when a claim transaction occurs\n     */\n    event Claimed(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 toTokenAmount,\n        uint256 gasFeeAmount,\n        uint256 srcChainId,\n        string  errInfo,\n        bytes32[] ext\n    );\n\n    event AdaptorsChanged(uint256 indexed _adaptorId, address _adaptor);\n\n    event MpcChanged(address _mpc, bool _enable);\n\n    event SysRatioChanged(uint256 _index, uint256 _ratio);\n\n    event ProxiesChanged(address _proxy, bool _enable);\n\n    event AccessSelectorIdChanged(bytes4 _selectorId, bool _enable);\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n\n    modifier onlyMPC() {\n        require(mpc[msg.sender], XBridgeErrors.ONLY_MPC);\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, XBridgeErrors.ONLY_ADMIN);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n\n    /**\n     * @notice Internal pure function to extract information from a packed uint256 value representing gas receive details\n     * @param toChainId Packed uint256 value containing order ID, gas fee amount, and chain ID\n     */\n    function _getGasReceiveAmount(uint256 toChainId)\n        internal\n        pure\n        returns (\n            uint256 orderId,\n            uint256 gasFeeAmount,\n            uint256 chainId\n        )\n    {\n        orderId      = (toChainId & 0xffffffffffffffff000000000000000000000000000000000000000000000000) >> 192;\n        gasFeeAmount = (toChainId & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffff00000000) >> 32;\n        chainId      =  toChainId & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\n    }\n\n    /**\n     * @notice Internal function to perform a token deposit operation.\n     * @dev Ensures that the caller has sufficient allowance to deposit the specified amount of tokens.\n     * @param from The address from which tokens are transferred.\n     * @param to The recipient address to receive the deposited tokens.\n     * @param token The address of the ERC20 token being deposited.\n     * @param amount The amount of tokens to be deposited.\n    */\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        IApproveProxy(XBridgeConstants.APPROVE_PROXY).claimTokens(token, from, to, amount);\n    }\n\n    function _getBalanceOf(address token) internal view returns (uint256) {\n        return _getBalanceOf(token, address(this));\n    }\n\n    function _getBalanceOf(address token, address who) internal view returns(uint256) {\n        return token == XBridgeConstants.NATIVE_TOKEN ? who.balance : IERC20Upgradeable(token).balanceOf(who);\n    }\n\n\n    /**\n     * @notice Internal function to transfer ERC20 tokens or native tokens (ETH) to a specified address.\n     * @param to The address to which tokens are transferred.\n     * @param token The address of the ERC20 token to be transferred.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function _transferToken(address to, address token, uint256 amount) internal {\n        if (amount > 0) {\n            if (token == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            } else {\n                IERC20Upgradeable(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function to construct extension data for cross-chain transaction.\n     * @param orderId The unique identifier for the cross-chain transaction.\n     * @param toChainId The identifier of the target chain.\n     * @param adaptorId The identifier of the cross-chain adaptor used.\n     * @param to The destination address on the target chain.\n     * @param data Additional data specific to the cross-chain adaptor.\n     * @param extData Additional extension data containing user-specific information.\n     * @return ext An array of bytes32 values representing the constructed extension data.\n     */\n    function _constructExt(uint256 orderId, uint256 toChainId, uint256 adaptorId, address to, bytes memory data, bytes memory extData)\n        internal\n        pure\n        returns(bytes32[] memory ext)\n    {\n        ext = new bytes32[](6);\n        ext[0] = bytes32(orderId);\n        ext[1] = bytes32(toChainId);\n\n        if (adaptorId == XBridgeConstants.ADAPTER_ID_ANYSWAP\n                || adaptorId == XBridgeConstants.ADAPTER_ID_CBRIDGE) {\n            ext[2] = bytes32(abi.encodePacked(to));\n            ext[3] = bytes32(abi.encodePacked(""));\n        } else if (adaptorId == XBridgeConstants.ADAPTER_ID_SWFT) {\n            (,,string memory destination,) = abi.decode(data, (address, string, string, uint256));\n            bytes32[] memory destBytes32Arr = Bytes.bytesToBytes32Array(bytes(destination));\n            ext[2] = destBytes32Arr[0];\n            if (destBytes32Arr.length > 1) {\n                ext[3] = destBytes32Arr[1];\n            }\n        }\n        if (extData.length > 0) {\n            (string memory userAddress) = abi.decode(extData, (string));\n            bytes32[] memory userAddressBytes32Arr = Bytes.bytesToBytes32Array(bytes(userAddress));\n            ext[4] = userAddressBytes32Arr[0];\n            if (userAddressBytes32Arr.length > 1) {\n                ext[5] = userAddressBytes32Arr[1];\n            }\n        } else {\n            ext[4] = ext[2];\n            ext[5] = ext[3];\n        }\n        return ext;\n    }\n\n    /**\n     * @notice Struct to represent the result of a commission operation.\n     */\n    struct CommissionReturn {\n        uint256 commissionAmount;  // commission amount\n        bytes extDataWithoutLast32;  // extData without last 32 bytes\n    }\n\n    /**\n     * @notice Internal function to initiate a cross-chain transaction using the specified BridgeRequestV2 parameters.\n     * @param _request The BridgeRequestV2 struct containing transaction details.\n     * @dev Performs necessary validations, token transfers, and calls the outboundBridgeTo function on the selected adaptor.\n     */\n    function _bridgeToV2Internal(BridgeRequestV2 memory _request) internal {\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        address adaptor = adaptorInfo[_request.adaptorId];\n        require(adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.token != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.amount != 0, XBridgeErrors.AMOUNT_ZERO);\n\n        // doCommission\n        CommissionReturn memory vars;\n        (vars.commissionAmount, vars.extDataWithoutLast32) = _doCommission(_request.amount, _request.token, _request.extData);\n        _request.extData = vars.extDataWithoutLast32;\n        uint256 ethValue = msg.value;\n\n        // Extract gas fee details from toChainId\n        (uint256 orderId, uint256 gasFeeAmount, uint256 toChainId) = _getGasReceiveAmount(_request.toChainId);\n        if (_request.token == XBridgeConstants.NATIVE_TOKEN) {\n            require(msg.value >= _request.amount + gasFeeAmount + vars.commissionAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            ethValue -= vars.commissionAmount;   // after docommission\n            if (gasFeeAmount > 0) {\n                (bool success, ) = payable(feeTo).call{value: gasFeeAmount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n                ethValue -= gasFeeAmount;\n            }\n        } else {\n            if (gasFeeAmount > 0) {\n                _deposit(msg.sender, feeTo, _request.token, gasFeeAmount);\n            }\n            _deposit(msg.sender, adaptor, _request.token, _request.amount);\n        }\n\n        // Call the outboundBridgeTo function on the selected adaptor\n        BridgeAdaptorBase(payable(adaptor)).outboundBridgeTo{value : ethValue}(\n            msg.sender,\n            _request.to,\n            msg.sender, // refund to msg.sender\n            _request.token,\n            _request.amount,\n            toChainId,\n            _request.data\n        );\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    orderId,\n                                    toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.token,\n            _request.amount,\n            gasFeeAmount,\n            ext\n        );\n    }\n\n    /**\n     * @notice Struct to represent the result of a cross-chain bridge operation.\n     * @dev Holds information about the adaptor, token balances, gas fee, chain ID, order ID, success status, function selector, and result data.\n     */\n    struct BridgeVariants {\n        address adaptor;\n        uint256 toTokenBalance;\n        uint256 toTokenBalanceOrigin;\n        uint256 gasFeeAmount;\n        uint256 toChainId;\n        uint256 orderId;\n        bool success;\n        bytes4 selectorId;\n        bytes result;\n    }\n\n    /**\n     * @notice Internal function to perform a token swap and bridge operation using the specified SwapBridgeRequestV2 parameters.\n     * @param _request The SwapBridgeRequestV2 struct containing swap and bridge details.\n     * @dev Performs necessary validations, token swaps, bridge calls, and balance checks.\n     */\n    function _swapBridgeToInternal(SwapBridgeRequestV2 memory _request) internal {\n        BridgeVariants memory vars;\n        require(_request.adaptorId != 0, XBridgeErrors.INVALID_ADAPTOR_ID);\n        vars.adaptor = adaptorInfo[_request.adaptorId];\n        require(vars.adaptor != address(0), XBridgeErrors.INVALID_ADAPTOR_ADDRESS);\n        require(_request.fromToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.toToken != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromToken != _request.toToken, XBridgeErrors.ADDRESS_EQUAL);\n        require(_request.to != address(0), XBridgeErrors.ADDRESS_0);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(_request.fromTokenAmount != 0, XBridgeErrors.AMOUNT_ZERO);\n        require(_request.toTokenMinAmount != 0, XBridgeErrors.MIN_AMOUNT_ZERO);\n\n        // Extract gas fee details from toChainId\n        (vars.orderId, vars.gasFeeAmount,  vars.toChainId) = _getGasReceiveAmount(_request.toChainId);\n        vars.toTokenBalanceOrigin = _getBalanceOf(_request.toToken);\n\n        // Validate the dexData function selector\n        require(accessSelectorId[bytes4(_request.dexData)], XBridgeErrors.ERROR_SELECTOR_ID);\n\n        // Set payer and receiver addresses for potential refund\n        payer = msg.sender;\n        receiver = address(this);\n\n        // doCommission\n        (uint256 commissionAmount, bytes memory extDataWithoutLast32) = _doCommission(_request.fromTokenAmount, _request.fromToken, _request.extData);\n        _request.extData = extDataWithoutLast32;\n\n        // 1. prepare and swap\n        if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { //FROM NATIVE\n            require(msg.value - commissionAmount >= _request.fromTokenAmount, XBridgeErrors.INVALID_MSG_VALUE);\n            if (_request.toToken == XBridgeConstants.WETH) { //ETH => WETH\n                vars.success = _swapWrap(address(this), address(this), _request.fromTokenAmount, false);\n            } else { // ETH => ERC20, use dexRouter       \n                (vars.success, vars.result) = dexRouter.call{value : _request.fromTokenAmount}(_request.dexData);\n            }\n        } else { // FROM ERC20\n            if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                // WETH => ETH\n                vars.success = _swapWrap(msg.sender, address(this), _request.fromTokenAmount, true);\n            } else { // ERC20 => ERC20, use dexRouter\n                (vars.success, vars.result) = dexRouter.call(_request.dexData);\n            }\n        }\n        delete payer;\n        delete receiver;\n        // 2. check result and balance\n\n        require(vars.success,vars.result.length == 0 ? XBridgeErrors.INTERNAL_WRAP_FAIL : RevertReasonParser.parse(vars.result, XBridgeErrors.DEX_ROUTER_ERR));\n        vars.toTokenBalance = _getBalanceOf(_request.toToken) - vars.toTokenBalanceOrigin; // toToken added\n        require(vars.toTokenBalance >= vars.gasFeeAmount + _request.toTokenMinAmount, XBridgeErrors.MIN_AMOUNT_ERR);\n\n        // 3. Receive to token for relay gas token on target chain to user\n        _transferToken(feeTo, _request.toToken, vars.gasFeeAmount);\n\n        // 4. Bridge the toToken to the target chain\n        vars.toTokenBalance = vars.toTokenBalance - vars.gasFeeAmount;\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n            // Internal with BridgeAdaptorBase, so it is safe to use payable\n            BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{\n                value: vars.toTokenBalance + msg.value\n            }(\n                msg.sender,\n                _request.to,\n                msg.sender, // refund to msg.sender\n                _request.toToken,\n                vars.toTokenBalance,\n                vars.toChainId,\n                _request.data\n            );\n        } else {\n            _transferToken(vars.adaptor, _request.toToken, vars.toTokenBalance);\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN){\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value - commissionAmount - _request.fromTokenAmount }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            } else {\n                BridgeAdaptorBase(payable(vars.adaptor)).outboundBridgeTo{value : msg.value }(\n                    msg.sender,\n                    _request.to,\n                    msg.sender, // refund to msg.sender\n                    _request.toToken,\n                    vars.toTokenBalance,\n                    vars.toChainId,\n                    _request.data\n                );\n            }\n        }\n\n        // Construct extension data and emit the LogBridgeTo event\n        bytes32[] memory ext = _constructExt(\n                                    vars.orderId,\n                                    vars.toChainId,\n                                    _request.adaptorId,\n                                    _request.to,\n                                    _request.data,\n                                    _request.extData\n                                );\n        emit LogSwapAndBridgeTo(\n            _request.adaptorId,\n            msg.sender,\n            _request.to,\n            _request.fromToken,\n            _request.fromTokenAmount,\n            _request.toToken,\n            vars.toTokenBalance,\n            vars.gasFeeAmount,\n            ext\n        );\n\n        // 5. Check balance\n        if (_request.toToken == XBridgeConstants.NATIVE_TOKEN){\n            // if toToken equal nativeToken, should add msg.value\n            require(_getBalanceOf(_request.toToken) + msg.value >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        } else {\n            require(_getBalanceOf(_request.toToken) >= vars.toTokenBalanceOrigin, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a permit on an ERC20 token if a permit data is provided.\n     * @param token Address of the ERC20 token.\n     * @param permit Permit data containing the necessary parameters for the permit function.\n     */\n    function _permit(address token, bytes calldata permit) internal {\n        if (permit.length > 0) {\n            bool success;\n            bytes memory result;\n            if (permit.length == 32 * 7) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            } else if (permit.length == 32 * 8) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (success, result) = token.call(abi.encodePacked(IDaiLikePermit.permit.selector, permit));\n            } else {\n                revert("Wrong permit length");\n            }\n            if (!success) {\n                revert(RevertReasonParser.parse(result, "Permit failed: "));\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function to receive gas tokens from the source chain and transfer them to the specified recipient.\n     * @param _request The ReceiveGasRequest struct containing details about the gas token receipt.\n     * @dev Performs necessary validations, updates state, and emits the GasTokenReceived event.\n     */\n    function _receiveGasTokenInternal(ReceiveGasRequest memory _request) internal {\n        require(_request.amount <= sysRatio[XBridgeConstants.GAS_TOKEN_RECEIVE_MAX_INDEX], XBridgeErrors.EXCEED_ALLOWED_GAS);\n        require(!receiveGasTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_RECEIVE_GAS);\n        receiveGasTx[_request.srcChainId][_request.srcTxHash] = true;\n        _transferToken(_request.to, XBridgeConstants.NATIVE_TOKEN, _request.amount);\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        emit GasTokenReceived(_request.to, _request.amount, _request.srcChainId, ext);\n    }\n\n    /**\n     * @notice Internal function to decode a message and its signature to extract relevant information.\n     * @param _message The encoded message containing information about the oracle request.\n     * @param _signature The signature of the message for authentication.\n     * @return source The address of the message sender recovered from the signature.\n     * @return thisChainId The chain ID of this contract.\n     * @return thisContractAddress The address of this contract.\n     * @return oracleInfo An OracleInfo struct containing details of the oracle request.\n     * @dev Decodes the message and signature to extract source address, chain ID, contract address, and oracle request details.\n     */\n    function _decode(bytes memory _message, bytes memory _signature)\n        internal\n        pure\n        returns (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        )\n    {\n        { // fix Stack too deep\n            (bytes32 r, bytes32 s, uint8 v) = abi.decode(_signature, (bytes32, bytes32, uint8));\n            bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(_message)));\n            source = ecrecover(hash, v, r, s);\n        }\n        (\n            thisChainId,\n            thisContractAddress,\n            oracleInfo.srcChainId,\n            oracleInfo.txHash,\n            oracleInfo.to,\n            oracleInfo.token,\n            oracleInfo.amount,\n            oracleInfo.actualAmount\n        ) = abi.decode(_message, (uint256, address, uint256, bytes32, bytes32, bytes32, uint256, uint256));\n        return (source, thisChainId, thisContractAddress, oracleInfo);\n    }\n\n    /**\n     * @notice Internal function to verify the oracle signature and details for a swap request.\n     * @param _request The SwapRequest struct containing swap details.\n     * @param _amount The amount to be verified against the oracle threshold.\n     * @dev Verifies the oracle signature, source address, and additional details for the swap request.\n     */\n    function _verifyOracle(\n        SwapRequest memory _request,\n        uint256 _amount\n    )\n        view\n        internal\n    {\n        (bytes memory message, bytes memory signature) = abi.decode(_request.extData, (bytes, bytes));\n        (\n            address source,\n            uint256 thisChainId,\n            address thisContractAddress,\n            OracleInfo memory oracleInfo\n        ) = _decode(message, signature);\n\n        // Validate the source address, oracle proxy status, chain ID, contract address, and request details\n        require(source != address(0), XBridgeErrors.ZERO_SIGNER);\n        require(proxies[source], XBridgeErrors.NOT_ORACLE_PROXY);\n        require(thisChainId == sysRatio[XBridgeConstants.CHAIN_ID_INDEX], XBridgeErrors.ERR_CHAIN_ID);\n        require(thisContractAddress == address(this), XBridgeErrors.CONTRACT_ADDRESS_ERROR);\n        require(_request.srcTxHash == oracleInfo.txHash, XBridgeErrors.ORACLE_NO_INFO);\n        require(_request.to == address(uint160(uint256(oracleInfo.to))), XBridgeErrors.ORACLE_TO_ADDRESS_ERR);\n        require(_request.fromToken == address(uint160(uint256(oracleInfo.token))), XBridgeErrors.ORACLE_TOKEN_ADDRESS_ERR);\n\n        // Calculate the high threshold based on the actualAmount and configured ratio\n        uint256 ratio = sysRatio[XBridgeConstants.CLAIM_TOKEN_RATIO_MAX_INDEX];\n        uint256 high = oracleInfo.actualAmount * (ratio + XBridgeConstants.DEFAULT_RATIO_BASE) / XBridgeConstants.DEFAULT_RATIO_BASE;\n\n        // Check if the requested amount is within the allowed high threshold\n        require(_amount <= high, XBridgeErrors.ORACLE_TOKEN_AMOUNT_ERR);\n    }\n\n    /**\n     * @notice Internal function to process the claim for a swap request, including gas fee handling and token transfer.\n     * @param _request The SwapRequest struct containing swap details.\n     * @dev Verifies the oracle, handles gas fees, performs token swap or transfer and emits the Claimed event.\n     */\n    function _claimInternal(SwapRequest memory _request) internal {\n        uint256 fromTokenOriginBalance = _getBalanceOf(_request.fromToken);\n\n        // Calculate the total amount needed, including swap amount and gas fees\n        uint256 fromTokenNeed = _request.amount + _request.gasFeeAmount;\n\n        // Verify the oracle signature and threshold for the source token\n        _verifyOracle(_request, fromTokenNeed);\n        require(fromTokenOriginBalance >= fromTokenNeed, XBridgeErrors.NO_ENOUGH_MONEY);\n        require(dexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        require(!paidTx[_request.srcChainId][_request.srcTxHash], XBridgeErrors.HAS_PAID);\n        paidTx[_request.srcChainId][_request.srcTxHash] = true;\n\n        // Initialize extension data for the Claimed event\n        bytes32[] memory ext = new bytes32[](1);\n        ext[0] = _request.srcTxHash;\n        bool success;\n        bytes memory result;\n        string memory errInfo;\n\n        // 1. Handle gas fee\n        _transferToken(feeTo, _request.fromToken, _request.gasFeeAmount);\n\n        // 2. Perform token swap or transfer to the user\n        if (_request.dexData.length > 0) {\n            // swap\n            uint256 toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to);\n\n            // Exchange anypair using the dexRouter except WETH<=>ETH\n            payer = address(this);\n            receiver = _request.to;\n            if (_request.fromToken == XBridgeConstants.NATIVE_TOKEN) { // FROM NATIVE\n                if (_request.toToken == XBridgeConstants.WETH) { // ETH => WETH\n                    success = _swapWrap(address(this), _request.to, _request.amount, false);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    }  \n                } else { // ETH => ERC20, use dexRouter\n                    (success, result) = dexRouter.call{value : _request.amount}(_request.dexData); \n                }\n            } else { // FROM ERC20\n                if (_request.fromToken == XBridgeConstants.WETH && _request.toToken == XBridgeConstants.NATIVE_TOKEN) {\n                    // WETH => ETH\n                    success =_swapWrap(address(this), _request.to, _request.amount, true);\n                    if (!success) {\n                        errInfo = XBridgeErrors.INTERNAL_WRAP_FAIL;\n                    } \n                } else { // ERC20 => ERC20, use dexRouter\n                    address tokenApprove = IApproveProxy(XBridgeConstants.APPROVE_PROXY).tokenApprove();\n                    IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, _request.amount);\n                    (success, result) = dexRouter.call(_request.dexData);\n                    if (IERC20Upgradeable(_request.fromToken).allowance(address(this), tokenApprove) != 0){\n                        IERC20Upgradeable(_request.fromToken).safeApprove(tokenApprove, 0);  \n                    }\n                }\n            }\n            if (!success && result.length > 0) {\n                errInfo = RevertReasonParser.parse(result, XBridgeErrors.DEX_ROUTER_ERR);\n            }\n            delete payer; // payer = 0;\n            delete receiver;\n            if (!success) { // transfer fromToken if swap failed\n                _transferToken(_request.to, _request.fromToken, _request.amount);\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            } else {\n                toTokenReceiverBalance = _getBalanceOf(_request.toToken, _request.to) - toTokenReceiverBalance;\n                emit Claimed(_request.to, _request.fromToken, _request.toToken, 0, toTokenReceiverBalance, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n            }\n        } else { // transfer token\n            errInfo = XBridgeConstants.__REFUND__;\n            _transferToken(_request.to, _request.fromToken, _request.amount);\n            emit Claimed(_request.to, _request.fromToken, _request.toToken, _request.amount, 0, _request.gasFeeAmount, _request.srcChainId, errInfo, ext);\n        }\n\n        // 3. Check the final balance of the source token\n        require(fromTokenOriginBalance - _getBalanceOf(_request.fromToken) <= fromTokenNeed, XBridgeErrors.SLASH_MUCH_TOO_MONEY);\n    }\n\n    /**\n     * @dev Internal function to swap and wrap tokens.\n     * @param from The address to transfer the tokens from.\n     * @param to The address to transfer the wrapped tokens to.\n     * @param amount The amount of tokens to swap and wrap.\n     * @param reversed Boolean indicating whether the swap is reversed (WETH => ETH).\n     * @return A boolean indicating the success of the swap and wrap operation.\n     */\n    function _swapWrap(\n        address from,\n        address to,\n        uint256 amount,\n        bool reversed\n    ) internal returns (bool) {\n        require(amount > 0,  XBridgeErrors.WRAP_AMOUNT_ZERO);\n        if (reversed) {\n            // reversed == true: WETH => ETH\n            if (from == address(this)){\n                IWETH(address(uint160(XBridgeConstants.WETH))).transfer(XBridgeConstants.WNATIVE_RELAY, amount);\n            } else {\n                _deposit(from, XBridgeConstants.WNATIVE_RELAY, XBridgeConstants.WETH, amount);\n            }\n            IWNativeRelayer(XBridgeConstants.WNATIVE_RELAY).withdraw(amount);\n            if (to != address(this)){\n                (bool success, ) = payable(to).call{value: amount}("");\n                require(success, XBridgeErrors.TRANSFER_ETH_FAILD);\n            }\n        } else {\n            // reversed == false: ETH => WETH\n            IWETH(XBridgeConstants.WETH).deposit{value: amount}();\n            if (to != address(this)){\n                IERC20Upgradeable(XBridgeConstants.WETH).safeTransfer(to, amount);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Internal function to handle commission logic\n     * @param inputAmount The amount of tokens to be transferred.\n     * @param commissionToken The address of the ERC20 token to be transferred.\n     * @param extData Additional extension data containing user-specific information.\n     * @return commissionAmount The amount of commission tokens to be transferred.\n     * @return extDataWithoutLast32 Additional extension data containing user-specific information without last 32 bytes.\n     */\n    function _doCommission( uint256 inputAmount, address commissionToken, bytes memory extData) internal returns (uint256 commissionAmount, bytes memory extDataWithoutLast32) {\n        \n        // Retrieve commission info from the last 32 bytes of extData\n        uint256 commissionInfo;\n        assembly {\n            commissionInfo := calldataload(sub(calldatasize(),0x20))\n        }\n\n        if ((commissionInfo & _COMMISSION_FLAG_MASK) == OKX_COMMISSION) {\n            // 0. decode the commissionInfo\n            address referrerAddress = address(uint160(commissionInfo & _REFERRER_MASK));\n            uint256 commissionRate = uint256((commissionInfo & _COMMISSION_FEE_MASK) >> 160);\n\n            // 1. Check the commission ratio. CommissionFeeAmount = fromTokenAmount * Rate / (10000 - Rate)\n            require(commissionRate <= commissionRateLimit, XBridgeErrors.COMMISSION_ERROR_RATE);\n            commissionAmount = (inputAmount * commissionRate) / (10000 - commissionRate);\n\n            // 2. Perform commission\n            if (commissionToken == XBridgeConstants.NATIVE_TOKEN) {\n                (bool success,) = payable(referrerAddress).call{value: commissionAmount}("");\n                require(success, XBridgeErrors.COMMISSION_ERROR_ETHER); \n            } else {\n                _deposit(msg.sender, referrerAddress, commissionToken, commissionAmount);\n            }\n\n            // 3. Restore extData\n            uint256 extDataSize = extData.length;\n            extDataWithoutLast32 = new bytes(extDataSize - 32);\n            for (uint256 i = 0; i < extDataSize - 32; i++) {\n                extDataWithoutLast32[i] = extData[i];\n            }\n\n            emit CommissionRecord(commissionAmount, referrerAddress);\n        } else {\n            extDataWithoutLast32 = extData;\n        }\n    }\n\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n\n    function setAdmin(address _newAdmin) external onlyOwner {\n        require(_newAdmin != address(0), XBridgeErrors.ADDRESS_0);\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin);\n    }\n\n    function setDexRouter(address _newDexRouter) external onlyAdmin {\n        require(_newDexRouter != address(0), XBridgeErrors.ADDRESS_0);\n        dexRouter = _newDexRouter;\n        emit DexRouterChanged(_newDexRouter);\n    }\n\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n\n    function setAdaptors(uint256[] calldata _ids, address[] calldata _adaptors) external onlyAdmin {\n        require(_ids.length == _adaptors.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            adaptorInfo[_ids[i]] = _adaptors[i];\n            emit AdaptorsChanged(_ids[i], _adaptors[i]);\n        }\n    }\n\n    function setFeeTo(address _newFeeTo) external onlyAdmin {\n        require(_newFeeTo != address(0), XBridgeErrors.ADDRESS_0);\n        feeTo = _newFeeTo;\n        emit FeeToChanged(_newFeeTo);\n    }\n\n    function setMpc(address[] memory _mpcList, bool[] memory _v) external onlyAdmin {\n        require(_mpcList.length == _v.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < _mpcList.length; i++) {\n            mpc[_mpcList[i]] = _v[i];\n            emit MpcChanged(_mpcList[i], _v[i]);\n        }\n    }\n\n    function setSysRatio(uint256 _index, uint256 _v) external onlyAdmin {\n        sysRatio[_index] = _v;\n        emit SysRatioChanged(_index, _v);\n    }\n\n    function setProxies(address[] memory proxiesList, bool[] memory values)\n        external\n        onlyAdmin\n    {\n        require(proxiesList.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < proxiesList.length; i++) {\n            proxies[proxiesList[i]] = values[i];\n            emit ProxiesChanged(proxiesList[i], values[i]);\n        }\n    }\n\n    function setAccessSelectorId(bytes4[] memory selectorIds, bool[] memory values) external onlyAdmin{\n        require(selectorIds.length == values.length, XBridgeErrors.LENGTH_NOT_EQUAL);\n        for (uint256 i = 0; i < selectorIds.length; i++) {\n            accessSelectorId[selectorIds[i]] = values[i];\n            emit AccessSelectorIdChanged(selectorIds[i], values[i]);\n        }\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n\n    /**\n     * @notice Initiates the bridge operation to transfer assets to another chain using the bridge.\n     * @param _request The BridgeRequestV2 struct containing the details of the bridge operation.\n     */\n    function bridgeToV2(BridgeRequestV2 memory _request)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _bridgeToV2Internal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation using the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     */\n    function swapBridgeToV2(SwapBridgeRequestV2 memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Initiates a swap and bridge operation with permit using V2 of the bridge.\n     * @param _request The SwapBridgeRequestV2 struct containing the details of the swap and bridge operation.\n     * @param _signature The permit signature for the fromToken.\n     */\n    function swapBridgeToWithPermit(\n        SwapBridgeRequestV2 calldata _request,\n        bytes calldata _signature\n    ) external nonReentrant whenNotPaused {\n        _permit(_request.fromToken, _signature);\n        _swapBridgeToInternal(_request);\n    }\n\n    /**\n     * @notice Completed receiving gas tokens from the source chain.\n     * @param _request The ReceiveGasRequest struct containing the details of this operation.\n     */\n    function receiveGasToken(ReceiveGasRequest memory _request)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        require(msg.value == _request.amount, XBridgeErrors.INVALID_MSG_VALUE);\n        _receiveGasTokenInternal(_request);\n    }\n\n    /**\n     * @notice Claims the assets on the current chain as part of the cross-chain swap.\n     * @param _request The SwapRequest struct containing details of the asset claiming operation.\n     */\n    function claim(SwapRequest memory _request)\n        public\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        _claimInternal(_request);\n    }\n\n    /**\n     * @notice Performs batch operations including Gas Token receiving and asset claiming.\n     * @param _gasRequest Array of ReceiveGasRequest structs containing details of Gas Token receiving operations.\n     * @param _claimRequest Array of SwapRequest structs containing details of asset claiming operations.\n     */\n    function doBatch(ReceiveGasRequest[] memory _gasRequest, SwapRequest[] memory _claimRequest)\n        public\n        payable\n        nonReentrant\n        whenNotPaused\n        onlyMPC\n    {\n        uint256 leftValue = msg.value;\n        for (uint256 i = 0; i < _gasRequest.length; i++) {\n            _receiveGasTokenInternal(_gasRequest[i]);\n            // DOES NOT need check, because it will overflow if less than amount\n            leftValue -= _gasRequest[i].amount;\n        }\n        for (uint256 i = 0; i < _claimRequest.length; i++) {\n            _claimInternal(_claimRequest[i]);\n        }\n        require(leftValue == 0, XBridgeErrors.LEFT_VALUE_NOT_ZERO);\n    }\n\n    function payerReceiver() external view returns(address, address) {\n        return (payer, receiver);\n    }\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 1519, 'end_line': 1521, 'offset_start': 62582, 'offset_end': 62692, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 1523, 'end_line': 1525, 'offset_start': 62699, 'offset_end': 62807, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 1540, 'end_line': 1546, 'offset_start': 63294, 'offset_end': 63580, 'content': 'function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 1548, 'end_line': 1552, 'offset_start': 63587, 'offset_end': 63795, 'content': 'function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 1558, 'end_line': 1560, 'offset_start': 63975, 'offset_end': 64081, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'BridgeAdaptorBase.tor', 'start_line': 1591, 'end_line': 1597, 'offset_start': 64994, 'offset_end': 65270, 'content': 'constructor(address _xBridge, address[] memory _routersList) {\n        require(_xBridge != address(0), XBridgeErrors.ADDRESS_0);\n        xBridge = _xBridge;\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = true;\n        }\n    }', 'contract_name': 'BridgeAdaptorBase', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address public immutable xBridge;\n\n    mapping(address => bool) public routers;\n\n    constructor(address _xBridge, address[] memory _routersList) {\n        require(_xBridge != address(0), XBridgeErrors.ADDRESS_0);\n        xBridge = _xBridge;\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = true;\n        }\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event LogOutboundBridgeTo(address _from, address _to, address _token, uint256 _amount, bytes32 _extraData);\n\n    event EmergencyWithdraw(address indexed _to, address _token, uint amount);\n\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n    modifier onlyXBridge() {\n        require(msg.sender == xBridge, XBridgeErrors.ONLY_X_BRIDGE);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n    function _approve(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            IERC20(token).safeApprove(spender, amount);\n        } else {\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, amount);\n        }\n    }\n\n    function _approve2(address token, address spender, uint256 amount) internal {\n        uint256 preAllowance = IERC20(token).allowance(address(this), spender);\n        if (preAllowance == 0) {\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        } else if (preAllowance < amount){\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n    function setRouters(address[] calldata _routersList, bool[] calldata _v) public onlyOwner {\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = _v[i];\n        }\n    }\n\n    // workaround for a possible solidity bug\n    function withdrawEmergency(address _to, address _token, uint _amount) public onlyOwner {\n        if (_token == XBridgeConstants.NATIVE_TOKEN) {\n            payable(_to).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n        emit EmergencyWithdraw(_to, _token, _amount);\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n    function outboundBridgeTo(\n        address _from,\n        address _to,\n        address _refundAddress,\n        address _token,\n        uint256 _amount,\n        uint256 _toChainId,\n        bytes memory _data\n    ) external payable virtual;\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'BridgeAdaptorBase._approve', 'start_line': 1617, 'end_line': 1624, 'offset_start': 65928, 'offset_end': 66267, 'content': 'function _approve(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            IERC20(token).safeApprove(spender, amount);\n        } else {\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, amount);\n        }\n    }', 'contract_name': 'BridgeAdaptorBase', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address public immutable xBridge;\n\n    mapping(address => bool) public routers;\n\n    constructor(address _xBridge, address[] memory _routersList) {\n        require(_xBridge != address(0), XBridgeErrors.ADDRESS_0);\n        xBridge = _xBridge;\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = true;\n        }\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event LogOutboundBridgeTo(address _from, address _to, address _token, uint256 _amount, bytes32 _extraData);\n\n    event EmergencyWithdraw(address indexed _to, address _token, uint amount);\n\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n    modifier onlyXBridge() {\n        require(msg.sender == xBridge, XBridgeErrors.ONLY_X_BRIDGE);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n    function _approve(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            IERC20(token).safeApprove(spender, amount);\n        } else {\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, amount);\n        }\n    }\n\n    function _approve2(address token, address spender, uint256 amount) internal {\n        uint256 preAllowance = IERC20(token).allowance(address(this), spender);\n        if (preAllowance == 0) {\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        } else if (preAllowance < amount){\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n    function setRouters(address[] calldata _routersList, bool[] calldata _v) public onlyOwner {\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = _v[i];\n        }\n    }\n\n    // workaround for a possible solidity bug\n    function withdrawEmergency(address _to, address _token, uint _amount) public onlyOwner {\n        if (_token == XBridgeConstants.NATIVE_TOKEN) {\n            payable(_to).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n        emit EmergencyWithdraw(_to, _token, _amount);\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n    function outboundBridgeTo(\n        address _from,\n        address _to,\n        address _refundAddress,\n        address _token,\n        uint256 _amount,\n        uint256 _toChainId,\n        bytes memory _data\n    ) external payable virtual;\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'BridgeAdaptorBase._approve2', 'start_line': 1626, 'end_line': 1634, 'offset_start': 66274, 'offset_end': 66707, 'content': 'function _approve2(address token, address spender, uint256 amount) internal {\n        uint256 preAllowance = IERC20(token).allowance(address(this), spender);\n        if (preAllowance == 0) {\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        } else if (preAllowance < amount){\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }', 'contract_name': 'BridgeAdaptorBase', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address public immutable xBridge;\n\n    mapping(address => bool) public routers;\n\n    constructor(address _xBridge, address[] memory _routersList) {\n        require(_xBridge != address(0), XBridgeErrors.ADDRESS_0);\n        xBridge = _xBridge;\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = true;\n        }\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event LogOutboundBridgeTo(address _from, address _to, address _token, uint256 _amount, bytes32 _extraData);\n\n    event EmergencyWithdraw(address indexed _to, address _token, uint amount);\n\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n    modifier onlyXBridge() {\n        require(msg.sender == xBridge, XBridgeErrors.ONLY_X_BRIDGE);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n    function _approve(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            IERC20(token).safeApprove(spender, amount);\n        } else {\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, amount);\n        }\n    }\n\n    function _approve2(address token, address spender, uint256 amount) internal {\n        uint256 preAllowance = IERC20(token).allowance(address(this), spender);\n        if (preAllowance == 0) {\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        } else if (preAllowance < amount){\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n    function setRouters(address[] calldata _routersList, bool[] calldata _v) public onlyOwner {\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = _v[i];\n        }\n    }\n\n    // workaround for a possible solidity bug\n    function withdrawEmergency(address _to, address _token, uint _amount) public onlyOwner {\n        if (_token == XBridgeConstants.NATIVE_TOKEN) {\n            payable(_to).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n        emit EmergencyWithdraw(_to, _token, _amount);\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n    function outboundBridgeTo(\n        address _from,\n        address _to,\n        address _refundAddress,\n        address _token,\n        uint256 _amount,\n        uint256 _toChainId,\n        bytes memory _data\n    ) external payable virtual;\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'BridgeAdaptorBase.setRouters', 'start_line': 1638, 'end_line': 1642, 'offset_start': 66827, 'offset_end': 67039, 'content': 'function setRouters(address[] calldata _routersList, bool[] calldata _v) public onlyOwner {\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = _v[i];\n        }\n    }', 'contract_name': 'BridgeAdaptorBase', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address public immutable xBridge;\n\n    mapping(address => bool) public routers;\n\n    constructor(address _xBridge, address[] memory _routersList) {\n        require(_xBridge != address(0), XBridgeErrors.ADDRESS_0);\n        xBridge = _xBridge;\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = true;\n        }\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event LogOutboundBridgeTo(address _from, address _to, address _token, uint256 _amount, bytes32 _extraData);\n\n    event EmergencyWithdraw(address indexed _to, address _token, uint amount);\n\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n    modifier onlyXBridge() {\n        require(msg.sender == xBridge, XBridgeErrors.ONLY_X_BRIDGE);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n    function _approve(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            IERC20(token).safeApprove(spender, amount);\n        } else {\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, amount);\n        }\n    }\n\n    function _approve2(address token, address spender, uint256 amount) internal {\n        uint256 preAllowance = IERC20(token).allowance(address(this), spender);\n        if (preAllowance == 0) {\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        } else if (preAllowance < amount){\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n    function setRouters(address[] calldata _routersList, bool[] calldata _v) public onlyOwner {\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = _v[i];\n        }\n    }\n\n    // workaround for a possible solidity bug\n    function withdrawEmergency(address _to, address _token, uint _amount) public onlyOwner {\n        if (_token == XBridgeConstants.NATIVE_TOKEN) {\n            payable(_to).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n        emit EmergencyWithdraw(_to, _token, _amount);\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n    function outboundBridgeTo(\n        address _from,\n        address _to,\n        address _refundAddress,\n        address _token,\n        uint256 _amount,\n        uint256 _toChainId,\n        bytes memory _data\n    ) external payable virtual;\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'BridgeAdaptorBase.withdrawEmergency', 'start_line': 1645, 'end_line': 1652, 'offset_start': 67092, 'offset_end': 67420, 'content': 'function withdrawEmergency(address _to, address _token, uint _amount) public onlyOwner {\n        if (_token == XBridgeConstants.NATIVE_TOKEN) {\n            payable(_to).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n        emit EmergencyWithdraw(_to, _token, _amount);\n    }', 'contract_name': 'BridgeAdaptorBase', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address public immutable xBridge;\n\n    mapping(address => bool) public routers;\n\n    constructor(address _xBridge, address[] memory _routersList) {\n        require(_xBridge != address(0), XBridgeErrors.ADDRESS_0);\n        xBridge = _xBridge;\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = true;\n        }\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event LogOutboundBridgeTo(address _from, address _to, address _token, uint256 _amount, bytes32 _extraData);\n\n    event EmergencyWithdraw(address indexed _to, address _token, uint amount);\n\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n    modifier onlyXBridge() {\n        require(msg.sender == xBridge, XBridgeErrors.ONLY_X_BRIDGE);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n    function _approve(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            IERC20(token).safeApprove(spender, amount);\n        } else {\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, amount);\n        }\n    }\n\n    function _approve2(address token, address spender, uint256 amount) internal {\n        uint256 preAllowance = IERC20(token).allowance(address(this), spender);\n        if (preAllowance == 0) {\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        } else if (preAllowance < amount){\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n    function setRouters(address[] calldata _routersList, bool[] calldata _v) public onlyOwner {\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = _v[i];\n        }\n    }\n\n    // workaround for a possible solidity bug\n    function withdrawEmergency(address _to, address _token, uint _amount) public onlyOwner {\n        if (_token == XBridgeConstants.NATIVE_TOKEN) {\n            payable(_to).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n        emit EmergencyWithdraw(_to, _token, _amount);\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n    function outboundBridgeTo(\n        address _from,\n        address _to,\n        address _refundAddress,\n        address _token,\n        uint256 _amount,\n        uint256 _toChainId,\n        bytes memory _data\n    ) external payable virtual;\n\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'BridgeAdaptorBase.outboundBridgeTo', 'start_line': 1657, 'end_line': 1665, 'offset_start': 67541, 'offset_end': 67778, 'content': 'function outboundBridgeTo(\n        address _from,\n        address _to,\n        address _refundAddress,\n        address _token,\n        uint256 _amount,\n        uint256 _toChainId,\n        bytes memory _data\n    ) external payable virtual;', 'contract_name': 'BridgeAdaptorBase', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address public immutable xBridge;\n\n    mapping(address => bool) public routers;\n\n    constructor(address _xBridge, address[] memory _routersList) {\n        require(_xBridge != address(0), XBridgeErrors.ADDRESS_0);\n        xBridge = _xBridge;\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = true;\n        }\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event LogOutboundBridgeTo(address _from, address _to, address _token, uint256 _amount, bytes32 _extraData);\n\n    event EmergencyWithdraw(address indexed _to, address _token, uint amount);\n\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n    modifier onlyXBridge() {\n        require(msg.sender == xBridge, XBridgeErrors.ONLY_X_BRIDGE);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n    function _approve(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            IERC20(token).safeApprove(spender, amount);\n        } else {\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, amount);\n        }\n    }\n\n    function _approve2(address token, address spender, uint256 amount) internal {\n        uint256 preAllowance = IERC20(token).allowance(address(this), spender);\n        if (preAllowance == 0) {\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        } else if (preAllowance < amount){\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n    function setRouters(address[] calldata _routersList, bool[] calldata _v) public onlyOwner {\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = _v[i];\n        }\n    }\n\n    // workaround for a possible solidity bug\n    function withdrawEmergency(address _to, address _token, uint _amount) public onlyOwner {\n        if (_token == XBridgeConstants.NATIVE_TOKEN) {\n            payable(_to).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n        emit EmergencyWithdraw(_to, _token, _amount);\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n    function outboundBridgeTo(\n        address _from,\n        address _to,\n        address _refundAddress,\n        address _token,\n        uint256 _amount,\n        uint256 _toChainId,\n        bytes memory _data\n    ) external payable virtual;\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'BridgeAdaptorBase.', 'start_line': 1667, 'end_line': 1667, 'offset_start': 67785, 'offset_end': 67813, 'content': 'receive() external payable {}', 'contract_name': 'BridgeAdaptorBase', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address public immutable xBridge;\n\n    mapping(address => bool) public routers;\n\n    constructor(address _xBridge, address[] memory _routersList) {\n        require(_xBridge != address(0), XBridgeErrors.ADDRESS_0);\n        xBridge = _xBridge;\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = true;\n        }\n    }\n\n    //-------------------------------\n    //------- Events ----------------\n    //-------------------------------\n    event LogOutboundBridgeTo(address _from, address _to, address _token, uint256 _amount, bytes32 _extraData);\n\n    event EmergencyWithdraw(address indexed _to, address _token, uint amount);\n\n    //-------------------------------\n    //------- Modifier --------------\n    //-------------------------------\n    modifier onlyXBridge() {\n        require(msg.sender == xBridge, XBridgeErrors.ONLY_X_BRIDGE);\n        _;\n    }\n\n    //-------------------------------\n    //------- Internal Functions ----\n    //-------------------------------\n    function _approve(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            IERC20(token).safeApprove(spender, amount);\n        } else {\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, amount);\n        }\n    }\n\n    function _approve2(address token, address spender, uint256 amount) internal {\n        uint256 preAllowance = IERC20(token).allowance(address(this), spender);\n        if (preAllowance == 0) {\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        } else if (preAllowance < amount){\n            IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n    //-------------------------------\n    //------- Admin functions -------\n    //-------------------------------\n    function setRouters(address[] calldata _routersList, bool[] calldata _v) public onlyOwner {\n        for (uint256 i = 0; i < _routersList.length; i++) {\n            routers[_routersList[i]] = _v[i];\n        }\n    }\n\n    // workaround for a possible solidity bug\n    function withdrawEmergency(address _to, address _token, uint _amount) public onlyOwner {\n        if (_token == XBridgeConstants.NATIVE_TOKEN) {\n            payable(_to).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n        }\n        emit EmergencyWithdraw(_to, _token, _amount);\n    }\n\n    //-------------------------------\n    //------- Users Functions -------\n    //-------------------------------\n    function outboundBridgeTo(\n        address _from,\n        address _to,\n        address _refundAddress,\n        address _token,\n        uint256 _amount,\n        uint256 _toChainId,\n        bytes memory _data\n    ) external payable virtual;\n\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IApproveProxy.owner', 'start_line': 1674, 'end_line': 1674, 'offset_start': 67905, 'offset_end': 67953, 'content': 'function owner() external view returns (address);', 'contract_name': 'IApproveProxy', 'contract_code': '{\n    function owner() external view returns (address);\n    \n    function isAllowedProxy(address _proxy) external view returns (bool);\n\n    function claimTokens(\n        address token,\n        address who,\n        address dest,\n        uint256 amount\n    ) external;\n\n    function tokenApprove() external view returns (address);\n\n    function addProxy(address _newProxy) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IApproveProxy.isAllowedProxy', 'start_line': 1676, 'end_line': 1676, 'offset_start': 67964, 'offset_end': 68032, 'content': 'function isAllowedProxy(address _proxy) external view returns (bool);', 'contract_name': 'IApproveProxy', 'contract_code': '{\n    function owner() external view returns (address);\n    \n    function isAllowedProxy(address _proxy) external view returns (bool);\n\n    function claimTokens(\n        address token,\n        address who,\n        address dest,\n        uint256 amount\n    ) external;\n\n    function tokenApprove() external view returns (address);\n\n    function addProxy(address _newProxy) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IApproveProxy.claimTokens', 'start_line': 1678, 'end_line': 1683, 'offset_start': 68039, 'offset_end': 68164, 'content': 'function claimTokens(\n        address token,\n        address who,\n        address dest,\n        uint256 amount\n    ) external;', 'contract_name': 'IApproveProxy', 'contract_code': '{\n    function owner() external view returns (address);\n    \n    function isAllowedProxy(address _proxy) external view returns (bool);\n\n    function claimTokens(\n        address token,\n        address who,\n        address dest,\n        uint256 amount\n    ) external;\n\n    function tokenApprove() external view returns (address);\n\n    function addProxy(address _newProxy) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IApproveProxy.tokenApprove', 'start_line': 1685, 'end_line': 1685, 'offset_start': 68171, 'offset_end': 68226, 'content': 'function tokenApprove() external view returns (address);', 'contract_name': 'IApproveProxy', 'contract_code': '{\n    function owner() external view returns (address);\n    \n    function isAllowedProxy(address _proxy) external view returns (bool);\n\n    function claimTokens(\n        address token,\n        address who,\n        address dest,\n        uint256 amount\n    ) external;\n\n    function tokenApprove() external view returns (address);\n\n    function addProxy(address _newProxy) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IApproveProxy.addProxy', 'start_line': 1687, 'end_line': 1687, 'offset_start': 68233, 'offset_end': 68278, 'content': 'function addProxy(address _newProxy) external;', 'contract_name': 'IApproveProxy', 'contract_code': '{\n    function owner() external view returns (address);\n    \n    function isAllowedProxy(address _proxy) external view returns (bool);\n\n    function claimTokens(\n        address token,\n        address who,\n        address dest,\n        uint256 amount\n    ) external;\n\n    function tokenApprove() external view returns (address);\n\n    function addProxy(address _newProxy) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.totalSupply', 'start_line': 1716, 'end_line': 1716, 'offset_start': 69068, 'offset_end': 69122, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.balanceOf', 'start_line': 1721, 'end_line': 1721, 'offset_start': 69206, 'offset_end': 69273, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transfer', 'start_line': 1730, 'end_line': 1730, 'offset_start': 69487, 'offset_end': 69556, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.allowance', 'start_line': 1739, 'end_line': 1739, 'offset_start': 69832, 'offset_end': 69914, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.approve', 'start_line': 1755, 'end_line': 1755, 'offset_start': 70568, 'offset_end': 70641, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transferFrom', 'start_line': 1766, 'end_line': 1766, 'offset_start': 70940, 'offset_end': 71027, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 1913, 'end_line': 1919, 'offset_start': 76971, 'offset_end': 77250, 'content': 'function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 1924, 'end_line': 1926, 'offset_start': 77361, 'offset_end': 77460, 'content': 'function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 1931, 'end_line': 1933, 'offset_start': 77577, 'offset_end': 77669, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 1962, 'end_line': 1962, 'offset_start': 78448, 'offset_end': 78502, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 1967, 'end_line': 1967, 'offset_start': 78586, 'offset_end': 78653, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 1976, 'end_line': 1976, 'offset_start': 78867, 'offset_end': 78936, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 1985, 'end_line': 1985, 'offset_start': 79212, 'offset_end': 79294, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 2001, 'end_line': 2001, 'offset_start': 79948, 'offset_end': 80021, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 2012, 'end_line': 2012, 'offset_start': 80320, 'offset_end': 80407, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 2040, 'end_line': 2042, 'offset_start': 81353, 'offset_end': 81527, 'content': 'function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 2048, 'end_line': 2050, 'offset_start': 81767, 'offset_end': 81969, 'content': 'function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeApprove', 'start_line': 2059, 'end_line': 2068, 'offset_start': 82230, 'offset_end': 82802, 'content': 'function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 2074, 'end_line': 2077, 'offset_start': 82994, 'offset_end': 83273, 'content': 'function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 2083, 'end_line': 2089, 'offset_start': 83465, 'offset_end': 83871, 'content': 'function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.forceApprove', 'start_line': 2096, 'end_line': 2103, 'offset_start': 84191, 'offset_end': 84600, 'content': 'function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safePermit', 'start_line': 2109, 'end_line': 2123, 'offset_start': 84753, 'offset_end': 85224, 'content': 'function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 2131, 'end_line': 2138, 'offset_start': 85608, 'offset_end': 86249, 'content': 'function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturnBool', 'start_line': 2148, 'end_line': 2156, 'offset_start': 86751, 'offset_end': 87344, 'content': "function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }", 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IDaiLikePermit.permit', 'start_line': 2164, 'end_line': 2173, 'offset_start': 87480, 'offset_end': 87683, 'content': 'function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IDaiLikePermit', 'contract_code': '{\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.isContract', 'start_line': 2224, 'end_line': 2230, 'offset_start': 89349, 'offset_end': 89668, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 2248, 'end_line': 2253, 'offset_start': 90584, 'offset_end': 90895, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 2273, 'end_line': 2275, 'offset_start': 91638, 'offset_end': 91822, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 2283, 'end_line': 2289, 'offset_start': 92045, 'offset_end': 92267, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 2302, 'end_line': 2304, 'offset_start': 92630, 'offset_end': 92853, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 2312, 'end_line': 2321, 'offset_start': 93102, 'offset_end': 93547, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 2329, 'end_line': 2331, 'offset_start': 93725, 'offset_end': 93921, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 2339, 'end_line': 2346, 'offset_start': 94106, 'offset_end': 94431, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 2354, 'end_line': 2356, 'offset_start': 94611, 'offset_end': 94808, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 2364, 'end_line': 2371, 'offset_start': 94995, 'offset_end': 95319, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 2379, 'end_line': 2395, 'offset_start': 95608, 'offset_end': 96235, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 2403, 'end_line': 2413, 'offset_start': 96457, 'offset_end': 96751, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 2415, 'end_line': 2427, 'offset_start': 96758, 'offset_end': 97297, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.totalSupply', 'start_line': 2436, 'end_line': 2436, 'offset_start': 97402, 'offset_end': 97456, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IWETH', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.balanceOf', 'start_line': 2438, 'end_line': 2438, 'offset_start': 97463, 'offset_end': 97530, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IWETH', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.transfer', 'start_line': 2440, 'end_line': 2440, 'offset_start': 97537, 'offset_end': 97613, 'content': 'function transfer(address recipient, uint256 amount) external returns (bool);', 'contract_name': 'IWETH', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.allowance', 'start_line': 2442, 'end_line': 2442, 'offset_start': 97620, 'offset_end': 97702, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IWETH', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.approve', 'start_line': 2444, 'end_line': 2444, 'offset_start': 97709, 'offset_end': 97782, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IWETH', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.transferFrom', 'start_line': 2446, 'end_line': 2450, 'offset_start': 97789, 'offset_end': 97903, 'content': 'function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);', 'contract_name': 'IWETH', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.deposit', 'start_line': 2452, 'end_line': 2452, 'offset_start': 97910, 'offset_end': 97945, 'content': 'function deposit() external payable;', 'contract_name': 'IWETH', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.withdraw', 'start_line': 2454, 'end_line': 2454, 'offset_start': 97952, 'offset_end': 97991, 'content': 'function withdraw(uint256 wad) external;', 'contract_name': 'IWETH', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWNativeRelayer.owner', 'start_line': 2483, 'end_line': 2483, 'offset_start': 99145, 'offset_end': 99193, 'content': 'function owner() external view returns (address);', 'contract_name': 'IWNativeRelayer', 'contract_code': '{\n    function owner() external view returns (address);\n    function withdraw(uint256 _amount) external;\n    function setCallerOk(address[] calldata whitelistedCallers, bool isOk) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWNativeRelayer.withdraw', 'start_line': 2484, 'end_line': 2484, 'offset_start': 99199, 'offset_end': 99242, 'content': 'function withdraw(uint256 _amount) external;', 'contract_name': 'IWNativeRelayer', 'contract_code': '{\n    function owner() external view returns (address);\n    function withdraw(uint256 _amount) external;\n    function setCallerOk(address[] calldata whitelistedCallers, bool isOk) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWNativeRelayer.setCallerOk', 'start_line': 2485, 'end_line': 2485, 'offset_start': 99248, 'offset_end': 99327, 'content': 'function setCallerOk(address[] calldata whitelistedCallers, bool isOk) external;', 'contract_name': 'IWNativeRelayer', 'contract_code': '{\n    function owner() external view returns (address);\n    function withdraw(uint256 _amount) external;\n    function setCallerOk(address[] calldata whitelistedCallers, bool isOk) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.isContract', 'start_line': 2527, 'end_line': 2533, 'offset_start': 100755, 'offset_end': 101074, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 2551, 'end_line': 2556, 'offset_start': 101990, 'offset_end': 102301, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 2576, 'end_line': 2578, 'offset_start': 103044, 'offset_end': 103228, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 2586, 'end_line': 2592, 'offset_start': 103451, 'offset_end': 103673, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 2605, 'end_line': 2607, 'offset_start': 104036, 'offset_end': 104259, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 2615, 'end_line': 2624, 'offset_start': 104508, 'offset_end': 104953, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 2632, 'end_line': 2634, 'offset_start': 105131, 'offset_end': 105327, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 2642, 'end_line': 2649, 'offset_start': 105512, 'offset_end': 105837, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 2657, 'end_line': 2659, 'offset_start': 106017, 'offset_end': 106214, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 2667, 'end_line': 2674, 'offset_start': 106401, 'offset_end': 106725, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 2682, 'end_line': 2698, 'offset_start': 107014, 'offset_end': 107641, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 2706, 'end_line': 2716, 'offset_start': 107863, 'offset_end': 108157, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 2718, 'end_line': 2730, 'offset_start': 108164, 'offset_end': 108703, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init', 'start_line': 2766, 'end_line': 2768, 'offset_start': 109771, 'offset_end': 109867, 'content': 'function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init_unchained', 'start_line': 2770, 'end_line': 2772, 'offset_start': 109874, 'offset_end': 109968, 'content': 'function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.paused', 'start_line': 2801, 'end_line': 2803, 'offset_start': 110566, 'offset_end': 110649, 'content': 'function paused() public view virtual returns (bool) {\n        return _paused;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requireNotPaused', 'start_line': 2808, 'end_line': 2810, 'offset_start': 110718, 'offset_end': 110823, 'content': 'function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requirePaused', 'start_line': 2815, 'end_line': 2817, 'offset_start': 110896, 'offset_end': 111001, 'content': 'function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._pause', 'start_line': 2826, 'end_line': 2829, 'offset_start': 111137, 'offset_end': 111251, 'content': 'function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._unpause', 'start_line': 2838, 'end_line': 2841, 'offset_start': 111384, 'offset_end': 111500, 'content': 'function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeTransfer', 'start_line': 2876, 'end_line': 2878, 'offset_start': 112792, 'offset_end': 112977, 'content': 'function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeTransferFrom', 'start_line': 2884, 'end_line': 2886, 'offset_start': 113217, 'offset_end': 113430, 'content': 'function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeApprove', 'start_line': 2895, 'end_line': 2904, 'offset_start': 113691, 'offset_end': 114274, 'content': 'function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeIncreaseAllowance', 'start_line': 2910, 'end_line': 2913, 'offset_start': 114466, 'offset_end': 114756, 'content': 'function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeDecreaseAllowance', 'start_line': 2919, 'end_line': 2925, 'offset_start': 114948, 'offset_end': 115365, 'content': 'function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.forceApprove', 'start_line': 2932, 'end_line': 2939, 'offset_start': 115685, 'offset_end': 116105, 'content': 'function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safePermit', 'start_line': 2945, 'end_line': 2959, 'offset_start': 116258, 'offset_end': 116740, 'content': 'function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable._callOptionalReturn', 'start_line': 2967, 'end_line': 2974, 'offset_start': 117124, 'offset_end': 117776, 'content': 'function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable._callOptionalReturnBool', 'start_line': 2984, 'end_line': 2992, 'offset_start': 118278, 'offset_end': 118893, 'content': "function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }", 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'RevertReasonParser.parse', 'start_line': 3010, 'end_line': 3061, 'offset_start': 119571, 'offset_end': 121733, 'content': 'function parse(bytes memory data, string memory prefix)\n        internal\n        pure\n        returns (string memory)\n    {\n        if (data.length >= 4) {\n            bytes4 selector;\n            assembly {\n                // solhint-disable-line no-inline-assembly\n                selector := mload(add(data, 0x20))\n            }\n\n            // 68 = 4-byte selector + 32 bytes offset + 32 bytes length\n            if (selector == _ERROR_SELECTOR && data.length >= 68) {\n                uint256 offset;\n                bytes memory reason;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    offset := mload(add(data, 36))\n                    reason := add(data, add(36, offset))\n                }\n                /*\n                    revert reason is padded up to 32 bytes with ABI encoder: Error(string)\n                    also sometimes there is extra 32 bytes of zeros padded in the end:\n                    https://github.com/ethereum/solidity/issues/10170\n                    because of that we can\'t check for equality and instead check\n                    that offset + string length + extra 36 bytes is less than overall data length\n                */\n                require(\n                    data.length >= 36 + offset + reason.length,\n                    "Invalid revert reason"\n                );\n                return string(abi.encodePacked(prefix, "Error(", reason, ")"));\n            }\n            // 36 = 4-byte selector + 32 bytes integer\n            else if (selector == _PANIC_SELECTOR && data.length == 36) {\n                uint256 code;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    code := mload(add(data, 36))\n                }\n                return\n                    string(\n                        abi.encodePacked(prefix, "Panic(", _toHex(code), ")")\n                    );\n            }\n        }\n\n        return string(abi.encodePacked(prefix, "Unknown(", _toHex(data), ")"));\n    }', 'contract_name': 'RevertReasonParser', 'contract_code': '{\n    bytes4 private constant _PANIC_SELECTOR =\n        bytes4(keccak256("Panic(uint256)"));\n    bytes4 private constant _ERROR_SELECTOR =\n        bytes4(keccak256("Error(string)"));\n\n    function parse(bytes memory data, string memory prefix)\n        internal\n        pure\n        returns (string memory)\n    {\n        if (data.length >= 4) {\n            bytes4 selector;\n            assembly {\n                // solhint-disable-line no-inline-assembly\n                selector := mload(add(data, 0x20))\n            }\n\n            // 68 = 4-byte selector + 32 bytes offset + 32 bytes length\n            if (selector == _ERROR_SELECTOR && data.length >= 68) {\n                uint256 offset;\n                bytes memory reason;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    offset := mload(add(data, 36))\n                    reason := add(data, add(36, offset))\n                }\n                /*\n                    revert reason is padded up to 32 bytes with ABI encoder: Error(string)\n                    also sometimes there is extra 32 bytes of zeros padded in the end:\n                    https://github.com/ethereum/solidity/issues/10170\n                    because of that we can\'t check for equality and instead check\n                    that offset + string length + extra 36 bytes is less than overall data length\n                */\n                require(\n                    data.length >= 36 + offset + reason.length,\n                    "Invalid revert reason"\n                );\n                return string(abi.encodePacked(prefix, "Error(", reason, ")"));\n            }\n            // 36 = 4-byte selector + 32 bytes integer\n            else if (selector == _PANIC_SELECTOR && data.length == 36) {\n                uint256 code;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    code := mload(add(data, 36))\n                }\n                return\n                    string(\n                        abi.encodePacked(prefix, "Panic(", _toHex(code), ")")\n                    );\n            }\n        }\n\n        return string(abi.encodePacked(prefix, "Unknown(", _toHex(data), ")"));\n    }\n\n    function _toHex(uint256 value) private pure returns (string memory) {\n        return _toHex(abi.encodePacked(value));\n    }\n\n    function _toHex(bytes memory data) private pure returns (string memory) {\n        bytes16 alphabet = 0x30313233343536373839616263646566;\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = "0";\n        str[1] = "x";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\n        }\n        return string(str);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'RevertReasonParser._toHex', 'start_line': 3063, 'end_line': 3065, 'offset_start': 121740, 'offset_end': 121862, 'content': 'function _toHex(uint256 value) private pure returns (string memory) {\n        return _toHex(abi.encodePacked(value));\n    }', 'contract_name': 'RevertReasonParser', 'contract_code': '{\n    bytes4 private constant _PANIC_SELECTOR =\n        bytes4(keccak256("Panic(uint256)"));\n    bytes4 private constant _ERROR_SELECTOR =\n        bytes4(keccak256("Error(string)"));\n\n    function parse(bytes memory data, string memory prefix)\n        internal\n        pure\n        returns (string memory)\n    {\n        if (data.length >= 4) {\n            bytes4 selector;\n            assembly {\n                // solhint-disable-line no-inline-assembly\n                selector := mload(add(data, 0x20))\n            }\n\n            // 68 = 4-byte selector + 32 bytes offset + 32 bytes length\n            if (selector == _ERROR_SELECTOR && data.length >= 68) {\n                uint256 offset;\n                bytes memory reason;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    offset := mload(add(data, 36))\n                    reason := add(data, add(36, offset))\n                }\n                /*\n                    revert reason is padded up to 32 bytes with ABI encoder: Error(string)\n                    also sometimes there is extra 32 bytes of zeros padded in the end:\n                    https://github.com/ethereum/solidity/issues/10170\n                    because of that we can\'t check for equality and instead check\n                    that offset + string length + extra 36 bytes is less than overall data length\n                */\n                require(\n                    data.length >= 36 + offset + reason.length,\n                    "Invalid revert reason"\n                );\n                return string(abi.encodePacked(prefix, "Error(", reason, ")"));\n            }\n            // 36 = 4-byte selector + 32 bytes integer\n            else if (selector == _PANIC_SELECTOR && data.length == 36) {\n                uint256 code;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    code := mload(add(data, 36))\n                }\n                return\n                    string(\n                        abi.encodePacked(prefix, "Panic(", _toHex(code), ")")\n                    );\n            }\n        }\n\n        return string(abi.encodePacked(prefix, "Unknown(", _toHex(data), ")"));\n    }\n\n    function _toHex(uint256 value) private pure returns (string memory) {\n        return _toHex(abi.encodePacked(value));\n    }\n\n    function _toHex(bytes memory data) private pure returns (string memory) {\n        bytes16 alphabet = 0x30313233343536373839616263646566;\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = "0";\n        str[1] = "x";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\n        }\n        return string(str);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'RevertReasonParser._toHex', 'start_line': 3067, 'end_line': 3077, 'offset_start': 121869, 'offset_end': 122325, 'content': 'function _toHex(bytes memory data) private pure returns (string memory) {\n        bytes16 alphabet = 0x30313233343536373839616263646566;\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = "0";\n        str[1] = "x";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\n        }\n        return string(str);\n    }', 'contract_name': 'RevertReasonParser', 'contract_code': '{\n    bytes4 private constant _PANIC_SELECTOR =\n        bytes4(keccak256("Panic(uint256)"));\n    bytes4 private constant _ERROR_SELECTOR =\n        bytes4(keccak256("Error(string)"));\n\n    function parse(bytes memory data, string memory prefix)\n        internal\n        pure\n        returns (string memory)\n    {\n        if (data.length >= 4) {\n            bytes4 selector;\n            assembly {\n                // solhint-disable-line no-inline-assembly\n                selector := mload(add(data, 0x20))\n            }\n\n            // 68 = 4-byte selector + 32 bytes offset + 32 bytes length\n            if (selector == _ERROR_SELECTOR && data.length >= 68) {\n                uint256 offset;\n                bytes memory reason;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    offset := mload(add(data, 36))\n                    reason := add(data, add(36, offset))\n                }\n                /*\n                    revert reason is padded up to 32 bytes with ABI encoder: Error(string)\n                    also sometimes there is extra 32 bytes of zeros padded in the end:\n                    https://github.com/ethereum/solidity/issues/10170\n                    because of that we can\'t check for equality and instead check\n                    that offset + string length + extra 36 bytes is less than overall data length\n                */\n                require(\n                    data.length >= 36 + offset + reason.length,\n                    "Invalid revert reason"\n                );\n                return string(abi.encodePacked(prefix, "Error(", reason, ")"));\n            }\n            // 36 = 4-byte selector + 32 bytes integer\n            else if (selector == _PANIC_SELECTOR && data.length == 36) {\n                uint256 code;\n                // solhint-disable no-inline-assembly\n                assembly {\n                    // 36 = 32 bytes data length + 4-byte selector\n                    code := mload(add(data, 36))\n                }\n                return\n                    string(\n                        abi.encodePacked(prefix, "Panic(", _toHex(code), ")")\n                    );\n            }\n        }\n\n        return string(abi.encodePacked(prefix, "Unknown(", _toHex(data), ")"));\n    }\n\n    function _toHex(uint256 value) private pure returns (string memory) {\n        return _toHex(abi.encodePacked(value));\n    }\n\n    function _toHex(bytes memory data) private pure returns (string memory) {\n        bytes16 alphabet = 0x30313233343536373839616263646566;\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = "0";\n        str[1] = "x";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\n        }\n        return string(str);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.permit', 'start_line': 3115, 'end_line': 3123, 'offset_start': 123796, 'offset_end': 123978, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.nonces', 'start_line': 3132, 'end_line': 3132, 'offset_start': 124284, 'offset_end': 124346, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.DOMAIN_SEPARATOR', 'start_line': 3138, 'end_line': 3138, 'offset_start': 124539, 'offset_end': 124598, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f/0xfc99f58a8974a4bc36e60e2d490bb8d72899ee9f.sol'}
