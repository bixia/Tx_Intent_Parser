{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.getERC20Gateway', 'start_line': 35, 'end_line': 35, 'offset_start': 1529, 'offset_end': 1601, 'content': 'function getERC20Gateway(address _token) external view returns (address);', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.requestERC20', 'start_line': 45, 'end_line': 49, 'offset_start': 1953, 'offset_end': 2078, 'content': 'function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.setETHGateway', 'start_line': 58, 'end_line': 58, 'offset_start': 2355, 'offset_end': 2407, 'content': 'function setETHGateway(address _ethGateway) external;', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.setDefaultERC20Gateway', 'start_line': 63, 'end_line': 63, 'offset_start': 2611, 'offset_end': 2681, 'content': 'function setDefaultERC20Gateway(address _defaultERC20Gateway) external;', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1GatewayRouter.setERC20Gateway', 'start_line': 69, 'end_line': 69, 'offset_start': 2966, 'offset_end': 3053, 'content': 'function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external;', 'contract_name': 'IL1GatewayRouter', 'contract_code': '{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param oldETHGateway The address of the old ETH Gateway.\n    /// @param newEthGateway The address of the new ETH Gateway.\n    event SetETHGateway(address indexed oldETHGateway, address indexed newEthGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param oldDefaultERC20Gateway The address of the old default ERC20 Gateway.\n    /// @param newDefaultERC20Gateway The address of the new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed oldDefaultERC20Gateway, address indexed newDefaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param oldGateway The corresponding address of the old gateway.\n    /// @param newGateway The corresponding address of the new gateway.\n    event SetERC20Gateway(address indexed token, address indexed oldGateway, address indexed newGateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.getL2ERC20Address', 'start_line': 125, 'end_line': 125, 'offset_start': 5003, 'offset_end': 5079, 'content': 'function getL2ERC20Address(address _l1Token) external view returns (address);', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.depositERC20', 'start_line': 136, 'end_line': 140, 'offset_start': 5508, 'offset_end': 5628, 'content': 'function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.depositERC20', 'start_line': 148, 'end_line': 153, 'offset_start': 6014, 'offset_end': 6155, 'content': 'function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.depositERC20AndCall', 'start_line': 162, 'end_line': 168, 'offset_start': 6620, 'offset_end': 6796, 'content': 'function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Gateway.finalizeWithdrawERC20', 'start_line': 180, 'end_line': 187, 'offset_start': 7524, 'offset_end': 7728, 'content': 'function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;', 'contract_name': 'IL1ERC20Gateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 334, 'end_line': 340, 'offset_start': 13672, 'offset_end': 13951, 'content': 'function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 345, 'end_line': 347, 'offset_start': 14062, 'offset_end': 14161, 'content': 'function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 352, 'end_line': 354, 'offset_start': 14278, 'offset_end': 14370, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ETHGateway.depositETH', 'start_line': 392, 'end_line': 392, 'offset_start': 15861, 'offset_end': 15931, 'content': 'function depositETH(uint256 amount, uint256 gasLimit) external payable;', 'contract_name': 'IL1ETHGateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ETH is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when someone deposit ETH from L1 to L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when some ETH is refunded.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of ETH refunded to receiver.\n    event RefundETH(address indexed recipient, uint256 amount);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit ETH to caller's account in L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2 and call the target contract.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev This function should only be called by L1ScrollMessenger.\n    ///      This function should also only be called by L1ETHGateway in L2.\n    /// @param from The address of account who withdraw ETH in L2.\n    /// @param to The address of recipient in L1 to receive ETH.\n    /// @param amount The amount of ETH to withdraw.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ETHGateway.depositETH', 'start_line': 398, 'end_line': 402, 'offset_start': 16192, 'offset_end': 16304, 'content': 'function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;', 'contract_name': 'IL1ETHGateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ETH is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when someone deposit ETH from L1 to L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when some ETH is refunded.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of ETH refunded to receiver.\n    event RefundETH(address indexed recipient, uint256 amount);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit ETH to caller's account in L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2 and call the target contract.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev This function should only be called by L1ScrollMessenger.\n    ///      This function should also only be called by L1ETHGateway in L2.\n    /// @param from The address of account who withdraw ETH in L2.\n    /// @param to The address of recipient in L1 to receive ETH.\n    /// @param amount The amount of ETH to withdraw.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ETHGateway.depositETHAndCall', 'start_line': 409, 'end_line': 414, 'offset_start': 16663, 'offset_end': 16811, 'content': 'function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;', 'contract_name': 'IL1ETHGateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ETH is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when someone deposit ETH from L1 to L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when some ETH is refunded.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of ETH refunded to receiver.\n    event RefundETH(address indexed recipient, uint256 amount);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit ETH to caller's account in L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2 and call the target contract.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev This function should only be called by L1ScrollMessenger.\n    ///      This function should also only be called by L1ETHGateway in L2.\n    /// @param from The address of account who withdraw ETH in L2.\n    /// @param to The address of recipient in L1 to receive ETH.\n    /// @param amount The amount of ETH to withdraw.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ETHGateway.finalizeWithdrawETH', 'start_line': 423, 'end_line': 428, 'offset_start': 17316, 'offset_end': 17462, 'content': 'function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;', 'contract_name': 'IL1ETHGateway', 'contract_code': "{\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ETH is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when someone deposit ETH from L1 to L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when some ETH is refunded.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of ETH refunded to receiver.\n    event RefundETH(address indexed recipient, uint256 amount);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit ETH to caller's account in L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2 and call the target contract.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev This function should only be called by L1ScrollMessenger.\n    ///      This function should also only be called by L1ETHGateway in L2.\n    /// @param from The address of account who withdraw ETH in L2.\n    /// @param to The address of recipient in L1 to receive ETH.\n    /// @param amount The amount of ETH to withdraw.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 459, 'end_line': 461, 'offset_start': 18470, 'offset_end': 18564, 'content': 'function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 463, 'end_line': 465, 'offset_start': 18571, 'offset_end': 18681, 'content': 'function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 478, 'end_line': 480, 'offset_start': 18908, 'offset_end': 18992, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 485, 'end_line': 487, 'offset_start': 19066, 'offset_end': 19195, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 496, 'end_line': 498, 'offset_start': 19531, 'offset_end': 19631, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 504, 'end_line': 507, 'offset_start': 19781, 'offset_end': 19978, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 513, 'end_line': 517, 'offset_start': 20133, 'offset_end': 20319, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeTransfer', 'start_line': 552, 'end_line': 554, 'offset_start': 21611, 'offset_end': 21796, 'content': 'function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeTransferFrom', 'start_line': 560, 'end_line': 562, 'offset_start': 22036, 'offset_end': 22249, 'content': 'function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeApprove', 'start_line': 571, 'end_line': 580, 'offset_start': 22510, 'offset_end': 23093, 'content': 'function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeIncreaseAllowance', 'start_line': 586, 'end_line': 589, 'offset_start': 23285, 'offset_end': 23575, 'content': 'function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeDecreaseAllowance', 'start_line': 595, 'end_line': 601, 'offset_start': 23767, 'offset_end': 24184, 'content': 'function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.forceApprove', 'start_line': 608, 'end_line': 615, 'offset_start': 24504, 'offset_end': 24924, 'content': 'function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safePermit', 'start_line': 621, 'end_line': 635, 'offset_start': 25077, 'offset_end': 25559, 'content': 'function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable._callOptionalReturn', 'start_line': 643, 'end_line': 650, 'offset_start': 25943, 'offset_end': 26595, 'content': 'function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable._callOptionalReturnBool', 'start_line': 660, 'end_line': 668, 'offset_start': 27097, 'offset_end': 27712, 'content': "function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }", 'contract_name': 'SafeERC20Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 688, 'end_line': 689, 'offset_start': 28428, 'offset_end': 28486, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 691, 'end_line': 692, 'offset_start': 28493, 'offset_end': 28561, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 693, 'end_line': 695, 'offset_start': 28567, 'offset_end': 28662, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 697, 'end_line': 699, 'offset_start': 28669, 'offset_end': 28767, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.permit', 'start_line': 744, 'end_line': 752, 'offset_start': 30529, 'offset_end': 30711, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.nonces', 'start_line': 761, 'end_line': 761, 'offset_start': 31017, 'offset_end': 31079, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.DOMAIN_SEPARATOR', 'start_line': 767, 'end_line': 767, 'offset_start': 31272, 'offset_end': 31331, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.isContract', 'start_line': 809, 'end_line': 815, 'offset_start': 32759, 'offset_end': 33078, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 833, 'end_line': 838, 'offset_start': 33994, 'offset_end': 34305, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 858, 'end_line': 860, 'offset_start': 35048, 'offset_end': 35232, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 868, 'end_line': 874, 'offset_start': 35455, 'offset_end': 35677, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 887, 'end_line': 889, 'offset_start': 36040, 'offset_end': 36263, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 897, 'end_line': 906, 'offset_start': 36512, 'offset_end': 36957, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 914, 'end_line': 916, 'offset_start': 37135, 'offset_end': 37331, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 924, 'end_line': 931, 'offset_start': 37516, 'offset_end': 37841, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 939, 'end_line': 941, 'offset_start': 38021, 'offset_end': 38218, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 949, 'end_line': 956, 'offset_start': 38405, 'offset_end': 38729, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 964, 'end_line': 980, 'offset_start': 39018, 'offset_end': 39645, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 988, 'end_line': 998, 'offset_start': 39867, 'offset_end': 40161, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 1000, 'end_line': 1012, 'offset_start': 40168, 'offset_end': 40707, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.tor', 'start_line': 1070, 'end_line': 1072, 'offset_start': 42698, 'offset_end': 42750, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.initialize', 'start_line': 1077, 'end_line': 1091, 'offset_start': 42964, 'offset_end': 43542, 'content': 'function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.getL2ERC20Address', 'start_line': 1098, 'end_line': 1105, 'offset_start': 43680, 'offset_end': 43982, 'content': 'function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.getERC20Gateway', 'start_line': 1108, 'end_line': 1114, 'offset_start': 44026, 'offset_end': 44269, 'content': 'function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.requestERC20', 'start_line': 1122, 'end_line': 1132, 'offset_start': 44529, 'offset_end': 44969, 'content': 'function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.depositERC20', 'start_line': 1139, 'end_line': 1145, 'offset_start': 45179, 'offset_end': 45400, 'content': 'function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.depositERC20', 'start_line': 1148, 'end_line': 1155, 'offset_start': 45443, 'offset_end': 45676, 'content': 'function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.depositERC20AndCall', 'start_line': 1158, 'end_line': 1178, 'offset_start': 45719, 'offset_end': 46416, 'content': 'function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.finalizeWithdrawERC20', 'start_line': 1181, 'end_line': 1190, 'offset_start': 46459, 'offset_end': 46687, 'content': 'function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.depositETH', 'start_line': 1197, 'end_line': 1199, 'offset_start': 46889, 'offset_end': 47052, 'content': 'function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.depositETH', 'start_line': 1202, 'end_line': 1208, 'offset_start': 47093, 'offset_end': 47290, 'content': 'function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.depositETHAndCall', 'start_line': 1211, 'end_line': 1224, 'offset_start': 47331, 'offset_end': 47834, 'content': 'function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.finalizeWithdrawETH', 'start_line': 1227, 'end_line': 1234, 'offset_start': 47875, 'offset_end': 48067, 'content': 'function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.setETHGateway', 'start_line': 1241, 'end_line': 1246, 'offset_start': 48203, 'offset_end': 48418, 'content': 'function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.setDefaultERC20Gateway', 'start_line': 1249, 'end_line': 1254, 'offset_start': 48462, 'offset_end': 48758, 'content': 'function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1GatewayRouter.setERC20Gateway', 'start_line': 1257, 'end_line': 1266, 'offset_start': 48802, 'offset_end': 49231, 'content': 'function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }', 'contract_name': 'L1GatewayRouter', 'contract_code': '{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), "Only not in context");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, "Only in deposit context");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), "no gateway available");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = ethGateway;\n        require(_gateway != address(0), "eth gateway available");\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ETHGateway(_gateway).depositETHAndCall{value: msg.value}(_to, _amount, _routerData, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert("should never be called");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, "length mismatch");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.totalSupply', 'start_line': 1295, 'end_line': 1295, 'offset_start': 50021, 'offset_end': 50075, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.balanceOf', 'start_line': 1300, 'end_line': 1300, 'offset_start': 50159, 'offset_end': 50226, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transfer', 'start_line': 1309, 'end_line': 1309, 'offset_start': 50440, 'offset_end': 50509, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.allowance', 'start_line': 1318, 'end_line': 1318, 'offset_start': 50785, 'offset_end': 50867, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.approve', 'start_line': 1334, 'end_line': 1334, 'offset_start': 51521, 'offset_end': 51594, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transferFrom', 'start_line': 1345, 'end_line': 1345, 'offset_start': 51893, 'offset_end': 51980, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6/0xf8b1378579659d8f7ee5f3c929c2f3e332e41fd6.sol'}
