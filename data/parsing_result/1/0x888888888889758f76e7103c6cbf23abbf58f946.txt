{'type': 'FunctionDefinition', 'name': 'IPMarket.mint', 'start_line': 38, 'end_line': 42, 'offset_start': 1068, 'offset_end': 1247, 'content': 'function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.burn', 'start_line': 44, 'end_line': 48, 'offset_start': 1254, 'offset_end': 1412, 'content': 'function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.swapExactPtForSy', 'start_line': 50, 'end_line': 54, 'offset_start': 1419, 'offset_end': 1586, 'content': 'function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.swapSyForExactPt', 'start_line': 56, 'end_line': 60, 'offset_start': 1593, 'offset_end': 1760, 'content': 'function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.redeemRewards', 'start_line': 62, 'end_line': 62, 'offset_start': 1767, 'offset_end': 1839, 'content': 'function redeemRewards(address user) external returns (uint256[] memory);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.readState', 'start_line': 64, 'end_line': 64, 'offset_start': 1846, 'offset_end': 1930, 'content': 'function readState(address router) external view returns (MarketState memory market);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.observe', 'start_line': 66, 'end_line': 66, 'offset_start': 1937, 'offset_end': 2047, 'content': 'function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.increaseObservationsCardinalityNext', 'start_line': 68, 'end_line': 68, 'offset_start': 2054, 'offset_end': 2131, 'content': 'function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.readTokens', 'start_line': 70, 'end_line': 70, 'offset_start': 2138, 'offset_end': 2246, 'content': 'function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.getRewardTokens', 'start_line': 72, 'end_line': 72, 'offset_start': 2253, 'offset_end': 2320, 'content': 'function getRewardTokens() external view returns (address[] memory);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.isExpired', 'start_line': 74, 'end_line': 74, 'offset_start': 2327, 'offset_end': 2376, 'content': 'function isExpired() external view returns (bool);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.expiry', 'start_line': 76, 'end_line': 76, 'offset_start': 2383, 'offset_end': 2432, 'content': 'function expiry() external view returns (uint256);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket.observations', 'start_line': 78, 'end_line': 80, 'offset_start': 2439, 'offset_end': 2586, 'content': 'function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPMarket._storage', 'start_line': 82, 'end_line': 92, 'offset_start': 2593, 'offset_end': 2890, 'content': 'function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );', 'contract_name': 'IPMarket', 'contract_code': '{\n    event Mint(address indexed receiver, uint256 netLpMinted, uint256 netSyUsed, uint256 netPtUsed);\n\n    event Burn(\n        address indexed receiverSy,\n        address indexed receiverPt,\n        uint256 netLpBurned,\n        uint256 netSyOut,\n        uint256 netPtOut\n    );\n\n    event Swap(\n        address indexed caller,\n        address indexed receiver,\n        int256 netPtOut,\n        int256 netSyOut,\n        uint256 netSyFee,\n        uint256 netSyToReserve\n    );\n\n    event UpdateImpliedRate(uint256 indexed timestamp, uint256 lnLastImpliedRate);\n\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    function mint(\n        address receiver,\n        uint256 netSyDesired,\n        uint256 netPtDesired\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function burn(\n        address receiverSy,\n        address receiverPt,\n        uint256 netLpToBurn\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function swapExactPtForSy(\n        address receiver,\n        uint256 exactPtIn,\n        bytes calldata data\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        uint256 exactPtOut,\n        bytes calldata data\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function redeemRewards(address user) external returns (uint256[] memory);\n\n    function readState(address router) external view returns (MarketState memory market);\n\n    function observe(uint32[] memory secondsAgos) external view returns (uint216[] memory lnImpliedRateCumulative);\n\n    function increaseObservationsCardinalityNext(uint16 cardinalityNext) external;\n\n    function readTokens() external view returns (IStandardizedYield _SY, IPPrincipalToken _PT, IPYieldToken _YT);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function isExpired() external view returns (bool);\n\n    function expiry() external view returns (uint256);\n\n    function observations(\n        uint256 index\n    ) external view returns (uint32 blockTimestamp, uint216 lnImpliedRateCumulative, bool initialized);\n\n    function _storage()\n        external\n        view\n        returns (\n            int128 totalPt,\n            int128 totalSy,\n            uint96 lastLnImpliedRate,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouterCallback.limitRouterCallback', 'start_line': 157, 'end_line': 162, 'offset_start': 4227, 'offset_end': 4406, 'content': 'function limitRouterCallback(\n        uint256 actualMaking,\n        uint256 actualTaking,\n        uint256 totalFee,\n        bytes memory data\n    ) external returns (bytes memory);', 'contract_name': 'IPLimitRouterCallback', 'contract_code': '{\n    function limitRouterCallback(\n        uint256 actualMaking,\n        uint256 actualTaking,\n        uint256 totalFee,\n        bytes memory data\n    ) external returns (bytes memory);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouter.fill', 'start_line': 187, 'end_line': 193, 'offset_start': 5013, 'offset_end': 5300, 'content': 'function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);', 'contract_name': 'IPLimitRouter', 'contract_code': '{\n    struct OrderStatus {\n        uint128 filledAmount;\n        uint128 remaining;\n    }\n\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\n\n    event OrderFilledV2(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume,\n        address maker,\n        address taker\n    );\n\n    // @dev actualMaking, actualTaking are in the SY form\n    function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\n\n    function feeRecipient() external view returns (address);\n\n    function hashOrder(Order memory order) external view returns (bytes32);\n\n    function cancelSingle(Order calldata order) external;\n\n    function cancelBatch(Order[] calldata orders) external;\n\n    function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\n\n    function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function simulate(address target, bytes calldata data) external payable;\n\n    /* --- Deprecated events --- */\n\n    // deprecate on 7/1/2024, prior to official launch\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume\n    );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouter.feeRecipient', 'start_line': 195, 'end_line': 195, 'offset_start': 5307, 'offset_end': 5362, 'content': 'function feeRecipient() external view returns (address);', 'contract_name': 'IPLimitRouter', 'contract_code': '{\n    struct OrderStatus {\n        uint128 filledAmount;\n        uint128 remaining;\n    }\n\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\n\n    event OrderFilledV2(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume,\n        address maker,\n        address taker\n    );\n\n    // @dev actualMaking, actualTaking are in the SY form\n    function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\n\n    function feeRecipient() external view returns (address);\n\n    function hashOrder(Order memory order) external view returns (bytes32);\n\n    function cancelSingle(Order calldata order) external;\n\n    function cancelBatch(Order[] calldata orders) external;\n\n    function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\n\n    function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function simulate(address target, bytes calldata data) external payable;\n\n    /* --- Deprecated events --- */\n\n    // deprecate on 7/1/2024, prior to official launch\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouter.hashOrder', 'start_line': 197, 'end_line': 197, 'offset_start': 5369, 'offset_end': 5439, 'content': 'function hashOrder(Order memory order) external view returns (bytes32);', 'contract_name': 'IPLimitRouter', 'contract_code': '{\n    struct OrderStatus {\n        uint128 filledAmount;\n        uint128 remaining;\n    }\n\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\n\n    event OrderFilledV2(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume,\n        address maker,\n        address taker\n    );\n\n    // @dev actualMaking, actualTaking are in the SY form\n    function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\n\n    function feeRecipient() external view returns (address);\n\n    function hashOrder(Order memory order) external view returns (bytes32);\n\n    function cancelSingle(Order calldata order) external;\n\n    function cancelBatch(Order[] calldata orders) external;\n\n    function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\n\n    function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function simulate(address target, bytes calldata data) external payable;\n\n    /* --- Deprecated events --- */\n\n    // deprecate on 7/1/2024, prior to official launch\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouter.cancelSingle', 'start_line': 199, 'end_line': 199, 'offset_start': 5446, 'offset_end': 5498, 'content': 'function cancelSingle(Order calldata order) external;', 'contract_name': 'IPLimitRouter', 'contract_code': '{\n    struct OrderStatus {\n        uint128 filledAmount;\n        uint128 remaining;\n    }\n\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\n\n    event OrderFilledV2(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume,\n        address maker,\n        address taker\n    );\n\n    // @dev actualMaking, actualTaking are in the SY form\n    function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\n\n    function feeRecipient() external view returns (address);\n\n    function hashOrder(Order memory order) external view returns (bytes32);\n\n    function cancelSingle(Order calldata order) external;\n\n    function cancelBatch(Order[] calldata orders) external;\n\n    function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\n\n    function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function simulate(address target, bytes calldata data) external payable;\n\n    /* --- Deprecated events --- */\n\n    // deprecate on 7/1/2024, prior to official launch\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume\n    );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouter.cancelBatch', 'start_line': 201, 'end_line': 201, 'offset_start': 5505, 'offset_end': 5559, 'content': 'function cancelBatch(Order[] calldata orders) external;', 'contract_name': 'IPLimitRouter', 'contract_code': '{\n    struct OrderStatus {\n        uint128 filledAmount;\n        uint128 remaining;\n    }\n\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\n\n    event OrderFilledV2(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume,\n        address maker,\n        address taker\n    );\n\n    // @dev actualMaking, actualTaking are in the SY form\n    function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\n\n    function feeRecipient() external view returns (address);\n\n    function hashOrder(Order memory order) external view returns (bytes32);\n\n    function cancelSingle(Order calldata order) external;\n\n    function cancelBatch(Order[] calldata orders) external;\n\n    function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\n\n    function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function simulate(address target, bytes calldata data) external payable;\n\n    /* --- Deprecated events --- */\n\n    // deprecate on 7/1/2024, prior to official launch\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume\n    );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouter.orderStatusesRaw', 'start_line': 203, 'end_line': 205, 'offset_start': 5566, 'offset_end': 5722, 'content': 'function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);', 'contract_name': 'IPLimitRouter', 'contract_code': '{\n    struct OrderStatus {\n        uint128 filledAmount;\n        uint128 remaining;\n    }\n\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\n\n    event OrderFilledV2(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume,\n        address maker,\n        address taker\n    );\n\n    // @dev actualMaking, actualTaking are in the SY form\n    function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\n\n    function feeRecipient() external view returns (address);\n\n    function hashOrder(Order memory order) external view returns (bytes32);\n\n    function cancelSingle(Order calldata order) external;\n\n    function cancelBatch(Order[] calldata orders) external;\n\n    function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\n\n    function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function simulate(address target, bytes calldata data) external payable;\n\n    /* --- Deprecated events --- */\n\n    // deprecate on 7/1/2024, prior to official launch\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouter.orderStatuses', 'start_line': 207, 'end_line': 209, 'offset_start': 5729, 'offset_end': 5879, 'content': 'function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);', 'contract_name': 'IPLimitRouter', 'contract_code': '{\n    struct OrderStatus {\n        uint128 filledAmount;\n        uint128 remaining;\n    }\n\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\n\n    event OrderFilledV2(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume,\n        address maker,\n        address taker\n    );\n\n    // @dev actualMaking, actualTaking are in the SY form\n    function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\n\n    function feeRecipient() external view returns (address);\n\n    function hashOrder(Order memory order) external view returns (bytes32);\n\n    function cancelSingle(Order calldata order) external;\n\n    function cancelBatch(Order[] calldata orders) external;\n\n    function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\n\n    function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function simulate(address target, bytes calldata data) external payable;\n\n    /* --- Deprecated events --- */\n\n    // deprecate on 7/1/2024, prior to official launch\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouter.DOMAIN_SEPARATOR', 'start_line': 211, 'end_line': 211, 'offset_start': 5886, 'offset_end': 5945, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IPLimitRouter', 'contract_code': '{\n    struct OrderStatus {\n        uint128 filledAmount;\n        uint128 remaining;\n    }\n\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\n\n    event OrderFilledV2(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume,\n        address maker,\n        address taker\n    );\n\n    // @dev actualMaking, actualTaking are in the SY form\n    function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\n\n    function feeRecipient() external view returns (address);\n\n    function hashOrder(Order memory order) external view returns (bytes32);\n\n    function cancelSingle(Order calldata order) external;\n\n    function cancelBatch(Order[] calldata orders) external;\n\n    function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\n\n    function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function simulate(address target, bytes calldata data) external payable;\n\n    /* --- Deprecated events --- */\n\n    // deprecate on 7/1/2024, prior to official launch\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPLimitRouter.simulate', 'start_line': 213, 'end_line': 213, 'offset_start': 5952, 'offset_end': 6023, 'content': 'function simulate(address target, bytes calldata data) external payable;', 'contract_name': 'IPLimitRouter', 'contract_code': '{\n    struct OrderStatus {\n        uint128 filledAmount;\n        uint128 remaining;\n    }\n\n    event OrderCanceled(address indexed maker, bytes32 indexed orderHash);\n\n    event OrderFilledV2(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume,\n        address maker,\n        address taker\n    );\n\n    // @dev actualMaking, actualTaking are in the SY form\n    function fill(\n        FillOrderParams[] memory params,\n        address receiver,\n        uint256 maxTaking,\n        bytes calldata optData,\n        bytes calldata callback\n    ) external returns (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, bytes memory callbackReturn);\n\n    function feeRecipient() external view returns (address);\n\n    function hashOrder(Order memory order) external view returns (bytes32);\n\n    function cancelSingle(Order calldata order) external;\n\n    function cancelBatch(Order[] calldata orders) external;\n\n    function orderStatusesRaw(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainingsRaw, uint256[] memory filledAmounts);\n\n    function orderStatuses(\n        bytes32[] memory orderHashes\n    ) external view returns (uint256[] memory remainings, uint256[] memory filledAmounts);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function simulate(address target, bytes calldata data) external payable;\n\n    /* --- Deprecated events --- */\n\n    // deprecate on 7/1/2024, prior to official launch\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        OrderType indexed orderType,\n        address indexed YT,\n        address token,\n        uint256 netInputFromMaker,\n        uint256 netOutputToMaker,\n        uint256 feeAmount,\n        uint256 notionalVolume\n    );\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.approxSwapPtForExactSy', 'start_line': 274, 'end_line': 302, 'offset_start': 8684, 'offset_end': 9833, 'content': 'function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.approxSwapExactSyForYt', 'start_line': 313, 'end_line': 349, 'offset_start': 10288, 'offset_end': 11790, 'content': 'function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.approxSwapPtToAddLiquidity', 'start_line': 368, 'end_line': 411, 'offset_start': 12291, 'offset_end': 14017, 'content': 'function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.calcNumerators', 'start_line': 413, 'end_line': 437, 'offset_start': 14024, 'offset_end': 14966, 'content': 'function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.approxSwapExactPtForYt', 'start_line': 448, 'end_line': 482, 'offset_start': 15381, 'offset_end': 16776, 'content': 'function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.calcSyOut', 'start_line': 486, 'end_line': 496, 'offset_start': 16869, 'offset_end': 17353, 'content': 'function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.nextGuess', 'start_line': 498, 'end_line': 502, 'offset_start': 17360, 'offset_end': 17685, 'content': 'function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.validateApprox', 'start_line': 506, 'end_line': 508, 'offset_start': 17760, 'offset_end': 17948, 'content': 'function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.calcMaxPtIn', 'start_line': 510, 'end_line': 526, 'offset_start': 17955, 'offset_end': 18532, 'content': 'function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtInLib.calcSlope', 'start_line': 528, 'end_line': 540, 'offset_start': 18539, 'offset_end': 19146, 'content': 'function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }', 'contract_name': 'MarketApproxPtInLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Try swapping & get netSyOut\n     *     - Stop when netSyOut greater & approx minSyOut\n     *     - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap in\n     *     - Flashswap the corresponding amount of SY out\n     *     - Pair those amount with exactSyIn SY to tokenize into PT & YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n     *     - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, index.syToAsset(exactSyIn));\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netSyToTokenizePt = index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyToPull, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 netSyHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Swap PT to SY\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _netSyHolding,\n        uint256 _blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtSwap*/ uint256, /*netSyFromSwap*/ uint256 /*netSyFee*/) {\n        Args5 memory a = Args5(_market, _index, _totalPtIn, _netSyHolding, _blockTime, approx);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(a.market, comp));\n            approx.guessMax = PMath.min(approx.guessMax, a.totalPtIn);\n            validateApprox(approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, ) = calcNumerators(\n                a.market,\n                a.index,\n                a.totalPtIn,\n                a.netSyHolding,\n                comp,\n                guess\n            );\n\n            if (PMath.isAApproxB(syNumerator, ptNumerator, approx.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                approx.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    function calcNumerators(\n        MarketState memory market,\n        PYIndex index,\n        uint256 totalPtIn,\n        uint256 netSyHolding,\n        MarketPreCompute memory comp,\n        uint256 guess\n    )\n        internal\n        pure\n        returns (uint256 syNumerator, uint256 ptNumerator, uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve)\n    {\n        (netSyOut, netSyFee, netSyToReserve) = calcSyOut(market, comp, index, guess);\n\n        uint256 newTotalPt = uint256(market.totalPt) + guess;\n        uint256 newTotalSy = (uint256(market.totalSy) - netSyOut - netSyToReserve);\n\n        // it is desired that\n        // (netSyOut + netSyHolding) / newTotalSy = netPtRemaining / newTotalPt\n        // which is equivalent to\n        // (netSyOut + netSyHolding) * newTotalPt = netPtRemaining * newTotalSy\n\n        syNumerator = (netSyOut + netSyHolding) * newTotalPt;\n        ptNumerator = (totalPtIn - guess) * newTotalSy;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swap to SY\n     *     - Flashswap the corresponding amount of SY out\n     *     - Tokenize all the SY into PT + YT\n     *     - PT to repay the flashswap, YT transferred to user\n     *     - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n     *     - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtOut*/ uint256, /*totalPtToSwap*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactPtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtIn(market, comp));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(market, comp, index, guess);\n\n            uint256 netAssetOut = index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= exactPtIn) {\n                if (PMath.isASmallerApproxB(netPtToPull, exactPtIn, approx.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    ) internal pure returns (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, -int256(netPtIn));\n        netSyOut = uint256(_netSyOut);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    /// INTENDED TO BE CALLED BY WHEN GUESS.OFFCHAIN == 0 ONLY ///\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n\n    function calcMaxPtIn(MarketState memory market, MarketPreCompute memory comp) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 hi = uint256(comp.totalAsset) - 1;\n\n        while (low != hi) {\n            uint256 mid = (low + hi + 1) / 2;\n            if (calcSlope(comp, market.totalPt, int256(mid)) < 0) hi = mid - 1;\n            else low = mid;\n        }\n\n        low = PMath.min(\n            low,\n            (MarketMathCore.MAX_MARKET_PROPORTION.mulDown(market.totalPt + comp.totalAsset) - market.totalPt).Uint()\n        );\n\n        return low;\n    }\n\n    function calcSlope(MarketPreCompute memory comp, int256 totalPt, int256 ptToMarket) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt;\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, "invalid ptToMarket");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(sumPt * diffAssetPtToMarket);\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = PMath.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtOutLib.approxSwapExactSyForPt', 'start_line': 557, 'end_line': 587, 'offset_start': 19602, 'offset_end': 20734, 'content': 'function approxSwapExactSyForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            if (netSyIn <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n\n        revert("Slippage: APPROX_EXHAUSTED");\n    }', 'contract_name': 'MarketApproxPtOutLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Calculate the amount of SY needed\n     *     - Stop when the netSyIn is smaller approx exactSyIn\n     *     - guess & approx is for netSyIn\n     */\n    function approxSwapExactSyForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            if (netSyIn <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT & pair with YT to redeem SY\n     *     - Use the SY to repay the flashswap debt and the remaining is transferred to user\n     *     - Stop when the netSyOut is greater approx the minSyOut\n     *     - guess & approx is for netSyOut\n     */\n    function approxSwapYtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess + 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalSyIn;\n        uint256 netPtHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Swap that amount of PT out\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _netPtHolding,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (a.approx.guessOffchain == 0) {\n            // no limit on min\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\n            validateApprox(a.approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(a.approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn > a.totalSyIn) {\n                a.approx.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                a.approx.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                a.approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT out\n     *     - Pair all the PT with the YT to redeem SY\n     *     - Use the SY to repay the flashswap debt\n     *     - Stop when the amount of YT required to pair with PT is approx exactYtIn\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapExactYtForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactYtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\n\n            if (netYtToPull <= exactYtIn) {\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\n                    return (guess - netYtToPull, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\n\n        // all safe since totalPt and totalSy is int128\n        netSyIn = uint256(-_netSyIn);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (uint256(maxPtOut) * 999) / 1000;\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtOutLib.approxSwapYtForExactSy', 'start_line': 597, 'end_line': 629, 'offset_start': 21110, 'offset_end': 22415, 'content': 'function approxSwapYtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess + 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }', 'contract_name': 'MarketApproxPtOutLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Calculate the amount of SY needed\n     *     - Stop when the netSyIn is smaller approx exactSyIn\n     *     - guess & approx is for netSyIn\n     */\n    function approxSwapExactSyForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            if (netSyIn <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT & pair with YT to redeem SY\n     *     - Use the SY to repay the flashswap debt and the remaining is transferred to user\n     *     - Stop when the netSyOut is greater approx the minSyOut\n     *     - guess & approx is for netSyOut\n     */\n    function approxSwapYtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess + 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalSyIn;\n        uint256 netPtHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Swap that amount of PT out\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _netPtHolding,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (a.approx.guessOffchain == 0) {\n            // no limit on min\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\n            validateApprox(a.approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(a.approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn > a.totalSyIn) {\n                a.approx.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                a.approx.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                a.approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT out\n     *     - Pair all the PT with the YT to redeem SY\n     *     - Use the SY to repay the flashswap debt\n     *     - Stop when the amount of YT required to pair with PT is approx exactYtIn\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapExactYtForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactYtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\n\n            if (netYtToPull <= exactYtIn) {\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\n                    return (guess - netYtToPull, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\n\n        // all safe since totalPt and totalSy is int128\n        netSyIn = uint256(-_netSyIn);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (uint256(maxPtOut) * 999) / 1000;\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtOutLib.approxSwapSyToAddLiquidity', 'start_line': 648, 'end_line': 705, 'offset_start': 22935, 'offset_end': 25212, 'content': 'function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _netPtHolding,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (a.approx.guessOffchain == 0) {\n            // no limit on min\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\n            validateApprox(a.approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(a.approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn > a.totalSyIn) {\n                a.approx.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                a.approx.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                a.approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }', 'contract_name': 'MarketApproxPtOutLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Calculate the amount of SY needed\n     *     - Stop when the netSyIn is smaller approx exactSyIn\n     *     - guess & approx is for netSyIn\n     */\n    function approxSwapExactSyForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            if (netSyIn <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT & pair with YT to redeem SY\n     *     - Use the SY to repay the flashswap debt and the remaining is transferred to user\n     *     - Stop when the netSyOut is greater approx the minSyOut\n     *     - guess & approx is for netSyOut\n     */\n    function approxSwapYtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess + 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalSyIn;\n        uint256 netPtHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Swap that amount of PT out\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _netPtHolding,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (a.approx.guessOffchain == 0) {\n            // no limit on min\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\n            validateApprox(a.approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(a.approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn > a.totalSyIn) {\n                a.approx.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                a.approx.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                a.approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT out\n     *     - Pair all the PT with the YT to redeem SY\n     *     - Use the SY to repay the flashswap debt\n     *     - Stop when the amount of YT required to pair with PT is approx exactYtIn\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapExactYtForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactYtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\n\n            if (netYtToPull <= exactYtIn) {\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\n                    return (guess - netYtToPull, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\n\n        // all safe since totalPt and totalSy is int128\n        netSyIn = uint256(-_netSyIn);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (uint256(maxPtOut) * 999) / 1000;\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtOutLib.approxSwapExactYtForPt', 'start_line': 716, 'end_line': 747, 'offset_start': 25600, 'offset_end': 26893, 'content': 'function approxSwapExactYtForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactYtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\n\n            if (netYtToPull <= exactYtIn) {\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\n                    return (guess - netYtToPull, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }', 'contract_name': 'MarketApproxPtOutLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Calculate the amount of SY needed\n     *     - Stop when the netSyIn is smaller approx exactSyIn\n     *     - guess & approx is for netSyIn\n     */\n    function approxSwapExactSyForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            if (netSyIn <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT & pair with YT to redeem SY\n     *     - Use the SY to repay the flashswap debt and the remaining is transferred to user\n     *     - Stop when the netSyOut is greater approx the minSyOut\n     *     - guess & approx is for netSyOut\n     */\n    function approxSwapYtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess + 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalSyIn;\n        uint256 netPtHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Swap that amount of PT out\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _netPtHolding,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (a.approx.guessOffchain == 0) {\n            // no limit on min\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\n            validateApprox(a.approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(a.approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn > a.totalSyIn) {\n                a.approx.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                a.approx.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                a.approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT out\n     *     - Pair all the PT with the YT to redeem SY\n     *     - Use the SY to repay the flashswap debt\n     *     - Stop when the amount of YT required to pair with PT is approx exactYtIn\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapExactYtForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactYtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\n\n            if (netYtToPull <= exactYtIn) {\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\n                    return (guess - netYtToPull, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\n\n        // all safe since totalPt and totalSy is int128\n        netSyIn = uint256(-_netSyIn);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (uint256(maxPtOut) * 999) / 1000;\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtOutLib.calcSyIn', 'start_line': 751, 'end_line': 763, 'offset_start': 26986, 'offset_end': 27524, 'content': 'function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\n\n        // all safe since totalPt and totalSy is int128\n        netSyIn = uint256(-_netSyIn);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }', 'contract_name': 'MarketApproxPtOutLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Calculate the amount of SY needed\n     *     - Stop when the netSyIn is smaller approx exactSyIn\n     *     - guess & approx is for netSyIn\n     */\n    function approxSwapExactSyForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            if (netSyIn <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT & pair with YT to redeem SY\n     *     - Use the SY to repay the flashswap debt and the remaining is transferred to user\n     *     - Stop when the netSyOut is greater approx the minSyOut\n     *     - guess & approx is for netSyOut\n     */\n    function approxSwapYtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess + 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalSyIn;\n        uint256 netPtHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Swap that amount of PT out\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _netPtHolding,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (a.approx.guessOffchain == 0) {\n            // no limit on min\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\n            validateApprox(a.approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(a.approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn > a.totalSyIn) {\n                a.approx.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                a.approx.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                a.approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT out\n     *     - Pair all the PT with the YT to redeem SY\n     *     - Use the SY to repay the flashswap debt\n     *     - Stop when the amount of YT required to pair with PT is approx exactYtIn\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapExactYtForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactYtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\n\n            if (netYtToPull <= exactYtIn) {\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\n                    return (guess - netYtToPull, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\n\n        // all safe since totalPt and totalSy is int128\n        netSyIn = uint256(-_netSyIn);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (uint256(maxPtOut) * 999) / 1000;\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtOutLib.calcMaxPtOut', 'start_line': 765, 'end_line': 772, 'offset_start': 27531, 'offset_end': 28047, 'content': 'function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (uint256(maxPtOut) * 999) / 1000;\n    }', 'contract_name': 'MarketApproxPtOutLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Calculate the amount of SY needed\n     *     - Stop when the netSyIn is smaller approx exactSyIn\n     *     - guess & approx is for netSyIn\n     */\n    function approxSwapExactSyForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            if (netSyIn <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT & pair with YT to redeem SY\n     *     - Use the SY to repay the flashswap debt and the remaining is transferred to user\n     *     - Stop when the netSyOut is greater approx the minSyOut\n     *     - guess & approx is for netSyOut\n     */\n    function approxSwapYtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess + 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalSyIn;\n        uint256 netPtHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Swap that amount of PT out\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _netPtHolding,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (a.approx.guessOffchain == 0) {\n            // no limit on min\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\n            validateApprox(a.approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(a.approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn > a.totalSyIn) {\n                a.approx.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                a.approx.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                a.approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT out\n     *     - Pair all the PT with the YT to redeem SY\n     *     - Use the SY to repay the flashswap debt\n     *     - Stop when the amount of YT required to pair with PT is approx exactYtIn\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapExactYtForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactYtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\n\n            if (netYtToPull <= exactYtIn) {\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\n                    return (guess - netYtToPull, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\n\n        // all safe since totalPt and totalSy is int128\n        netSyIn = uint256(-_netSyIn);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (uint256(maxPtOut) * 999) / 1000;\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtOutLib.nextGuess', 'start_line': 774, 'end_line': 778, 'offset_start': 28054, 'offset_end': 28379, 'content': 'function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }', 'contract_name': 'MarketApproxPtOutLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Calculate the amount of SY needed\n     *     - Stop when the netSyIn is smaller approx exactSyIn\n     *     - guess & approx is for netSyIn\n     */\n    function approxSwapExactSyForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            if (netSyIn <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT & pair with YT to redeem SY\n     *     - Use the SY to repay the flashswap debt and the remaining is transferred to user\n     *     - Stop when the netSyOut is greater approx the minSyOut\n     *     - guess & approx is for netSyOut\n     */\n    function approxSwapYtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess + 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalSyIn;\n        uint256 netPtHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Swap that amount of PT out\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _netPtHolding,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (a.approx.guessOffchain == 0) {\n            // no limit on min\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\n            validateApprox(a.approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(a.approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn > a.totalSyIn) {\n                a.approx.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                a.approx.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                a.approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT out\n     *     - Pair all the PT with the YT to redeem SY\n     *     - Use the SY to repay the flashswap debt\n     *     - Stop when the amount of YT required to pair with PT is approx exactYtIn\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapExactYtForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactYtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\n\n            if (netYtToPull <= exactYtIn) {\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\n                    return (guess - netYtToPull, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\n\n        // all safe since totalPt and totalSy is int128\n        netSyIn = uint256(-_netSyIn);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (uint256(maxPtOut) * 999) / 1000;\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketApproxPtOutLib.validateApprox', 'start_line': 780, 'end_line': 782, 'offset_start': 28386, 'offset_end': 28574, 'content': 'function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }', 'contract_name': 'MarketApproxPtOutLib', 'contract_code': '{\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Calculate the amount of SY needed\n     *     - Stop when the netSyIn is smaller approx exactSyIn\n     *     - guess & approx is for netSyIn\n     */\n    function approxSwapExactSyForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactSyIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            if (netSyIn <= exactSyIn) {\n                if (PMath.isASmallerApproxB(netSyIn, exactSyIn, approx.eps)) {\n                    return (guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT & pair with YT to redeem SY\n     *     - Use the SY to repay the flashswap debt and the remaining is transferred to user\n     *     - Stop when the netSyOut is greater approx the minSyOut\n     *     - guess & approx is for netSyOut\n     */\n    function approxSwapYtForExactSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 minSyOut,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netYtIn*/ uint256, /*netSyOut*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            // no limit on min\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netAssetToRepay = index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= minSyOut) {\n                if (PMath.isAGreaterApproxB(netSyOut, minSyOut, approx.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n                approx.guessMax = guess;\n            } else {\n                approx.guessMin = guess + 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalSyIn;\n        uint256 netPtHolding;\n        uint256 blockTime;\n        ApproxParams approx;\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Swap that amount of PT out\n     *     - Pair the remaining PT with the SY to add liquidity\n     *     - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _netPtHolding,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    ) internal pure returns (uint256, /*netPtFromSwap*/ uint256, /*netSySwap*/ uint256 /*netSyFee*/) {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _netPtHolding, _blockTime, _approx);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        if (a.approx.guessOffchain == 0) {\n            // no limit on min\n            a.approx.guessMax = PMath.min(a.approx.guessMax, calcMaxPtOut(comp, a.market.totalPt));\n            validateApprox(a.approx);\n            require(a.market.totalLp != 0, "no existing lp");\n        }\n\n        for (uint256 iter = 0; iter < a.approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(a.approx, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn > a.totalSyIn) {\n                a.approx.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = uint256(a.market.totalPt) - guess;\n                uint256 netTotalSy = uint256(a.market.totalSy) + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // (netPtFromSwap + netPtHolding) / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // (netPtFromSwap + netPtHolding) * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = (guess + a.netPtHolding) * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (PMath.isAApproxB(ptNumerator, syNumerator, a.approx.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                a.approx.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                a.approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    /**\n     * @dev algorithm:\n     *     - Bin search the amount of PT to swapExactOut\n     *     - Flashswap that amount of PT out\n     *     - Pair all the PT with the YT to redeem SY\n     *     - Use the SY to repay the flashswap debt\n     *     - Stop when the amount of YT required to pair with PT is approx exactYtIn\n     *     - guess & approx is for netPtFromSwap\n     */\n    function approxSwapExactYtForPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactYtIn,\n        uint256 blockTime,\n        ApproxParams memory approx\n    ) internal pure returns (uint256, /*netPtOut*/ uint256, /*totalPtSwapped*/ uint256 /*netSyFee*/) {\n        MarketPreCompute memory comp = market.getMarketPreCompute(index, blockTime);\n        if (approx.guessOffchain == 0) {\n            approx.guessMin = PMath.max(approx.guessMin, exactYtIn);\n            approx.guessMax = PMath.min(approx.guessMax, calcMaxPtOut(comp, market.totalPt));\n            validateApprox(approx);\n        }\n\n        for (uint256 iter = 0; iter < approx.maxIteration; ++iter) {\n            uint256 guess = nextGuess(approx, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(market, comp, index, guess);\n\n            uint256 netYtToPull = index.syToAssetUp(netSyOwed);\n\n            if (netYtToPull <= exactYtIn) {\n                if (PMath.isASmallerApproxB(netYtToPull, exactYtIn, approx.eps)) {\n                    return (guess - netYtToPull, guess, netSyFee);\n                }\n                approx.guessMin = guess;\n            } else {\n                approx.guessMax = guess - 1;\n            }\n        }\n        revert("Slippage: APPROX_EXHAUSTED");\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    ) internal pure returns (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(comp, index, int256(netPtOut));\n\n        // all safe since totalPt and totalSy is int128\n        netSyIn = uint256(-_netSyIn);\n        netSyFee = uint256(_netSyFee);\n        netSyToReserve = uint256(_netSyToReserve);\n    }\n\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt) internal pure returns (uint256) {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + PMath.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (uint256(maxPtOut) * 999) / 1000;\n    }\n\n    function nextGuess(ApproxParams memory approx, uint256 iter) internal pure returns (uint256) {\n        if (iter == 0 && approx.guessOffchain != 0) return approx.guessOffchain;\n        if (approx.guessMin <= approx.guessMax) return (approx.guessMin + approx.guessMax) / 2;\n        revert("Slippage: guessMin > guessMax");\n    }\n\n    function validateApprox(ApproxParams memory approx) internal pure {\n        if (approx.guessMin > approx.guessMax || approx.eps > PMath.ONE) revert("Internal: INVALID_APPROX_PARAMS");\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.subMax0', 'start_line': 807, 'end_line': 811, 'offset_start': 29509, 'offset_end': 29657, 'content': 'function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.subNoNeg', 'start_line': 813, 'end_line': 816, 'offset_start': 29664, 'offset_end': 29864, 'content': 'function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.mulDown', 'start_line': 818, 'end_line': 823, 'offset_start': 29871, 'offset_end': 30045, 'content': 'function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.mulDown', 'start_line': 825, 'end_line': 830, 'offset_start': 30052, 'offset_end': 30223, 'content': 'function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.divDown', 'start_line': 832, 'end_line': 837, 'offset_start': 30230, 'offset_end': 30408, 'content': 'function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.divDown', 'start_line': 839, 'end_line': 844, 'offset_start': 30415, 'offset_end': 30590, 'content': 'function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.rawDivUp', 'start_line': 846, 'end_line': 848, 'offset_start': 30597, 'offset_end': 30707, 'content': 'function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.sqrt', 'start_line': 851, 'end_line': 862, 'offset_start': 30737, 'offset_end': 31037, 'content': 'function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.square', 'start_line': 864, 'end_line': 866, 'offset_start': 31044, 'offset_end': 31131, 'content': 'function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.squareDown', 'start_line': 868, 'end_line': 870, 'offset_start': 31138, 'offset_end': 31237, 'content': 'function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.abs', 'start_line': 872, 'end_line': 874, 'offset_start': 31244, 'offset_end': 31345, 'content': 'function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.neg', 'start_line': 876, 'end_line': 878, 'offset_start': 31352, 'offset_end': 31437, 'content': 'function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.neg', 'start_line': 880, 'end_line': 882, 'offset_start': 31444, 'offset_end': 31535, 'content': 'function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.max', 'start_line': 884, 'end_line': 886, 'offset_start': 31542, 'offset_end': 31647, 'content': 'function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.max', 'start_line': 888, 'end_line': 890, 'offset_start': 31654, 'offset_end': 31756, 'content': 'function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.min', 'start_line': 892, 'end_line': 894, 'offset_start': 31763, 'offset_end': 31868, 'content': 'function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.min', 'start_line': 896, 'end_line': 898, 'offset_start': 31875, 'offset_end': 31977, 'content': 'function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Int', 'start_line': 904, 'end_line': 907, 'offset_start': 32168, 'offset_end': 32304, 'content': 'function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Int128', 'start_line': 909, 'end_line': 912, 'offset_start': 32311, 'offset_end': 32465, 'content': 'function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Int128', 'start_line': 914, 'end_line': 916, 'offset_start': 32472, 'offset_end': 32567, 'content': 'function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Uint', 'start_line': 922, 'end_line': 925, 'offset_start': 32760, 'offset_end': 32874, 'content': 'function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Uint32', 'start_line': 927, 'end_line': 930, 'offset_start': 32881, 'offset_end': 33011, 'content': 'function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Uint64', 'start_line': 932, 'end_line': 935, 'offset_start': 33018, 'offset_end': 33148, 'content': 'function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Uint112', 'start_line': 937, 'end_line': 940, 'offset_start': 33155, 'offset_end': 33289, 'content': 'function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Uint96', 'start_line': 942, 'end_line': 945, 'offset_start': 33296, 'offset_end': 33426, 'content': 'function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Uint128', 'start_line': 947, 'end_line': 950, 'offset_start': 33433, 'offset_end': 33567, 'content': 'function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.Uint192', 'start_line': 952, 'end_line': 955, 'offset_start': 33574, 'offset_end': 33708, 'content': 'function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.isAApproxB', 'start_line': 957, 'end_line': 959, 'offset_start': 33715, 'offset_end': 33878, 'content': 'function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.isAGreaterApproxB', 'start_line': 961, 'end_line': 963, 'offset_start': 33885, 'offset_end': 34035, 'content': 'function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PMath.isASmallerApproxB', 'start_line': 965, 'end_line': 967, 'offset_start': 34042, 'offset_end': 34192, 'content': 'function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }', 'contract_name': 'PMath', 'contract_code': '{\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, "negative");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function square(uint256 x) internal pure returns (uint256) {\n        return x * x;\n    }\n\n    function squareDown(uint256 x) internal pure returns (uint256) {\n        return mulDown(x, x);\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint64(uint256 x) internal pure returns (uint64) {\n        require(x <= type(uint64).max);\n        return uint64(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function Uint192(uint256 x) internal pure returns (uint192) {\n        require(x <= type(uint192).max);\n        return uint192(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.isContract', 'start_line': 1009, 'end_line': 1015, 'offset_start': 35609, 'offset_end': 35928, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 1033, 'end_line': 1038, 'offset_start': 36844, 'offset_end': 37155, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1058, 'end_line': 1060, 'offset_start': 37898, 'offset_end': 38082, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1068, 'end_line': 1074, 'offset_start': 38305, 'offset_end': 38527, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1087, 'end_line': 1089, 'offset_start': 38890, 'offset_end': 39113, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1097, 'end_line': 1106, 'offset_start': 39362, 'offset_end': 39807, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1114, 'end_line': 1116, 'offset_start': 39985, 'offset_end': 40181, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1124, 'end_line': 1131, 'offset_start': 40366, 'offset_end': 40691, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1139, 'end_line': 1141, 'offset_start': 40871, 'offset_end': 41068, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1149, 'end_line': 1156, 'offset_start': 41255, 'offset_end': 41579, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 1164, 'end_line': 1180, 'offset_start': 41868, 'offset_end': 42495, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 1188, 'end_line': 1198, 'offset_start': 42717, 'offset_end': 43011, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 1200, 'end_line': 1212, 'offset_start': 43018, 'offset_end': 43557, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPGauge.totalActiveSupply', 'start_line': 1219, 'end_line': 1219, 'offset_start': 43656, 'offset_end': 43716, 'content': 'function totalActiveSupply() external view returns (uint256);', 'contract_name': 'IPGauge', 'contract_code': '{\n    function totalActiveSupply() external view returns (uint256);\n\n    function activeBalance(address user) external view returns (uint256);\n\n    // only available for newer factories. please check the verified contracts\n    event RedeemRewards(address indexed user, uint256[] rewardsOut);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPGauge.activeBalance', 'start_line': 1221, 'end_line': 1221, 'offset_start': 43723, 'offset_end': 43791, 'content': 'function activeBalance(address user) external view returns (uint256);', 'contract_name': 'IPGauge', 'contract_code': '{\n    function totalActiveSupply() external view returns (uint256);\n\n    function activeBalance(address user) external view returns (uint256);\n\n    // only available for newer factories. please check the verified contracts\n    event RedeemRewards(address indexed user, uint256[] rewardsOut);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 1253, 'end_line': 1253, 'offset_start': 44719, 'offset_end': 44773, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 1258, 'end_line': 1258, 'offset_start': 44857, 'offset_end': 44924, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 1267, 'end_line': 1267, 'offset_start': 45138, 'offset_end': 45207, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 1276, 'end_line': 1276, 'offset_start': 45483, 'offset_end': 45565, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 1292, 'end_line': 1292, 'offset_start': 46219, 'offset_end': 46292, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 1303, 'end_line': 1303, 'offset_start': 46591, 'offset_end': 46678, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MiniHelpers.isCurrentlyExpired', 'start_line': 1493, 'end_line': 1495, 'offset_start': 54384, 'offset_end': 54507, 'content': 'function isCurrentlyExpired(uint256 expiry) internal view returns (bool) {\n        return (expiry <= block.timestamp);\n    }', 'contract_name': 'MiniHelpers', 'contract_code': '{\n    function isCurrentlyExpired(uint256 expiry) internal view returns (bool) {\n        return (expiry <= block.timestamp);\n    }\n\n    function isExpired(uint256 expiry, uint256 blockTime) internal pure returns (bool) {\n        return (expiry <= blockTime);\n    }\n\n    function isTimeInThePast(uint256 timestamp) internal view returns (bool) {\n        return (timestamp <= block.timestamp); // same definition as isCurrentlyExpired\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MiniHelpers.isExpired', 'start_line': 1497, 'end_line': 1499, 'offset_start': 54514, 'offset_end': 54641, 'content': 'function isExpired(uint256 expiry, uint256 blockTime) internal pure returns (bool) {\n        return (expiry <= blockTime);\n    }', 'contract_name': 'MiniHelpers', 'contract_code': '{\n    function isCurrentlyExpired(uint256 expiry) internal view returns (bool) {\n        return (expiry <= block.timestamp);\n    }\n\n    function isExpired(uint256 expiry, uint256 blockTime) internal pure returns (bool) {\n        return (expiry <= blockTime);\n    }\n\n    function isTimeInThePast(uint256 timestamp) internal view returns (bool) {\n        return (timestamp <= block.timestamp); // same definition as isCurrentlyExpired\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MiniHelpers.isTimeInThePast', 'start_line': 1501, 'end_line': 1503, 'offset_start': 54648, 'offset_end': 54815, 'content': 'function isTimeInThePast(uint256 timestamp) internal view returns (bool) {\n        return (timestamp <= block.timestamp); // same definition as isCurrentlyExpired\n    }', 'contract_name': 'MiniHelpers', 'contract_code': '{\n    function isCurrentlyExpired(uint256 expiry) internal view returns (bool) {\n        return (expiry <= block.timestamp);\n    }\n\n    function isExpired(uint256 expiry, uint256 blockTime) internal pure returns (bool) {\n        return (expiry <= blockTime);\n    }\n\n    function isTimeInThePast(uint256 timestamp) internal view returns (bool) {\n        return (timestamp <= block.timestamp); // same definition as isCurrentlyExpired\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SYUtils.syToAsset', 'start_line': 1512, 'end_line': 1514, 'offset_start': 54955, 'offset_end': 55100, 'content': 'function syToAsset(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate) / ONE;\n    }', 'contract_name': 'SYUtils', 'contract_code': '{\n    uint256 internal constant ONE = 1e18;\n\n    function syToAsset(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate) / ONE;\n    }\n\n    function syToAssetUp(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate + ONE - 1) / ONE;\n    }\n\n    function assetToSy(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE) / exchangeRate;\n    }\n\n    function assetToSyUp(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE + exchangeRate - 1) / exchangeRate;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SYUtils.syToAssetUp', 'start_line': 1516, 'end_line': 1518, 'offset_start': 55107, 'offset_end': 55264, 'content': 'function syToAssetUp(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate + ONE - 1) / ONE;\n    }', 'contract_name': 'SYUtils', 'contract_code': '{\n    uint256 internal constant ONE = 1e18;\n\n    function syToAsset(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate) / ONE;\n    }\n\n    function syToAssetUp(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate + ONE - 1) / ONE;\n    }\n\n    function assetToSy(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE) / exchangeRate;\n    }\n\n    function assetToSyUp(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE + exchangeRate - 1) / exchangeRate;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SYUtils.assetToSy', 'start_line': 1520, 'end_line': 1522, 'offset_start': 55271, 'offset_end': 55422, 'content': 'function assetToSy(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE) / exchangeRate;\n    }', 'contract_name': 'SYUtils', 'contract_code': '{\n    uint256 internal constant ONE = 1e18;\n\n    function syToAsset(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate) / ONE;\n    }\n\n    function syToAssetUp(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate + ONE - 1) / ONE;\n    }\n\n    function assetToSy(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE) / exchangeRate;\n    }\n\n    function assetToSyUp(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE + exchangeRate - 1) / exchangeRate;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SYUtils.assetToSyUp', 'start_line': 1524, 'end_line': 1526, 'offset_start': 55429, 'offset_end': 55601, 'content': 'function assetToSyUp(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE + exchangeRate - 1) / exchangeRate;\n    }', 'contract_name': 'SYUtils', 'contract_code': '{\n    uint256 internal constant ONE = 1e18;\n\n    function syToAsset(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate) / ONE;\n    }\n\n    function syToAssetUp(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate + ONE - 1) / ONE;\n    }\n\n    function assetToSy(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE) / exchangeRate;\n    }\n\n    function assetToSyUp(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE + exchangeRate - 1) / exchangeRate;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'TokenHelper._transferIn', 'start_line': 1542, 'end_line': 1545, 'offset_start': 56092, 'offset_end': 56339, 'content': 'function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }', 'contract_name': 'TokenHelper', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'TokenHelper._transferFrom', 'start_line': 1547, 'end_line': 1549, 'offset_start': 56346, 'offset_end': 56507, 'content': 'function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }', 'contract_name': 'TokenHelper', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'TokenHelper._transferOut', 'start_line': 1551, 'end_line': 1559, 'offset_start': 56514, 'offset_end': 56845, 'content': 'function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }', 'contract_name': 'TokenHelper', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'TokenHelper._transferOut', 'start_line': 1561, 'end_line': 1570, 'offset_start': 56852, 'offset_end': 57229, 'content': 'function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }', 'contract_name': 'TokenHelper', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'TokenHelper._selfBalance', 'start_line': 1572, 'end_line': 1574, 'offset_start': 57236, 'offset_end': 57410, 'content': 'function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }', 'contract_name': 'TokenHelper', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'TokenHelper._selfBalance', 'start_line': 1576, 'end_line': 1578, 'offset_start': 57417, 'offset_end': 57538, 'content': 'function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }', 'contract_name': 'TokenHelper', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'TokenHelper._safeApprove', 'start_line': 1582, 'end_line': 1585, 'offset_start': 57744, 'offset_end': 58031, 'content': 'function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }', 'contract_name': 'TokenHelper', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'TokenHelper._safeApproveInf', 'start_line': 1587, 'end_line': 1593, 'offset_start': 58038, 'offset_end': 58329, 'content': 'function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }', 'contract_name': 'TokenHelper', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'TokenHelper._wrap_unwrap_ETH', 'start_line': 1595, 'end_line': 1598, 'offset_start': 58336, 'offset_end': 58559, 'content': 'function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }', 'contract_name': 'TokenHelper', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, "eth mismatch");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{value: amount}("");\n            require(success, "eth send failed");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, "length mismatch");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), "Safe Approve");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{value: netTokenIn}();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 1636, 'end_line': 1644, 'offset_start': 60019, 'offset_end': 60201, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 1653, 'end_line': 1653, 'offset_start': 60507, 'offset_end': 60569, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 1659, 'end_line': 1659, 'offset_start': 60762, 'offset_end': 60821, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.addLiquidityDualTokenAndPt', 'start_line': 1794, 'end_line': 1800, 'offset_start': 64568, 'offset_end': 64834, 'content': 'function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.addLiquidityDualSyAndPt', 'start_line': 1802, 'end_line': 1808, 'offset_start': 64841, 'offset_end': 65089, 'content': 'function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.addLiquiditySinglePt', 'start_line': 1810, 'end_line': 1817, 'offset_start': 65096, 'offset_end': 65372, 'content': 'function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.addLiquiditySingleToken', 'start_line': 1819, 'end_line': 1826, 'offset_start': 65379, 'offset_end': 65703, 'content': 'function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.addLiquiditySingleSy', 'start_line': 1828, 'end_line': 1835, 'offset_start': 65710, 'offset_end': 65992, 'content': 'function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.addLiquiditySingleTokenKeepYt', 'start_line': 1837, 'end_line': 1843, 'offset_start': 65999, 'offset_end': 66284, 'content': 'function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.addLiquiditySingleSyKeepYt', 'start_line': 1845, 'end_line': 1851, 'offset_start': 66291, 'offset_end': 66534, 'content': 'function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.removeLiquidityDualTokenAndPt', 'start_line': 1853, 'end_line': 1859, 'offset_start': 66541, 'offset_end': 66807, 'content': 'function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.removeLiquidityDualSyAndPt', 'start_line': 1861, 'end_line': 1867, 'offset_start': 66814, 'offset_end': 67042, 'content': 'function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.removeLiquiditySinglePt', 'start_line': 1869, 'end_line': 1876, 'offset_start': 67049, 'offset_end': 67340, 'content': 'function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.removeLiquiditySingleToken', 'start_line': 1878, 'end_line': 1884, 'offset_start': 67347, 'offset_end': 67623, 'content': 'function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPActionAddRemoveLiqV3.removeLiquiditySingleSy', 'start_line': 1886, 'end_line': 1892, 'offset_start': 67630, 'offset_end': 67868, 'content': 'function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);', 'contract_name': 'IPActionAddRemoveLiqV3', 'contract_code': '{\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netSyInterm\n    );\n\n    event AddLiquiditySingleSyKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netSyMintPy,\n        uint256 netLpOut,\n        uint256 netYtOut\n    );\n\n    event AddLiquiditySingleTokenKeepYt(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut,\n        uint256 netYtOut,\n        uint256 netSyMintPy,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut,\n        uint256 netSyInterm\n    );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm);\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed);\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm);\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPInterestManagerYT.userInterest', 'start_line': 1901, 'end_line': 1901, 'offset_start': 68037, 'offset_end': 68141, 'content': 'function userInterest(address user) external view returns (uint128 lastPYIndex, uint128 accruedInterest);', 'contract_name': 'IPInterestManagerYT', 'contract_code': '{\n    event CollectInterestFee(uint256 amountInterestFee);\n\n    function userInterest(address user) external view returns (uint128 lastPYIndex, uint128 accruedInterest);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Metadata.name', 'start_line': 1920, 'end_line': 1920, 'offset_start': 68523, 'offset_end': 68576, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC20Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Metadata.symbol', 'start_line': 1925, 'end_line': 1925, 'offset_start': 68644, 'offset_end': 68699, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC20Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Metadata.decimals', 'start_line': 1930, 'end_line': 1930, 'offset_start': 68776, 'offset_end': 68825, 'content': 'function decimals() external view returns (uint8);', 'contract_name': 'IERC20Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.deposit', 'start_line': 1999, 'end_line': 2004, 'offset_start': 71451, 'offset_end': 71643, 'content': 'function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.redeem', 'start_line': 2019, 'end_line': 2025, 'offset_start': 72287, 'offset_end': 72507, 'content': 'function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.exchangeRate', 'start_line': 2034, 'end_line': 2034, 'offset_start': 72880, 'offset_end': 72939, 'content': 'function exchangeRate() external view returns (uint256 res);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.claimRewards', 'start_line': 2044, 'end_line': 2044, 'offset_start': 73254, 'offset_end': 73339, 'content': 'function claimRewards(address user) external returns (uint256[] memory rewardAmounts);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.accruedRewards', 'start_line': 2051, 'end_line': 2051, 'offset_start': 73562, 'offset_end': 73654, 'content': 'function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.rewardIndexesCurrent', 'start_line': 2053, 'end_line': 2053, 'offset_start': 73661, 'offset_end': 73736, 'content': 'function rewardIndexesCurrent() external returns (uint256[] memory indexes);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.rewardIndexesStored', 'start_line': 2055, 'end_line': 2055, 'offset_start': 73743, 'offset_end': 73822, 'content': 'function rewardIndexesStored() external view returns (uint256[] memory indexes);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.getRewardTokens', 'start_line': 2060, 'end_line': 2060, 'offset_start': 73903, 'offset_end': 73970, 'content': 'function getRewardTokens() external view returns (address[] memory);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.yieldToken', 'start_line': 2065, 'end_line': 2065, 'offset_start': 74058, 'offset_end': 74111, 'content': 'function yieldToken() external view returns (address);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.getTokensIn', 'start_line': 2070, 'end_line': 2070, 'offset_start': 74190, 'offset_end': 74257, 'content': 'function getTokensIn() external view returns (address[] memory res);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.getTokensOut', 'start_line': 2075, 'end_line': 2075, 'offset_start': 74346, 'offset_end': 74414, 'content': 'function getTokensOut() external view returns (address[] memory res);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.isValidTokenIn', 'start_line': 2077, 'end_line': 2077, 'offset_start': 74421, 'offset_end': 74488, 'content': 'function isValidTokenIn(address token) external view returns (bool);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.isValidTokenOut', 'start_line': 2079, 'end_line': 2079, 'offset_start': 74495, 'offset_end': 74563, 'content': 'function isValidTokenOut(address token) external view returns (bool);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.previewDeposit', 'start_line': 2081, 'end_line': 2084, 'offset_start': 74570, 'offset_end': 74710, 'content': 'function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.previewRedeem', 'start_line': 2086, 'end_line': 2089, 'offset_start': 74717, 'offset_end': 74856, 'content': 'function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IStandardizedYield.assetInfo', 'start_line': 2098, 'end_line': 2098, 'offset_start': 75288, 'offset_end': 75395, 'content': 'function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);', 'contract_name': 'IStandardizedYield', 'contract_code': "{\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens,\n        2 for bridged yield bearing tokens like wstETH, rETH on Arbi whose the underlying asset doesn't exist on the chain)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo() external view returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IRewardManager.userReward', 'start_line': 2105, 'end_line': 2105, 'offset_start': 75501, 'offset_end': 75604, 'content': 'function userReward(address token, address user) external view returns (uint128 index, uint128 accrued);', 'contract_name': 'IRewardManager', 'contract_code': '{\n    function userReward(address token, address user) external view returns (uint128 index, uint128 accrued);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'LogExpMath.exp', 'start_line': 2198, 'end_line': 2335, 'offset_start': 80405, 'offset_end': 86235, 'content': 'function exp(int256 x) internal pure returns (int256) {\n        unchecked {\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, "Invalid exponent");\n\n            if (x < 0) {\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n                // Fixed point division requires multiplying by ONE_18.\n                return ((ONE_18 * ONE_18) / exp(-x));\n            }\n\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n            // decomposition.\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest x_n.\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n            // decomposition.\n\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n            // it and compute the accumulated product.\n\n            int256 firstAN;\n            if (x >= x0) {\n                x -= x0;\n                firstAN = a0;\n            } else if (x >= x1) {\n                x -= x1;\n                firstAN = a1;\n            } else {\n                firstAN = 1; // One with no decimal places\n            }\n\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n            // smaller terms.\n            x *= 100;\n\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\n            int256 product = ONE_20;\n\n            if (x >= x2) {\n                x -= x2;\n                product = (product * a2) / ONE_20;\n            }\n            if (x >= x3) {\n                x -= x3;\n                product = (product * a3) / ONE_20;\n            }\n            if (x >= x4) {\n                x -= x4;\n                product = (product * a4) / ONE_20;\n            }\n            if (x >= x5) {\n                x -= x5;\n                product = (product * a5) / ONE_20;\n            }\n            if (x >= x6) {\n                x -= x6;\n                product = (product * a6) / ONE_20;\n            }\n            if (x >= x7) {\n                x -= x7;\n                product = (product * a7) / ONE_20;\n            }\n            if (x >= x8) {\n                x -= x8;\n                product = (product * a8) / ONE_20;\n            }\n            if (x >= x9) {\n                x -= x9;\n                product = (product * a9) / ONE_20;\n            }\n\n            // x10 and x11 are unnecessary here since we have high enough precision already.\n\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n            // The first term is simply x.\n            term = x;\n            seriesSum += term;\n\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n            term = ((term * x) / ONE_20) / 2;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 3;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 4;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 5;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 6;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 7;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 8;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 9;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 10;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 11;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 12;\n            seriesSum += term;\n\n            // 12 Taylor terms are sufficient for 18 decimal precision.\n\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n            // and then drop two digits to return an 18 decimal value.\n\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n        }\n    }', 'contract_name': 'LogExpMath', 'contract_code': '{\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36\'s argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        unchecked {\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, "Invalid exponent");\n\n            if (x < 0) {\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n                // Fixed point division requires multiplying by ONE_18.\n                return ((ONE_18 * ONE_18) / exp(-x));\n            }\n\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n            // decomposition.\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest x_n.\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n            // decomposition.\n\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n            // it and compute the accumulated product.\n\n            int256 firstAN;\n            if (x >= x0) {\n                x -= x0;\n                firstAN = a0;\n            } else if (x >= x1) {\n                x -= x1;\n                firstAN = a1;\n            } else {\n                firstAN = 1; // One with no decimal places\n            }\n\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n            // smaller terms.\n            x *= 100;\n\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\n            int256 product = ONE_20;\n\n            if (x >= x2) {\n                x -= x2;\n                product = (product * a2) / ONE_20;\n            }\n            if (x >= x3) {\n                x -= x3;\n                product = (product * a3) / ONE_20;\n            }\n            if (x >= x4) {\n                x -= x4;\n                product = (product * a4) / ONE_20;\n            }\n            if (x >= x5) {\n                x -= x5;\n                product = (product * a5) / ONE_20;\n            }\n            if (x >= x6) {\n                x -= x6;\n                product = (product * a6) / ONE_20;\n            }\n            if (x >= x7) {\n                x -= x7;\n                product = (product * a7) / ONE_20;\n            }\n            if (x >= x8) {\n                x -= x8;\n                product = (product * a8) / ONE_20;\n            }\n            if (x >= x9) {\n                x -= x9;\n                product = (product * a9) / ONE_20;\n            }\n\n            // x10 and x11 are unnecessary here since we have high enough precision already.\n\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n            // The first term is simply x.\n            term = x;\n            seriesSum += term;\n\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n            term = ((term * x) / ONE_20) / 2;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 3;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 4;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 5;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 6;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 7;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 8;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 9;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 10;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 11;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 12;\n            seriesSum += term;\n\n            // 12 Taylor terms are sufficient for 18 decimal precision.\n\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n            // and then drop two digits to return an 18 decimal value.\n\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n        }\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        unchecked {\n            // The real natural logarithm is not defined for negative numbers or zero.\n            require(a > 0, "out of bounds");\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n                return _ln_36(a) / ONE_18;\n            } else {\n                return _ln(a);\n            }\n        }\n    }\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            if (y == 0) {\n                // We solve the 0^0 indetermination by making it equal one.\n                return uint256(ONE_18);\n            }\n\n            if (x == 0) {\n                return 0;\n            }\n\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n            // x^y = exp(y * ln(x)).\n\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n            require(x < 2 ** 255, "x out of bounds");\n            int256 x_int256 = int256(x);\n\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n            require(y < MILD_EXPONENT_BOUND, "y out of bounds");\n            int256 y_int256 = int256(y);\n\n            int256 logx_times_y;\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n                int256 ln_36_x = _ln_36(x_int256);\n\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn\'t as straightforward, since we can\'t just\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n                // (downscaled) last 18 decimals.\n                logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n            } else {\n                logx_times_y = _ln(x_int256) * y_int256;\n            }\n            logx_times_y /= ONE_18;\n\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\n            require(\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n                "product out of bounds"\n            );\n\n            return uint256(exp(logx_times_y));\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        unchecked {\n            if (a < ONE_18) {\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n                // Fixed point division requires multiplying by ONE_18.\n                return (-_ln((ONE_18 * ONE_18) / a));\n            }\n\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest a_n.\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n            // ONE_18 to convert them to fixed point.\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n            // by it and compute the accumulated sum.\n\n            int256 sum = 0;\n            if (a >= a0 * ONE_18) {\n                a /= a0; // Integer, not fixed point division\n                sum += x0;\n            }\n\n            if (a >= a1 * ONE_18) {\n                a /= a1; // Integer, not fixed point division\n                sum += x1;\n            }\n\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n            sum *= 100;\n            a *= 100;\n\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n            if (a >= a2) {\n                a = (a * ONE_20) / a2;\n                sum += x2;\n            }\n\n            if (a >= a3) {\n                a = (a * ONE_20) / a3;\n                sum += x3;\n            }\n\n            if (a >= a4) {\n                a = (a * ONE_20) / a4;\n                sum += x4;\n            }\n\n            if (a >= a5) {\n                a = (a * ONE_20) / a5;\n                sum += x5;\n            }\n\n            if (a >= a6) {\n                a = (a * ONE_20) / a6;\n                sum += x6;\n            }\n\n            if (a >= a7) {\n                a = (a * ONE_20) / a7;\n                sum += x7;\n            }\n\n            if (a >= a8) {\n                a = (a * ONE_20) / a8;\n                sum += x8;\n            }\n\n            if (a >= a9) {\n                a = (a * ONE_20) / a9;\n                sum += x9;\n            }\n\n            if (a >= a10) {\n                a = (a * ONE_20) / a10;\n                sum += x10;\n            }\n\n            if (a >= a11) {\n                a = (a * ONE_20) / a11;\n                sum += x11;\n            }\n\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n            // Let z = (a - 1) / (a + 1).\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n            // division by ONE_20.\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n            int256 z_squared = (z * z) / ONE_20;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 11;\n\n            // 6 Taylor terms are sufficient for 36 decimal precision.\n\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n            seriesSum *= 2;\n\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n            // value.\n\n            return (sum + seriesSum) / 100;\n        }\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        unchecked {\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n            // worthwhile.\n\n            // First, we transform x to a 36 digit fixed point value.\n            x *= ONE_18;\n\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n            // division by ONE_36.\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n            int256 z_squared = (z * z) / ONE_36;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 11;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 13;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 15;\n\n            // 8 Taylor terms are sufficient for 36 decimal precision.\n\n            // All that remains is multiplying by 2 (non fixed point).\n            return seriesSum * 2;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'LogExpMath.ln', 'start_line': 2340, 'end_line': 2350, 'offset_start': 86341, 'offset_end': 86737, 'content': 'function ln(int256 a) internal pure returns (int256) {\n        unchecked {\n            // The real natural logarithm is not defined for negative numbers or zero.\n            require(a > 0, "out of bounds");\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n                return _ln_36(a) / ONE_18;\n            } else {\n                return _ln(a);\n            }\n        }\n    }', 'contract_name': 'LogExpMath', 'contract_code': '{\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36\'s argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        unchecked {\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, "Invalid exponent");\n\n            if (x < 0) {\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n                // Fixed point division requires multiplying by ONE_18.\n                return ((ONE_18 * ONE_18) / exp(-x));\n            }\n\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n            // decomposition.\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest x_n.\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n            // decomposition.\n\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n            // it and compute the accumulated product.\n\n            int256 firstAN;\n            if (x >= x0) {\n                x -= x0;\n                firstAN = a0;\n            } else if (x >= x1) {\n                x -= x1;\n                firstAN = a1;\n            } else {\n                firstAN = 1; // One with no decimal places\n            }\n\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n            // smaller terms.\n            x *= 100;\n\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\n            int256 product = ONE_20;\n\n            if (x >= x2) {\n                x -= x2;\n                product = (product * a2) / ONE_20;\n            }\n            if (x >= x3) {\n                x -= x3;\n                product = (product * a3) / ONE_20;\n            }\n            if (x >= x4) {\n                x -= x4;\n                product = (product * a4) / ONE_20;\n            }\n            if (x >= x5) {\n                x -= x5;\n                product = (product * a5) / ONE_20;\n            }\n            if (x >= x6) {\n                x -= x6;\n                product = (product * a6) / ONE_20;\n            }\n            if (x >= x7) {\n                x -= x7;\n                product = (product * a7) / ONE_20;\n            }\n            if (x >= x8) {\n                x -= x8;\n                product = (product * a8) / ONE_20;\n            }\n            if (x >= x9) {\n                x -= x9;\n                product = (product * a9) / ONE_20;\n            }\n\n            // x10 and x11 are unnecessary here since we have high enough precision already.\n\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n            // The first term is simply x.\n            term = x;\n            seriesSum += term;\n\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n            term = ((term * x) / ONE_20) / 2;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 3;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 4;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 5;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 6;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 7;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 8;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 9;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 10;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 11;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 12;\n            seriesSum += term;\n\n            // 12 Taylor terms are sufficient for 18 decimal precision.\n\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n            // and then drop two digits to return an 18 decimal value.\n\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n        }\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        unchecked {\n            // The real natural logarithm is not defined for negative numbers or zero.\n            require(a > 0, "out of bounds");\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n                return _ln_36(a) / ONE_18;\n            } else {\n                return _ln(a);\n            }\n        }\n    }\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            if (y == 0) {\n                // We solve the 0^0 indetermination by making it equal one.\n                return uint256(ONE_18);\n            }\n\n            if (x == 0) {\n                return 0;\n            }\n\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n            // x^y = exp(y * ln(x)).\n\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n            require(x < 2 ** 255, "x out of bounds");\n            int256 x_int256 = int256(x);\n\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n            require(y < MILD_EXPONENT_BOUND, "y out of bounds");\n            int256 y_int256 = int256(y);\n\n            int256 logx_times_y;\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n                int256 ln_36_x = _ln_36(x_int256);\n\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn\'t as straightforward, since we can\'t just\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n                // (downscaled) last 18 decimals.\n                logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n            } else {\n                logx_times_y = _ln(x_int256) * y_int256;\n            }\n            logx_times_y /= ONE_18;\n\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\n            require(\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n                "product out of bounds"\n            );\n\n            return uint256(exp(logx_times_y));\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        unchecked {\n            if (a < ONE_18) {\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n                // Fixed point division requires multiplying by ONE_18.\n                return (-_ln((ONE_18 * ONE_18) / a));\n            }\n\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest a_n.\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n            // ONE_18 to convert them to fixed point.\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n            // by it and compute the accumulated sum.\n\n            int256 sum = 0;\n            if (a >= a0 * ONE_18) {\n                a /= a0; // Integer, not fixed point division\n                sum += x0;\n            }\n\n            if (a >= a1 * ONE_18) {\n                a /= a1; // Integer, not fixed point division\n                sum += x1;\n            }\n\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n            sum *= 100;\n            a *= 100;\n\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n            if (a >= a2) {\n                a = (a * ONE_20) / a2;\n                sum += x2;\n            }\n\n            if (a >= a3) {\n                a = (a * ONE_20) / a3;\n                sum += x3;\n            }\n\n            if (a >= a4) {\n                a = (a * ONE_20) / a4;\n                sum += x4;\n            }\n\n            if (a >= a5) {\n                a = (a * ONE_20) / a5;\n                sum += x5;\n            }\n\n            if (a >= a6) {\n                a = (a * ONE_20) / a6;\n                sum += x6;\n            }\n\n            if (a >= a7) {\n                a = (a * ONE_20) / a7;\n                sum += x7;\n            }\n\n            if (a >= a8) {\n                a = (a * ONE_20) / a8;\n                sum += x8;\n            }\n\n            if (a >= a9) {\n                a = (a * ONE_20) / a9;\n                sum += x9;\n            }\n\n            if (a >= a10) {\n                a = (a * ONE_20) / a10;\n                sum += x10;\n            }\n\n            if (a >= a11) {\n                a = (a * ONE_20) / a11;\n                sum += x11;\n            }\n\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n            // Let z = (a - 1) / (a + 1).\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n            // division by ONE_20.\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n            int256 z_squared = (z * z) / ONE_20;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 11;\n\n            // 6 Taylor terms are sufficient for 36 decimal precision.\n\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n            seriesSum *= 2;\n\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n            // value.\n\n            return (sum + seriesSum) / 100;\n        }\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        unchecked {\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n            // worthwhile.\n\n            // First, we transform x to a 36 digit fixed point value.\n            x *= ONE_18;\n\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n            // division by ONE_36.\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n            int256 z_squared = (z * z) / ONE_36;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 11;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 13;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 15;\n\n            // 8 Taylor terms are sufficient for 36 decimal precision.\n\n            // All that remains is multiplying by 2 (non fixed point).\n            return seriesSum * 2;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'LogExpMath.pow', 'start_line': 2357, 'end_line': 2405, 'offset_start': 86963, 'offset_end': 89313, 'content': 'function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            if (y == 0) {\n                // We solve the 0^0 indetermination by making it equal one.\n                return uint256(ONE_18);\n            }\n\n            if (x == 0) {\n                return 0;\n            }\n\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n            // x^y = exp(y * ln(x)).\n\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n            require(x < 2 ** 255, "x out of bounds");\n            int256 x_int256 = int256(x);\n\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n            require(y < MILD_EXPONENT_BOUND, "y out of bounds");\n            int256 y_int256 = int256(y);\n\n            int256 logx_times_y;\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n                int256 ln_36_x = _ln_36(x_int256);\n\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn\'t as straightforward, since we can\'t just\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n                // (downscaled) last 18 decimals.\n                logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n            } else {\n                logx_times_y = _ln(x_int256) * y_int256;\n            }\n            logx_times_y /= ONE_18;\n\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\n            require(\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n                "product out of bounds"\n            );\n\n            return uint256(exp(logx_times_y));\n        }\n    }', 'contract_name': 'LogExpMath', 'contract_code': '{\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36\'s argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        unchecked {\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, "Invalid exponent");\n\n            if (x < 0) {\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n                // Fixed point division requires multiplying by ONE_18.\n                return ((ONE_18 * ONE_18) / exp(-x));\n            }\n\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n            // decomposition.\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest x_n.\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n            // decomposition.\n\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n            // it and compute the accumulated product.\n\n            int256 firstAN;\n            if (x >= x0) {\n                x -= x0;\n                firstAN = a0;\n            } else if (x >= x1) {\n                x -= x1;\n                firstAN = a1;\n            } else {\n                firstAN = 1; // One with no decimal places\n            }\n\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n            // smaller terms.\n            x *= 100;\n\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\n            int256 product = ONE_20;\n\n            if (x >= x2) {\n                x -= x2;\n                product = (product * a2) / ONE_20;\n            }\n            if (x >= x3) {\n                x -= x3;\n                product = (product * a3) / ONE_20;\n            }\n            if (x >= x4) {\n                x -= x4;\n                product = (product * a4) / ONE_20;\n            }\n            if (x >= x5) {\n                x -= x5;\n                product = (product * a5) / ONE_20;\n            }\n            if (x >= x6) {\n                x -= x6;\n                product = (product * a6) / ONE_20;\n            }\n            if (x >= x7) {\n                x -= x7;\n                product = (product * a7) / ONE_20;\n            }\n            if (x >= x8) {\n                x -= x8;\n                product = (product * a8) / ONE_20;\n            }\n            if (x >= x9) {\n                x -= x9;\n                product = (product * a9) / ONE_20;\n            }\n\n            // x10 and x11 are unnecessary here since we have high enough precision already.\n\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n            // The first term is simply x.\n            term = x;\n            seriesSum += term;\n\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n            term = ((term * x) / ONE_20) / 2;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 3;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 4;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 5;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 6;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 7;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 8;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 9;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 10;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 11;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 12;\n            seriesSum += term;\n\n            // 12 Taylor terms are sufficient for 18 decimal precision.\n\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n            // and then drop two digits to return an 18 decimal value.\n\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n        }\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        unchecked {\n            // The real natural logarithm is not defined for negative numbers or zero.\n            require(a > 0, "out of bounds");\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n                return _ln_36(a) / ONE_18;\n            } else {\n                return _ln(a);\n            }\n        }\n    }\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            if (y == 0) {\n                // We solve the 0^0 indetermination by making it equal one.\n                return uint256(ONE_18);\n            }\n\n            if (x == 0) {\n                return 0;\n            }\n\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n            // x^y = exp(y * ln(x)).\n\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n            require(x < 2 ** 255, "x out of bounds");\n            int256 x_int256 = int256(x);\n\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n            require(y < MILD_EXPONENT_BOUND, "y out of bounds");\n            int256 y_int256 = int256(y);\n\n            int256 logx_times_y;\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n                int256 ln_36_x = _ln_36(x_int256);\n\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn\'t as straightforward, since we can\'t just\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n                // (downscaled) last 18 decimals.\n                logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n            } else {\n                logx_times_y = _ln(x_int256) * y_int256;\n            }\n            logx_times_y /= ONE_18;\n\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\n            require(\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n                "product out of bounds"\n            );\n\n            return uint256(exp(logx_times_y));\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        unchecked {\n            if (a < ONE_18) {\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n                // Fixed point division requires multiplying by ONE_18.\n                return (-_ln((ONE_18 * ONE_18) / a));\n            }\n\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest a_n.\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n            // ONE_18 to convert them to fixed point.\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n            // by it and compute the accumulated sum.\n\n            int256 sum = 0;\n            if (a >= a0 * ONE_18) {\n                a /= a0; // Integer, not fixed point division\n                sum += x0;\n            }\n\n            if (a >= a1 * ONE_18) {\n                a /= a1; // Integer, not fixed point division\n                sum += x1;\n            }\n\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n            sum *= 100;\n            a *= 100;\n\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n            if (a >= a2) {\n                a = (a * ONE_20) / a2;\n                sum += x2;\n            }\n\n            if (a >= a3) {\n                a = (a * ONE_20) / a3;\n                sum += x3;\n            }\n\n            if (a >= a4) {\n                a = (a * ONE_20) / a4;\n                sum += x4;\n            }\n\n            if (a >= a5) {\n                a = (a * ONE_20) / a5;\n                sum += x5;\n            }\n\n            if (a >= a6) {\n                a = (a * ONE_20) / a6;\n                sum += x6;\n            }\n\n            if (a >= a7) {\n                a = (a * ONE_20) / a7;\n                sum += x7;\n            }\n\n            if (a >= a8) {\n                a = (a * ONE_20) / a8;\n                sum += x8;\n            }\n\n            if (a >= a9) {\n                a = (a * ONE_20) / a9;\n                sum += x9;\n            }\n\n            if (a >= a10) {\n                a = (a * ONE_20) / a10;\n                sum += x10;\n            }\n\n            if (a >= a11) {\n                a = (a * ONE_20) / a11;\n                sum += x11;\n            }\n\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n            // Let z = (a - 1) / (a + 1).\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n            // division by ONE_20.\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n            int256 z_squared = (z * z) / ONE_20;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 11;\n\n            // 6 Taylor terms are sufficient for 36 decimal precision.\n\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n            seriesSum *= 2;\n\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n            // value.\n\n            return (sum + seriesSum) / 100;\n        }\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        unchecked {\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n            // worthwhile.\n\n            // First, we transform x to a 36 digit fixed point value.\n            x *= ONE_18;\n\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n            // division by ONE_36.\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n            int256 z_squared = (z * z) / ONE_36;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 11;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 13;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 15;\n\n            // 8 Taylor terms are sufficient for 36 decimal precision.\n\n            // All that remains is multiplying by 2 (non fixed point).\n            return seriesSum * 2;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'LogExpMath._ln', 'start_line': 2410, 'end_line': 2544, 'offset_start': 89428, 'offset_end': 94824, 'content': 'function _ln(int256 a) private pure returns (int256) {\n        unchecked {\n            if (a < ONE_18) {\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n                // Fixed point division requires multiplying by ONE_18.\n                return (-_ln((ONE_18 * ONE_18) / a));\n            }\n\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest a_n.\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n            // ONE_18 to convert them to fixed point.\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n            // by it and compute the accumulated sum.\n\n            int256 sum = 0;\n            if (a >= a0 * ONE_18) {\n                a /= a0; // Integer, not fixed point division\n                sum += x0;\n            }\n\n            if (a >= a1 * ONE_18) {\n                a /= a1; // Integer, not fixed point division\n                sum += x1;\n            }\n\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n            sum *= 100;\n            a *= 100;\n\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n            if (a >= a2) {\n                a = (a * ONE_20) / a2;\n                sum += x2;\n            }\n\n            if (a >= a3) {\n                a = (a * ONE_20) / a3;\n                sum += x3;\n            }\n\n            if (a >= a4) {\n                a = (a * ONE_20) / a4;\n                sum += x4;\n            }\n\n            if (a >= a5) {\n                a = (a * ONE_20) / a5;\n                sum += x5;\n            }\n\n            if (a >= a6) {\n                a = (a * ONE_20) / a6;\n                sum += x6;\n            }\n\n            if (a >= a7) {\n                a = (a * ONE_20) / a7;\n                sum += x7;\n            }\n\n            if (a >= a8) {\n                a = (a * ONE_20) / a8;\n                sum += x8;\n            }\n\n            if (a >= a9) {\n                a = (a * ONE_20) / a9;\n                sum += x9;\n            }\n\n            if (a >= a10) {\n                a = (a * ONE_20) / a10;\n                sum += x10;\n            }\n\n            if (a >= a11) {\n                a = (a * ONE_20) / a11;\n                sum += x11;\n            }\n\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n            // Let z = (a - 1) / (a + 1).\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n            // division by ONE_20.\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n            int256 z_squared = (z * z) / ONE_20;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 11;\n\n            // 6 Taylor terms are sufficient for 36 decimal precision.\n\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n            seriesSum *= 2;\n\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n            // value.\n\n            return (sum + seriesSum) / 100;\n        }\n    }', 'contract_name': 'LogExpMath', 'contract_code': '{\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36\'s argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        unchecked {\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, "Invalid exponent");\n\n            if (x < 0) {\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n                // Fixed point division requires multiplying by ONE_18.\n                return ((ONE_18 * ONE_18) / exp(-x));\n            }\n\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n            // decomposition.\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest x_n.\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n            // decomposition.\n\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n            // it and compute the accumulated product.\n\n            int256 firstAN;\n            if (x >= x0) {\n                x -= x0;\n                firstAN = a0;\n            } else if (x >= x1) {\n                x -= x1;\n                firstAN = a1;\n            } else {\n                firstAN = 1; // One with no decimal places\n            }\n\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n            // smaller terms.\n            x *= 100;\n\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\n            int256 product = ONE_20;\n\n            if (x >= x2) {\n                x -= x2;\n                product = (product * a2) / ONE_20;\n            }\n            if (x >= x3) {\n                x -= x3;\n                product = (product * a3) / ONE_20;\n            }\n            if (x >= x4) {\n                x -= x4;\n                product = (product * a4) / ONE_20;\n            }\n            if (x >= x5) {\n                x -= x5;\n                product = (product * a5) / ONE_20;\n            }\n            if (x >= x6) {\n                x -= x6;\n                product = (product * a6) / ONE_20;\n            }\n            if (x >= x7) {\n                x -= x7;\n                product = (product * a7) / ONE_20;\n            }\n            if (x >= x8) {\n                x -= x8;\n                product = (product * a8) / ONE_20;\n            }\n            if (x >= x9) {\n                x -= x9;\n                product = (product * a9) / ONE_20;\n            }\n\n            // x10 and x11 are unnecessary here since we have high enough precision already.\n\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n            // The first term is simply x.\n            term = x;\n            seriesSum += term;\n\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n            term = ((term * x) / ONE_20) / 2;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 3;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 4;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 5;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 6;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 7;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 8;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 9;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 10;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 11;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 12;\n            seriesSum += term;\n\n            // 12 Taylor terms are sufficient for 18 decimal precision.\n\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n            // and then drop two digits to return an 18 decimal value.\n\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n        }\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        unchecked {\n            // The real natural logarithm is not defined for negative numbers or zero.\n            require(a > 0, "out of bounds");\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n                return _ln_36(a) / ONE_18;\n            } else {\n                return _ln(a);\n            }\n        }\n    }\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            if (y == 0) {\n                // We solve the 0^0 indetermination by making it equal one.\n                return uint256(ONE_18);\n            }\n\n            if (x == 0) {\n                return 0;\n            }\n\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n            // x^y = exp(y * ln(x)).\n\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n            require(x < 2 ** 255, "x out of bounds");\n            int256 x_int256 = int256(x);\n\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n            require(y < MILD_EXPONENT_BOUND, "y out of bounds");\n            int256 y_int256 = int256(y);\n\n            int256 logx_times_y;\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n                int256 ln_36_x = _ln_36(x_int256);\n\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn\'t as straightforward, since we can\'t just\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n                // (downscaled) last 18 decimals.\n                logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n            } else {\n                logx_times_y = _ln(x_int256) * y_int256;\n            }\n            logx_times_y /= ONE_18;\n\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\n            require(\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n                "product out of bounds"\n            );\n\n            return uint256(exp(logx_times_y));\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        unchecked {\n            if (a < ONE_18) {\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n                // Fixed point division requires multiplying by ONE_18.\n                return (-_ln((ONE_18 * ONE_18) / a));\n            }\n\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest a_n.\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n            // ONE_18 to convert them to fixed point.\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n            // by it and compute the accumulated sum.\n\n            int256 sum = 0;\n            if (a >= a0 * ONE_18) {\n                a /= a0; // Integer, not fixed point division\n                sum += x0;\n            }\n\n            if (a >= a1 * ONE_18) {\n                a /= a1; // Integer, not fixed point division\n                sum += x1;\n            }\n\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n            sum *= 100;\n            a *= 100;\n\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n            if (a >= a2) {\n                a = (a * ONE_20) / a2;\n                sum += x2;\n            }\n\n            if (a >= a3) {\n                a = (a * ONE_20) / a3;\n                sum += x3;\n            }\n\n            if (a >= a4) {\n                a = (a * ONE_20) / a4;\n                sum += x4;\n            }\n\n            if (a >= a5) {\n                a = (a * ONE_20) / a5;\n                sum += x5;\n            }\n\n            if (a >= a6) {\n                a = (a * ONE_20) / a6;\n                sum += x6;\n            }\n\n            if (a >= a7) {\n                a = (a * ONE_20) / a7;\n                sum += x7;\n            }\n\n            if (a >= a8) {\n                a = (a * ONE_20) / a8;\n                sum += x8;\n            }\n\n            if (a >= a9) {\n                a = (a * ONE_20) / a9;\n                sum += x9;\n            }\n\n            if (a >= a10) {\n                a = (a * ONE_20) / a10;\n                sum += x10;\n            }\n\n            if (a >= a11) {\n                a = (a * ONE_20) / a11;\n                sum += x11;\n            }\n\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n            // Let z = (a - 1) / (a + 1).\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n            // division by ONE_20.\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n            int256 z_squared = (z * z) / ONE_20;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 11;\n\n            // 6 Taylor terms are sufficient for 36 decimal precision.\n\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n            seriesSum *= 2;\n\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n            // value.\n\n            return (sum + seriesSum) / 100;\n        }\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        unchecked {\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n            // worthwhile.\n\n            // First, we transform x to a 36 digit fixed point value.\n            x *= ONE_18;\n\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n            // division by ONE_36.\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n            int256 z_squared = (z * z) / ONE_36;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 11;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 13;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 15;\n\n            // 8 Taylor terms are sufficient for 36 decimal precision.\n\n            // All that remains is multiplying by 2 (non fixed point).\n            return seriesSum * 2;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'LogExpMath._ln_36', 'start_line': 2552, 'end_line': 2601, 'offset_start': 95091, 'offset_end': 96962, 'content': 'function _ln_36(int256 x) private pure returns (int256) {\n        unchecked {\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n            // worthwhile.\n\n            // First, we transform x to a 36 digit fixed point value.\n            x *= ONE_18;\n\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n            // division by ONE_36.\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n            int256 z_squared = (z * z) / ONE_36;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 11;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 13;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 15;\n\n            // 8 Taylor terms are sufficient for 36 decimal precision.\n\n            // All that remains is multiplying by 2 (non fixed point).\n            return seriesSum * 2;\n        }\n    }', 'contract_name': 'LogExpMath', 'contract_code': '{\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36\'s argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        unchecked {\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, "Invalid exponent");\n\n            if (x < 0) {\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n                // Fixed point division requires multiplying by ONE_18.\n                return ((ONE_18 * ONE_18) / exp(-x));\n            }\n\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n            // decomposition.\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest x_n.\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n            // decomposition.\n\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n            // it and compute the accumulated product.\n\n            int256 firstAN;\n            if (x >= x0) {\n                x -= x0;\n                firstAN = a0;\n            } else if (x >= x1) {\n                x -= x1;\n                firstAN = a1;\n            } else {\n                firstAN = 1; // One with no decimal places\n            }\n\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n            // smaller terms.\n            x *= 100;\n\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\n            int256 product = ONE_20;\n\n            if (x >= x2) {\n                x -= x2;\n                product = (product * a2) / ONE_20;\n            }\n            if (x >= x3) {\n                x -= x3;\n                product = (product * a3) / ONE_20;\n            }\n            if (x >= x4) {\n                x -= x4;\n                product = (product * a4) / ONE_20;\n            }\n            if (x >= x5) {\n                x -= x5;\n                product = (product * a5) / ONE_20;\n            }\n            if (x >= x6) {\n                x -= x6;\n                product = (product * a6) / ONE_20;\n            }\n            if (x >= x7) {\n                x -= x7;\n                product = (product * a7) / ONE_20;\n            }\n            if (x >= x8) {\n                x -= x8;\n                product = (product * a8) / ONE_20;\n            }\n            if (x >= x9) {\n                x -= x9;\n                product = (product * a9) / ONE_20;\n            }\n\n            // x10 and x11 are unnecessary here since we have high enough precision already.\n\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n            // The first term is simply x.\n            term = x;\n            seriesSum += term;\n\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n            term = ((term * x) / ONE_20) / 2;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 3;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 4;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 5;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 6;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 7;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 8;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 9;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 10;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 11;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 12;\n            seriesSum += term;\n\n            // 12 Taylor terms are sufficient for 18 decimal precision.\n\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n            // and then drop two digits to return an 18 decimal value.\n\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n        }\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        unchecked {\n            // The real natural logarithm is not defined for negative numbers or zero.\n            require(a > 0, "out of bounds");\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n                return _ln_36(a) / ONE_18;\n            } else {\n                return _ln(a);\n            }\n        }\n    }\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            if (y == 0) {\n                // We solve the 0^0 indetermination by making it equal one.\n                return uint256(ONE_18);\n            }\n\n            if (x == 0) {\n                return 0;\n            }\n\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n            // x^y = exp(y * ln(x)).\n\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n            require(x < 2 ** 255, "x out of bounds");\n            int256 x_int256 = int256(x);\n\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n            require(y < MILD_EXPONENT_BOUND, "y out of bounds");\n            int256 y_int256 = int256(y);\n\n            int256 logx_times_y;\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n                int256 ln_36_x = _ln_36(x_int256);\n\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn\'t as straightforward, since we can\'t just\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n                // (downscaled) last 18 decimals.\n                logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n            } else {\n                logx_times_y = _ln(x_int256) * y_int256;\n            }\n            logx_times_y /= ONE_18;\n\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\n            require(\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n                "product out of bounds"\n            );\n\n            return uint256(exp(logx_times_y));\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        unchecked {\n            if (a < ONE_18) {\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n                // Fixed point division requires multiplying by ONE_18.\n                return (-_ln((ONE_18 * ONE_18) / a));\n            }\n\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest a_n.\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n            // ONE_18 to convert them to fixed point.\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n            // by it and compute the accumulated sum.\n\n            int256 sum = 0;\n            if (a >= a0 * ONE_18) {\n                a /= a0; // Integer, not fixed point division\n                sum += x0;\n            }\n\n            if (a >= a1 * ONE_18) {\n                a /= a1; // Integer, not fixed point division\n                sum += x1;\n            }\n\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n            sum *= 100;\n            a *= 100;\n\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n            if (a >= a2) {\n                a = (a * ONE_20) / a2;\n                sum += x2;\n            }\n\n            if (a >= a3) {\n                a = (a * ONE_20) / a3;\n                sum += x3;\n            }\n\n            if (a >= a4) {\n                a = (a * ONE_20) / a4;\n                sum += x4;\n            }\n\n            if (a >= a5) {\n                a = (a * ONE_20) / a5;\n                sum += x5;\n            }\n\n            if (a >= a6) {\n                a = (a * ONE_20) / a6;\n                sum += x6;\n            }\n\n            if (a >= a7) {\n                a = (a * ONE_20) / a7;\n                sum += x7;\n            }\n\n            if (a >= a8) {\n                a = (a * ONE_20) / a8;\n                sum += x8;\n            }\n\n            if (a >= a9) {\n                a = (a * ONE_20) / a9;\n                sum += x9;\n            }\n\n            if (a >= a10) {\n                a = (a * ONE_20) / a10;\n                sum += x10;\n            }\n\n            if (a >= a11) {\n                a = (a * ONE_20) / a11;\n                sum += x11;\n            }\n\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n            // Let z = (a - 1) / (a + 1).\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n            // division by ONE_20.\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n            int256 z_squared = (z * z) / ONE_20;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 11;\n\n            // 6 Taylor terms are sufficient for 36 decimal precision.\n\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n            seriesSum *= 2;\n\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n            // value.\n\n            return (sum + seriesSum) / 100;\n        }\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        unchecked {\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n            // worthwhile.\n\n            // First, we transform x to a 36 digit fixed point value.\n            x *= ONE_18;\n\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n            // division by ONE_36.\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n            int256 z_squared = (z * z) / ONE_36;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 11;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 13;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 15;\n\n            // 8 Taylor terms are sufficient for 36 decimal precision.\n\n            // All that remains is multiplying by 2 (non fixed point).\n            return seriesSum * 2;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.deposit', 'start_line': 2634, 'end_line': 2634, 'offset_start': 98336, 'offset_end': 98371, 'content': 'function deposit() external payable;', 'contract_name': 'IWETH', 'contract_code': '{\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.withdraw', 'start_line': 2636, 'end_line': 2636, 'offset_start': 98378, 'offset_end': 98417, 'content': 'function withdraw(uint256 wad) external;', 'contract_name': 'IWETH', 'contract_code': '{\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PYIndexLib.newIndex', 'start_line': 2653, 'end_line': 2655, 'offset_start': 98756, 'offset_end': 98874, 'content': 'function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }', 'contract_name': 'PYIndexLib', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PYIndexLib.syToAsset', 'start_line': 2657, 'end_line': 2659, 'offset_start': 98881, 'offset_end': 99038, 'content': 'function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }', 'contract_name': 'PYIndexLib', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PYIndexLib.assetToSy', 'start_line': 2661, 'end_line': 2663, 'offset_start': 99045, 'offset_end': 99208, 'content': 'function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }', 'contract_name': 'PYIndexLib', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PYIndexLib.assetToSyUp', 'start_line': 2665, 'end_line': 2667, 'offset_start': 99215, 'offset_end': 99382, 'content': 'function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }', 'contract_name': 'PYIndexLib', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PYIndexLib.syToAssetUp', 'start_line': 2669, 'end_line': 2672, 'offset_start': 99389, 'offset_end': 99583, 'content': 'function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }', 'contract_name': 'PYIndexLib', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PYIndexLib.syToAsset', 'start_line': 2674, 'end_line': 2677, 'offset_start': 99590, 'offset_end': 99827, 'content': 'function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }', 'contract_name': 'PYIndexLib', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PYIndexLib.assetToSy', 'start_line': 2679, 'end_line': 2682, 'offset_start': 99834, 'offset_end': 100080, 'content': 'function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }', 'contract_name': 'PYIndexLib', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'PYIndexLib.assetToSyUp', 'start_line': 2684, 'end_line': 2687, 'offset_start': 100087, 'offset_end': 100337, 'content': 'function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }', 'contract_name': 'PYIndexLib', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount) internal pure returns (uint256) {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount) internal pure returns (uint256) {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount) internal pure returns (int256) {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount) internal pure returns (int256) {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.addLiquidityDualTokenAndPt', 'start_line': 2706, 'end_line': 2740, 'offset_start': 100903, 'offset_end': 102098, 'content': 'function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.addLiquidityDualSyAndPt', 'start_line': 2742, 'end_line': 2765, 'offset_start': 102105, 'offset_end': 103048, 'content': 'function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.addLiquiditySinglePt', 'start_line': 2769, 'end_line': 2813, 'offset_start': 103125, 'offset_end': 104690, 'content': 'function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3._entry_addLiquiditySinglePt', 'start_line': 2815, 'end_line': 2817, 'offset_start': 104697, 'offset_end': 104878, 'content': 'function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.addLiquiditySingleToken', 'start_line': 2821, 'end_line': 2853, 'offset_start': 104958, 'offset_end': 105940, 'content': 'function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.addLiquiditySingleSy', 'start_line': 2855, 'end_line': 2879, 'offset_start': 105947, 'offset_end': 106734, 'content': 'function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3._entry_addLiquiditySingleSy', 'start_line': 2881, 'end_line': 2883, 'offset_start': 106741, 'offset_end': 106922, 'content': 'function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3._addLiquiditySingleSy', 'start_line': 2885, 'end_line': 2924, 'offset_start': 106929, 'offset_end': 108238, 'content': 'function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.addLiquiditySingleTokenKeepYt', 'start_line': 2928, 'end_line': 2960, 'offset_start': 108326, 'offset_end': 109280, 'content': 'function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.addLiquiditySingleSyKeepYt', 'start_line': 2962, 'end_line': 2984, 'offset_start': 109287, 'offset_end': 110014, 'content': 'function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3._addLiquiditySingleSyKeepYt', 'start_line': 2986, 'end_line': 3018, 'offset_start': 110021, 'offset_end': 111170, 'content': 'function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.removeLiquidityDualTokenAndPt', 'start_line': 3022, 'end_line': 3049, 'offset_start': 111245, 'offset_end': 112257, 'content': 'function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.removeLiquidityDualSyAndPt', 'start_line': 3051, 'end_line': 3066, 'offset_start': 112264, 'offset_end': 112919, 'content': 'function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.removeLiquiditySinglePt', 'start_line': 3069, 'end_line': 3103, 'offset_start': 112998, 'offset_end': 114140, 'content': 'function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.removeLiquiditySingleToken', 'start_line': 3107, 'end_line': 3131, 'offset_start': 114223, 'offset_end': 115073, 'content': 'function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.removeLiquiditySingleSy', 'start_line': 3133, 'end_line': 3145, 'offset_start': 115080, 'offset_end': 115601, 'content': 'function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3._removeLiquiditySingleSy', 'start_line': 3148, 'end_line': 3161, 'offset_start': 115655, 'offset_end': 116232, 'content': 'function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.__removeLpToSyAfterExpiry', 'start_line': 3163, 'end_line': 3171, 'offset_start': 116239, 'offset_end': 116615, 'content': 'function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionAddRemoveLiqV3.__removeLpToSyBeforeExpiry', 'start_line': 3173, 'end_line': 3192, 'offset_start': 116622, 'offset_end': 117312, 'content': 'function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }', 'contract_name': 'ActionAddRemoveLiqV3', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert("Slippage: NOT_ALL_SY_USED");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert("Slippage: INSUFFICIENT_LP_OUT");\n        if (netYtOut < minYtOut) revert("Slippage: INSUFFICIENT_YT_OUT");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._mintSyFromToken', 'start_line': 3218, 'end_line': 3241, 'offset_start': 118097, 'offset_end': 118948, 'content': 'function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._swapTokenInput', 'start_line': 3243, 'end_line': 3252, 'offset_start': 118955, 'offset_end': 119385, 'content': 'function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase.__mintSy', 'start_line': 3254, 'end_line': 3269, 'offset_start': 119392, 'offset_end': 119896, 'content': 'function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._redeemSyToToken', 'start_line': 3271, 'end_line': 3299, 'offset_start': 119903, 'offset_end': 120994, 'content': 'function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase.__redeemSy', 'start_line': 3301, 'end_line': 3313, 'offset_start': 121001, 'offset_end': 121404, 'content': 'function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._mintPyFromSy', 'start_line': 3315, 'end_line': 3329, 'offset_start': 121411, 'offset_end': 121858, 'content': 'function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._redeemPyToSy', 'start_line': 3331, 'end_line': 3346, 'offset_start': 121865, 'offset_end': 122409, 'content': 'function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._readMarket', 'start_line': 3350, 'end_line': 3352, 'offset_start': 122467, 'offset_end': 122611, 'content': 'function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._entry_swapExactPtForSy', 'start_line': 3356, 'end_line': 3358, 'offset_start': 122670, 'offset_end': 122851, 'content': 'function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._swapExactPtForSy', 'start_line': 3360, 'end_line': 3391, 'offset_start': 122858, 'offset_end': 123887, 'content': 'function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._entry_swapExactSyForPt', 'start_line': 3393, 'end_line': 3395, 'offset_start': 123894, 'offset_end': 124075, 'content': 'function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._swapExactSyForPt', 'start_line': 3397, 'end_line': 3431, 'offset_start': 124082, 'offset_end': 125309, 'content': 'function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._fillLimit', 'start_line': 3434, 'end_line': 3476, 'offset_start': 125372, 'offset_end': 126868, 'content': 'function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'ActionBase._isEmptyLimit', 'start_line': 3478, 'end_line': 3480, 'offset_start': 126875, 'offset_end': 127030, 'content': 'function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }', 'contract_name': 'ActionBase', 'contract_code': '{\n    using MarketApproxPtOutLib for MarketState;\n    using PMath for uint256;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    bytes internal constant EMPTY_BYTES = abi.encode();\n\n    // ----------------- MINT REDEEM SY PY -----------------\n\n    function _mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) internal returns (uint256 netSyOut) {\n        SwapType swapType = inp.swapData.swapType;\n\n        uint256 netTokenMintSy;\n\n        if (swapType == SwapType.NONE) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else if (swapType == SwapType.ETH_WETH) {\n            _transferIn(inp.tokenIn, msg.sender, inp.netTokenIn);\n            _wrap_unwrap_ETH(inp.tokenIn, inp.tokenMintSy, inp.netTokenIn);\n            netTokenMintSy = inp.netTokenIn;\n        } else {\n            _swapTokenInput(inp);\n            netTokenMintSy = _selfBalance(inp.tokenMintSy);\n        }\n\n        netSyOut = __mintSy(receiver, SY, netTokenMintSy, minSyOut, inp);\n    }\n\n    function _swapTokenInput(TokenInput calldata inp) internal {\n        if (inp.tokenIn == NATIVE) _transferIn(NATIVE, msg.sender, inp.netTokenIn);\n        else _transferFrom(IERC20(inp.tokenIn), msg.sender, inp.pendleSwap, inp.netTokenIn);\n\n        IPSwapAggregator(inp.pendleSwap).swap{value: inp.tokenIn == NATIVE ? inp.netTokenIn : 0}(\n            inp.tokenIn,\n            inp.netTokenIn,\n            inp.swapData\n        );\n    }\n\n    function __mintSy(\n        address receiver,\n        address SY,\n        uint256 netTokenMintSy,\n        uint256 minSyOut,\n        TokenInput calldata inp\n    ) private returns (uint256 netSyOut) {\n        uint256 netNative = inp.tokenMintSy == NATIVE ? netTokenMintSy : 0;\n        _safeApproveInf(inp.tokenMintSy, SY);\n        netSyOut = IStandardizedYield(SY).deposit{value: netNative}(\n            receiver,\n            inp.tokenMintSy,\n            netTokenMintSy,\n            minSyOut\n        );\n    }\n\n    function _redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) internal returns (uint256 netTokenOut) {\n        SwapType swapType = out.swapData.swapType;\n\n        if (swapType == SwapType.NONE) {\n            netTokenOut = __redeemSy(receiver, SY, netSyIn, out, doPull);\n        } else if (swapType == SwapType.ETH_WETH) {\n            netTokenOut = __redeemSy(address(this), SY, netSyIn, out, doPull); // ETH:WETH is 1:1\n\n            _wrap_unwrap_ETH(out.tokenRedeemSy, out.tokenOut, netTokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        } else {\n            uint256 netTokenRedeemed = __redeemSy(out.pendleSwap, SY, netSyIn, out, doPull);\n\n            IPSwapAggregator(out.pendleSwap).swap(out.tokenRedeemSy, netTokenRedeemed, out.swapData);\n\n            netTokenOut = _selfBalance(out.tokenOut);\n\n            _transferOut(out.tokenOut, receiver, netTokenOut);\n        }\n\n        if (netTokenOut < out.minTokenOut) revert("Slippage: INSUFFICIENT_TOKEN_OUT");\n    }\n\n    function __redeemSy(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata out,\n        bool doPull\n    ) private returns (uint256 netTokenRedeemed) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, SY, netSyIn);\n        }\n\n        netTokenRedeemed = IStandardizedYield(SY).redeem(receiver, netSyIn, out.tokenRedeemSy, 0, true);\n    }\n\n    function _mintPyFromSy(\n        address receiver,\n        address SY,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut,\n        bool doPull\n    ) internal returns (uint256 netPyOut) {\n        if (doPull) {\n            _transferFrom(IERC20(SY), msg.sender, YT, netSyIn);\n        }\n\n        netPyOut = IPYieldToken(YT).mintPY(receiver, receiver);\n        if (netPyOut < minPyOut) revert("Slippage: INSUFFICIENT_PT_YT_OUT");\n    }\n\n    function _redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) internal returns (uint256 netSyOut) {\n        address PT = IPYieldToken(YT).PT();\n\n        _transferFrom(IERC20(PT), msg.sender, YT, netPyIn);\n\n        bool needToBurnYt = (!IPYieldToken(YT).isExpired());\n        if (needToBurnYt) _transferFrom(IERC20(YT), msg.sender, YT, netPyIn);\n\n        netSyOut = IPYieldToken(YT).redeemPY(receiver);\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    // ----------------- HELPER -----------------\n\n    function _readMarket(address market) internal view returns (MarketState memory) {\n        return IPMarket(market).readState(address(this));\n    }\n\n    // ----------------- PT SWAP -----------------\n\n    function _entry_swapExactPtForSy(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        uint256 netPtLeft = exactPtIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyOut, netSyFee, doMarketOrder) = _fillLimit(receiver, PT, netPtLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(PT), market, netPtLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n                receiver,\n                netPtLeft,\n                EMPTY_BYTES\n            );\n\n            netSyOut += netSyOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netSyOut < minSyOut) revert("Slippage: INSUFFICIENT_SY_OUT");\n    }\n\n    function _entry_swapExactSyForPt(address market, LimitOrderData calldata limit) internal view returns (address) {\n        return !_isEmptyLimit(limit) ? address(this) : market;\n    }\n\n    function _swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netPtOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n        uint256 netSyLeft = exactSyIn;\n        bool doMarketOrder = true;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtOut, netSyFee, doMarketOrder) = _fillLimit(receiver, SY, netSyLeft, limit);\n            if (doMarketOrder) {\n                _transferOut(address(SY), market, netSyLeft);\n            }\n        }\n\n        if (doMarketOrder) {\n            (uint256 netPtOutMarket, ) = _readMarket(market).approxSwapExactSyForPt(\n                YT.newIndex(),\n                netSyLeft,\n                block.timestamp,\n                guessPtOut\n            );\n\n            (, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(receiver, netPtOutMarket, EMPTY_BYTES);\n\n            netPtOut += netPtOutMarket;\n            netSyFee += netSyFeeMarket;\n        }\n\n        if (netPtOut < minPtOut) revert("Slippage: INSUFFICIENT_PT_OUT");\n    }\n\n    // ----------------- LIMIT ORDERS -----------------\n    function _fillLimit(\n        address receiver,\n        IERC20 tokenIn,\n        uint256 netInput,\n        LimitOrderData calldata lim\n    ) internal returns (uint256 netLeft, uint256 netOut, uint256 netSyFee, bool doMarketOrder) {\n        IPLimitRouter router = IPLimitRouter(lim.limitRouter);\n        netLeft = netInput;\n\n        if (lim.normalFills.length != 0) {\n            _safeApproveInf(address(tokenIn), lim.limitRouter);\n            (uint256 actualMaking, uint256 actualTaking, uint256 totalFee, ) = router.fill(\n                lim.normalFills,\n                receiver,\n                netLeft,\n                lim.optData,\n                EMPTY_BYTES\n            );\n            netOut += actualMaking;\n            netLeft -= actualTaking;\n            netSyFee += totalFee;\n        }\n\n        if (lim.flashFills.length != 0) {\n            address YT = lim.flashFills[0].order.YT;\n            OrderType orderType = lim.flashFills[0].order.orderType;\n\n            (, , uint256 totalFee, bytes memory ret) = router.fill(\n                lim.flashFills,\n                YT,\n                type(uint256).max,\n                lim.optData,\n                abi.encode(orderType, YT, netLeft, receiver)\n            );\n            (uint256 netUse, uint256 netReceived) = abi.decode(ret, (uint256, uint256));\n\n            netOut += netReceived;\n            netLeft -= netUse;\n            netSyFee += totalFee;\n        }\n\n        doMarketOrder = netLeft > netInput.mulDown(lim.epsSkipMarket);\n    }\n\n    function _isEmptyLimit(LimitOrderData calldata a) internal pure returns (bool) {\n        return a.normalFills.length == 0 && a.flashFills.length == 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPSwapAggregator.swap', 'start_line': 3548, 'end_line': 3548, 'offset_start': 128824, 'offset_end': 128917, 'content': 'function swap(address tokenIn, uint256 amountIn, SwapData calldata swapData) external payable;', 'contract_name': 'IPSwapAggregator', 'contract_code': '{\n    function swap(address tokenIn, uint256 amountIn, SwapData calldata swapData) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.mintPY', 'start_line': 3576, 'end_line': 3576, 'offset_start': 129805, 'offset_end': 129899, 'content': 'function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.redeemPY', 'start_line': 3578, 'end_line': 3578, 'offset_start': 129906, 'offset_end': 129980, 'content': 'function redeemPY(address receiver) external returns (uint256 amountSyOut);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.redeemPYMulti', 'start_line': 3580, 'end_line': 3583, 'offset_start': 129987, 'offset_end': 130148, 'content': 'function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.redeemDueInterestAndRewards', 'start_line': 3585, 'end_line': 3589, 'offset_start': 130155, 'offset_end': 130344, 'content': 'function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.rewardIndexesCurrent', 'start_line': 3591, 'end_line': 3591, 'offset_start': 130351, 'offset_end': 130418, 'content': 'function rewardIndexesCurrent() external returns (uint256[] memory);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.pyIndexCurrent', 'start_line': 3593, 'end_line': 3593, 'offset_start': 130425, 'offset_end': 130477, 'content': 'function pyIndexCurrent() external returns (uint256);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.pyIndexStored', 'start_line': 3595, 'end_line': 3595, 'offset_start': 130484, 'offset_end': 130540, 'content': 'function pyIndexStored() external view returns (uint256);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.getRewardTokens', 'start_line': 3597, 'end_line': 3597, 'offset_start': 130547, 'offset_end': 130614, 'content': 'function getRewardTokens() external view returns (address[] memory);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.SY', 'start_line': 3599, 'end_line': 3599, 'offset_start': 130621, 'offset_end': 130666, 'content': 'function SY() external view returns (address);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.PT', 'start_line': 3601, 'end_line': 3601, 'offset_start': 130673, 'offset_end': 130718, 'content': 'function PT() external view returns (address);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.factory', 'start_line': 3603, 'end_line': 3603, 'offset_start': 130725, 'offset_end': 130775, 'content': 'function factory() external view returns (address);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.expiry', 'start_line': 3605, 'end_line': 3605, 'offset_start': 130782, 'offset_end': 130831, 'content': 'function expiry() external view returns (uint256);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.isExpired', 'start_line': 3607, 'end_line': 3607, 'offset_start': 130838, 'offset_end': 130887, 'content': 'function isExpired() external view returns (bool);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.doCacheIndexSameBlock', 'start_line': 3609, 'end_line': 3609, 'offset_start': 130894, 'offset_end': 130955, 'content': 'function doCacheIndexSameBlock() external view returns (bool);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPYieldToken.pyIndexLastUpdatedBlock', 'start_line': 3611, 'end_line': 3611, 'offset_start': 130962, 'offset_end': 131028, 'content': 'function pyIndexLastUpdatedBlock() external view returns (uint128);', 'contract_name': 'IPYieldToken', 'contract_code': '{\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(address indexed caller, address indexed receiver, uint256 amountPYToRedeem, uint256 amountSyOut);\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event CollectRewardFee(address indexed rewardToken, uint256 amountRewardFee);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(\n        address[] calldata receivers,\n        uint256[] calldata amountPYToRedeems\n    ) external returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n\n    function pyIndexLastUpdatedBlock() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 3639, 'end_line': 3641, 'offset_start': 131974, 'offset_end': 132148, 'content': 'function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 3647, 'end_line': 3649, 'offset_start': 132388, 'offset_end': 132590, 'content': 'function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeApprove', 'start_line': 3658, 'end_line': 3667, 'offset_start': 132851, 'offset_end': 133423, 'content': 'function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 3673, 'end_line': 3676, 'offset_start': 133615, 'offset_end': 133894, 'content': 'function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 3682, 'end_line': 3688, 'offset_start': 134086, 'offset_end': 134492, 'content': 'function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.forceApprove', 'start_line': 3695, 'end_line': 3702, 'offset_start': 134812, 'offset_end': 135221, 'content': 'function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safePermit', 'start_line': 3708, 'end_line': 3722, 'offset_start': 135374, 'offset_end': 135845, 'content': 'function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 3730, 'end_line': 3737, 'offset_start': 136229, 'offset_end': 136870, 'content': 'function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturnBool', 'start_line': 3747, 'end_line': 3755, 'offset_start': 137372, 'offset_end': 137965, 'content': "function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }", 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.addLiquidity', 'start_line': 3812, 'end_line': 3829, 'offset_start': 139489, 'offset_end': 140103, 'content': 'function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.removeLiquidity', 'start_line': 3831, 'end_line': 3839, 'offset_start': 140110, 'offset_end': 140474, 'content': 'function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.swapExactPtForSy', 'start_line': 3841, 'end_line': 3857, 'offset_start': 140481, 'offset_end': 141064, 'content': 'function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.swapSyForExactPt', 'start_line': 3859, 'end_line': 3875, 'offset_start': 141071, 'offset_end': 141660, 'content': 'function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.addLiquidityCore', 'start_line': 3881, 'end_line': 3923, 'offset_start': 141842, 'offset_end': 143753, 'content': 'function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.removeLiquidityCore', 'start_line': 3925, 'end_line': 3948, 'offset_start': 143760, 'offset_end': 144933, 'content': 'function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.executeTradeCore', 'start_line': 3950, 'end_line': 3974, 'offset_start': 144940, 'offset_end': 146201, 'content': 'function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.getMarketPreCompute', 'start_line': 3976, 'end_line': 3999, 'offset_start': 146208, 'offset_end': 147096, 'content': 'function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.calcTrade', 'start_line': 4001, 'end_line': 4035, 'offset_start': 147103, 'offset_end': 148483, 'content': 'function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore._setNewMarketStateTrade', 'start_line': 4037, 'end_line': 4060, 'offset_start': 148490, 'offset_end': 149280, 'content': 'function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore._getRateAnchor', 'start_line': 4062, 'end_line': 4080, 'offset_start': 149287, 'offset_end': 149942, 'content': 'function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore._getLnImpliedRate', 'start_line': 4084, 'end_line': 4098, 'offset_start': 150056, 'offset_end': 150597, 'content': 'function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore._getExchangeRateFromImpliedRate', 'start_line': 4102, 'end_line': 4109, 'offset_start': 150721, 'offset_end': 151002, 'content': 'function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore._getExchangeRate', 'start_line': 4111, 'end_line': 4130, 'offset_start': 151009, 'offset_end': 151721, 'content': 'function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore._logProportion', 'start_line': 4132, 'end_line': 4138, 'offset_start': 151728, 'offset_end': 151997, 'content': 'function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore._getRateScalar', 'start_line': 4140, 'end_line': 4143, 'offset_start': 152004, 'offset_end': 152296, 'content': 'function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'MarketMathCore.setInitialLnImpliedRate', 'start_line': 4145, 'end_line': 4173, 'offset_start': 152303, 'offset_end': 153441, 'content': 'function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }', 'contract_name': 'MarketMathCore', 'contract_code': '{\n    using PMath for uint256;\n    using PMath for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using PMath for uint256;\n    using PMath for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (uint256 lpToReserve, uint256 lpToAccount, uint256 syUsed, uint256 ptUsed) {\n        (int256 _lpToReserve, int256 _lpToAccount, int256 _syUsed, int256 _ptUsed) = addLiquidityCore(\n            market,\n            syDesired.Int(),\n            ptDesired.Int(),\n            blockTime\n        );\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(\n        MarketState memory market,\n        uint256 lpToRemove\n    ) internal pure returns (uint256 netSyToAccount, uint256 netPtToAccount) {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToAccount, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (uint256 netSyToMarket, uint256 netSyFee, uint256 netSyToReserve) {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    ) internal pure returns (int256 lpToReserve, int256 lpToAccount, int256 syUsed, int256 ptUsed) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = PMath.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(\n        MarketState memory market,\n        int256 lpToRemove\n    ) internal pure returns (int256 netSyToAccount, int256 netPtToAccount) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(market, comp, index, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(market, comp, index, netPtToAccount, netSyToAccount, netSyToReserve, blockTime);\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    ) internal pure returns (int256 netSyToAccount, int256 netSyFee, int256 netSyToReserve) {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(PMath.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (PMath.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < PMath.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(\n        uint256 lnImpliedRate,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 exchangeRate) {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < PMath.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == PMath.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(PMath.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry) internal pure returns (int256 rateScalar) {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPPrincipalToken.burnByYT', 'start_line': 4181, 'end_line': 4181, 'offset_start': 153643, 'offset_end': 153699, 'content': 'function burnByYT(address user, uint256 amount) external;', 'contract_name': 'IPPrincipalToken', 'contract_code': '{\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPPrincipalToken.mintByYT', 'start_line': 4183, 'end_line': 4183, 'offset_start': 153706, 'offset_end': 153762, 'content': 'function mintByYT(address user, uint256 amount) external;', 'contract_name': 'IPPrincipalToken', 'contract_code': '{\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPPrincipalToken.initialize', 'start_line': 4185, 'end_line': 4185, 'offset_start': 153769, 'offset_end': 153810, 'content': 'function initialize(address _YT) external;', 'contract_name': 'IPPrincipalToken', 'contract_code': '{\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPPrincipalToken.SY', 'start_line': 4187, 'end_line': 4187, 'offset_start': 153817, 'offset_end': 153862, 'content': 'function SY() external view returns (address);', 'contract_name': 'IPPrincipalToken', 'contract_code': '{\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPPrincipalToken.YT', 'start_line': 4189, 'end_line': 4189, 'offset_start': 153869, 'offset_end': 153914, 'content': 'function YT() external view returns (address);', 'contract_name': 'IPPrincipalToken', 'contract_code': '{\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPPrincipalToken.factory', 'start_line': 4191, 'end_line': 4191, 'offset_start': 153921, 'offset_end': 153971, 'content': 'function factory() external view returns (address);', 'contract_name': 'IPPrincipalToken', 'contract_code': '{\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPPrincipalToken.expiry', 'start_line': 4193, 'end_line': 4193, 'offset_start': 153978, 'offset_end': 154027, 'content': 'function expiry() external view returns (uint256);', 'contract_name': 'IPPrincipalToken', 'contract_code': '{\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
{'type': 'FunctionDefinition', 'name': 'IPPrincipalToken.isExpired', 'start_line': 4195, 'end_line': 4195, 'offset_start': 154034, 'offset_end': 154083, 'content': 'function isExpired() external view returns (bool);', 'contract_name': 'IPPrincipalToken', 'contract_code': '{\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x888888888889758f76e7103c6cbf23abbf58f946/0x888888888889758f76e7103c6cbf23abbf58f946.sol'}
