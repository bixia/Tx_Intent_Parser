{'type': 'FunctionDefinition', 'name': 'IL1BridgeLegacy.deposit', 'start_line': 9, 'end_line': 15, 'offset_start': 214, 'offset_end': 429, 'content': 'function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);', 'contract_name': 'IL1BridgeLegacy', 'contract_code': '{\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._initializeReentrancyGuard', 'start_line': 63, 'end_line': 76, 'offset_start': 2535, 'offset_end': 3078, 'content': 'function _initializeReentrancyGuard() private {\n        uint256 lockSlotOldValue;\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive but in exchange every call to nonReentrant\n        // will be cheaper.\n        assembly {\n            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n\n        // Check that storage slot for reentrancy guard is empty to rule out possibility of slot conflict\n        require(lockSlotOldValue == 0, "1B");\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    /// @dev Address of lock flag variable.\n    /// @dev Flag is placed at random memory location to not interfere with Storage contract.\n    // keccak256("ReentrancyGuard") - 1;\n    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4;\n\n    // solhint-disable-next-line max-line-length\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/security/ReentrancyGuard.sol\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    modifier reentrancyGuardInitializer() {\n        _initializeReentrancyGuard();\n        _;\n    }\n\n    function _initializeReentrancyGuard() private {\n        uint256 lockSlotOldValue;\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive but in exchange every call to nonReentrant\n        // will be cheaper.\n        assembly {\n            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n\n        // Check that storage slot for reentrancy guard is empty to rule out possibility of slot conflict\n        require(lockSlotOldValue == 0, "1B");\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        uint256 _status;\n        assembly {\n            _status := sload(LOCK_FLAG_ADDRESS)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status == _NOT_ENTERED, "r1");\n\n        // Any calls to nonReentrant after this point will fail\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.proveL2MessageInclusion', 'start_line': 207, 'end_line': 212, 'offset_start': 9856, 'offset_end': 10051, 'content': 'function proveL2MessageInclusion(\n        uint256 _l2BatchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);', 'contract_name': 'IMailbox', 'contract_code': '{\n    /// @dev Structure that includes all fields of the L2 transaction\n    /// @dev The hash of this structure is the "canonical L2 transaction hash" and can be used as a unique identifier of a tx\n    /// @param txType The tx type number, depending on which the L2 transaction can be interpreted differently\n    /// @param from The sender\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param to The recipient\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param gasLimit The L2 gas limit for L2 transaction. Analog to the `gasLimit` on an L1 transactions\n    /// @param gasPerPubdataByteLimit Maximum number of L2 gas that will cost one byte of pubdata (every piece of data that will be stored on L1 as calldata)\n    /// @param maxFeePerGas The absolute maximum sender willing to pay per unit of L2 gas to get the transaction included in a batch. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions\n    /// @param maxPriorityFeePerGas The additional fee that is paid directly to the validator to incentivize them to include the transaction in a batch. Analog to the EIP-1559 `maxPriorityFeePerGas` on an L1 transactions\n    /// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the transaction. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param nonce The nonce of the transaction. For L1->L2 transactions it is the priority operation Id.\n    /// @param value The value to pass with the transaction\n    /// @param reserved The fixed-length fields for usage in a future extension of transaction formats\n    /// @param data The calldata that is transmitted for the transaction call\n    /// @param signature An abstract set of bytes that are used for transaction authorization\n    /// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1\n    /// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call\n    /// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats\n    struct L2CanonicalTransaction {\n        uint256 txType;\n        uint256 from;\n        uint256 to;\n        uint256 gasLimit;\n        uint256 gasPerPubdataByteLimit;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        uint256 paymaster;\n        uint256 nonce;\n        uint256 value;\n        // In the future, we might want to add some\n        // new fields to the struct. The `txData` struct\n        // is to be passed to account and any changes to its structure\n        // would mean a breaking change to these accounts. To prevent this,\n        // we should keep some fields as "reserved".\n        // It is also recommended that their length is fixed, since\n        // it would allow easier proof integration (in case we will need\n        // some special circuit for preprocessing transactions).\n        uint256[4] reserved;\n        bytes data;\n        bytes signature;\n        uint256[] factoryDeps;\n        bytes paymasterInput;\n        // Reserved dynamic type for the future use-case. Using it should be avoided,\n        // But it is still here, just in case we want to enable some additional functionality.\n        bytes reservedDynamic;\n    }\n\n    /// @dev Internal structure that contains the parameters for the forwardRequestL2Transaction\n    /// @param gateway The secondary chain gateway;\n    /// @param isContractCall It\'s true when the request come from a contract.\n    /// @param sender The sender\'s address.\n    /// @param txId The id of the priority transaction.\n    /// @param contractAddressL2 The address of the contract on L2 to call.\n    /// @param l2Value The msg.value of the L2 transaction.\n    /// @param l2CallData The call data of the L2 transaction.\n    /// @param l2GasLimit The limit of the L2 gas for the L2 transaction\n    /// @param l2GasPrice The price of the L2 gas in Wei to be used for this transaction.\n    /// @param l2GasPricePerPubdata The price for a single pubdata byte in L2 gas.\n    /// @param refundRecipient The recipient of the refund for the transaction on L2. If the transaction fails, then\n    /// this address will receive the `l2Value`.\n    struct ForwardL2Request {\n        address gateway;\n        bool isContractCall;\n        address sender;\n        uint256 txId;\n        address contractAddressL2;\n        uint256 l2Value;\n        bytes l2CallData;\n        uint256 l2GasLimit;\n        uint256 l2GasPricePerPubdata;\n        bytes[] factoryDeps;\n        address refundRecipient;\n    }\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _l2BatchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _l2BatchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn\'t mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.proveL1ToL2TransactionStatus', 'start_line': 223, 'end_line': 230, 'offset_start': 10934, 'offset_end': 11200, 'content': 'function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);', 'contract_name': 'IMailbox', 'contract_code': '{\n    /// @dev Structure that includes all fields of the L2 transaction\n    /// @dev The hash of this structure is the "canonical L2 transaction hash" and can be used as a unique identifier of a tx\n    /// @param txType The tx type number, depending on which the L2 transaction can be interpreted differently\n    /// @param from The sender\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param to The recipient\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param gasLimit The L2 gas limit for L2 transaction. Analog to the `gasLimit` on an L1 transactions\n    /// @param gasPerPubdataByteLimit Maximum number of L2 gas that will cost one byte of pubdata (every piece of data that will be stored on L1 as calldata)\n    /// @param maxFeePerGas The absolute maximum sender willing to pay per unit of L2 gas to get the transaction included in a batch. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions\n    /// @param maxPriorityFeePerGas The additional fee that is paid directly to the validator to incentivize them to include the transaction in a batch. Analog to the EIP-1559 `maxPriorityFeePerGas` on an L1 transactions\n    /// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the transaction. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param nonce The nonce of the transaction. For L1->L2 transactions it is the priority operation Id.\n    /// @param value The value to pass with the transaction\n    /// @param reserved The fixed-length fields for usage in a future extension of transaction formats\n    /// @param data The calldata that is transmitted for the transaction call\n    /// @param signature An abstract set of bytes that are used for transaction authorization\n    /// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1\n    /// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call\n    /// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats\n    struct L2CanonicalTransaction {\n        uint256 txType;\n        uint256 from;\n        uint256 to;\n        uint256 gasLimit;\n        uint256 gasPerPubdataByteLimit;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        uint256 paymaster;\n        uint256 nonce;\n        uint256 value;\n        // In the future, we might want to add some\n        // new fields to the struct. The `txData` struct\n        // is to be passed to account and any changes to its structure\n        // would mean a breaking change to these accounts. To prevent this,\n        // we should keep some fields as "reserved".\n        // It is also recommended that their length is fixed, since\n        // it would allow easier proof integration (in case we will need\n        // some special circuit for preprocessing transactions).\n        uint256[4] reserved;\n        bytes data;\n        bytes signature;\n        uint256[] factoryDeps;\n        bytes paymasterInput;\n        // Reserved dynamic type for the future use-case. Using it should be avoided,\n        // But it is still here, just in case we want to enable some additional functionality.\n        bytes reservedDynamic;\n    }\n\n    /// @dev Internal structure that contains the parameters for the forwardRequestL2Transaction\n    /// @param gateway The secondary chain gateway;\n    /// @param isContractCall It\'s true when the request come from a contract.\n    /// @param sender The sender\'s address.\n    /// @param txId The id of the priority transaction.\n    /// @param contractAddressL2 The address of the contract on L2 to call.\n    /// @param l2Value The msg.value of the L2 transaction.\n    /// @param l2CallData The call data of the L2 transaction.\n    /// @param l2GasLimit The limit of the L2 gas for the L2 transaction\n    /// @param l2GasPrice The price of the L2 gas in Wei to be used for this transaction.\n    /// @param l2GasPricePerPubdata The price for a single pubdata byte in L2 gas.\n    /// @param refundRecipient The recipient of the refund for the transaction on L2. If the transaction fails, then\n    /// this address will receive the `l2Value`.\n    struct ForwardL2Request {\n        address gateway;\n        bool isContractCall;\n        address sender;\n        uint256 txId;\n        address contractAddressL2;\n        uint256 l2Value;\n        bytes l2CallData;\n        uint256 l2GasLimit;\n        uint256 l2GasPricePerPubdata;\n        bytes[] factoryDeps;\n        address refundRecipient;\n    }\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _l2BatchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _l2BatchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn\'t mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.requestL2Transaction', 'start_line': 250, 'end_line': 258, 'offset_start': 13131, 'offset_end': 13451, 'content': 'function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);', 'contract_name': 'IMailbox', 'contract_code': '{\n    /// @dev Structure that includes all fields of the L2 transaction\n    /// @dev The hash of this structure is the "canonical L2 transaction hash" and can be used as a unique identifier of a tx\n    /// @param txType The tx type number, depending on which the L2 transaction can be interpreted differently\n    /// @param from The sender\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param to The recipient\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param gasLimit The L2 gas limit for L2 transaction. Analog to the `gasLimit` on an L1 transactions\n    /// @param gasPerPubdataByteLimit Maximum number of L2 gas that will cost one byte of pubdata (every piece of data that will be stored on L1 as calldata)\n    /// @param maxFeePerGas The absolute maximum sender willing to pay per unit of L2 gas to get the transaction included in a batch. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions\n    /// @param maxPriorityFeePerGas The additional fee that is paid directly to the validator to incentivize them to include the transaction in a batch. Analog to the EIP-1559 `maxPriorityFeePerGas` on an L1 transactions\n    /// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the transaction. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param nonce The nonce of the transaction. For L1->L2 transactions it is the priority operation Id.\n    /// @param value The value to pass with the transaction\n    /// @param reserved The fixed-length fields for usage in a future extension of transaction formats\n    /// @param data The calldata that is transmitted for the transaction call\n    /// @param signature An abstract set of bytes that are used for transaction authorization\n    /// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1\n    /// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call\n    /// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats\n    struct L2CanonicalTransaction {\n        uint256 txType;\n        uint256 from;\n        uint256 to;\n        uint256 gasLimit;\n        uint256 gasPerPubdataByteLimit;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        uint256 paymaster;\n        uint256 nonce;\n        uint256 value;\n        // In the future, we might want to add some\n        // new fields to the struct. The `txData` struct\n        // is to be passed to account and any changes to its structure\n        // would mean a breaking change to these accounts. To prevent this,\n        // we should keep some fields as "reserved".\n        // It is also recommended that their length is fixed, since\n        // it would allow easier proof integration (in case we will need\n        // some special circuit for preprocessing transactions).\n        uint256[4] reserved;\n        bytes data;\n        bytes signature;\n        uint256[] factoryDeps;\n        bytes paymasterInput;\n        // Reserved dynamic type for the future use-case. Using it should be avoided,\n        // But it is still here, just in case we want to enable some additional functionality.\n        bytes reservedDynamic;\n    }\n\n    /// @dev Internal structure that contains the parameters for the forwardRequestL2Transaction\n    /// @param gateway The secondary chain gateway;\n    /// @param isContractCall It\'s true when the request come from a contract.\n    /// @param sender The sender\'s address.\n    /// @param txId The id of the priority transaction.\n    /// @param contractAddressL2 The address of the contract on L2 to call.\n    /// @param l2Value The msg.value of the L2 transaction.\n    /// @param l2CallData The call data of the L2 transaction.\n    /// @param l2GasLimit The limit of the L2 gas for the L2 transaction\n    /// @param l2GasPrice The price of the L2 gas in Wei to be used for this transaction.\n    /// @param l2GasPricePerPubdata The price for a single pubdata byte in L2 gas.\n    /// @param refundRecipient The recipient of the refund for the transaction on L2. If the transaction fails, then\n    /// this address will receive the `l2Value`.\n    struct ForwardL2Request {\n        address gateway;\n        bool isContractCall;\n        address sender;\n        uint256 txId;\n        address contractAddressL2;\n        uint256 l2Value;\n        bytes l2CallData;\n        uint256 l2GasLimit;\n        uint256 l2GasPricePerPubdata;\n        bytes[] factoryDeps;\n        address refundRecipient;\n    }\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _l2BatchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _l2BatchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn\'t mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.finalizeEthWithdrawal', 'start_line': 266, 'end_line': 272, 'offset_start': 14001, 'offset_end': 14220, 'content': 'function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;', 'contract_name': 'IMailbox', 'contract_code': '{\n    /// @dev Structure that includes all fields of the L2 transaction\n    /// @dev The hash of this structure is the "canonical L2 transaction hash" and can be used as a unique identifier of a tx\n    /// @param txType The tx type number, depending on which the L2 transaction can be interpreted differently\n    /// @param from The sender\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param to The recipient\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param gasLimit The L2 gas limit for L2 transaction. Analog to the `gasLimit` on an L1 transactions\n    /// @param gasPerPubdataByteLimit Maximum number of L2 gas that will cost one byte of pubdata (every piece of data that will be stored on L1 as calldata)\n    /// @param maxFeePerGas The absolute maximum sender willing to pay per unit of L2 gas to get the transaction included in a batch. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions\n    /// @param maxPriorityFeePerGas The additional fee that is paid directly to the validator to incentivize them to include the transaction in a batch. Analog to the EIP-1559 `maxPriorityFeePerGas` on an L1 transactions\n    /// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the transaction. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param nonce The nonce of the transaction. For L1->L2 transactions it is the priority operation Id.\n    /// @param value The value to pass with the transaction\n    /// @param reserved The fixed-length fields for usage in a future extension of transaction formats\n    /// @param data The calldata that is transmitted for the transaction call\n    /// @param signature An abstract set of bytes that are used for transaction authorization\n    /// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1\n    /// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call\n    /// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats\n    struct L2CanonicalTransaction {\n        uint256 txType;\n        uint256 from;\n        uint256 to;\n        uint256 gasLimit;\n        uint256 gasPerPubdataByteLimit;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        uint256 paymaster;\n        uint256 nonce;\n        uint256 value;\n        // In the future, we might want to add some\n        // new fields to the struct. The `txData` struct\n        // is to be passed to account and any changes to its structure\n        // would mean a breaking change to these accounts. To prevent this,\n        // we should keep some fields as "reserved".\n        // It is also recommended that their length is fixed, since\n        // it would allow easier proof integration (in case we will need\n        // some special circuit for preprocessing transactions).\n        uint256[4] reserved;\n        bytes data;\n        bytes signature;\n        uint256[] factoryDeps;\n        bytes paymasterInput;\n        // Reserved dynamic type for the future use-case. Using it should be avoided,\n        // But it is still here, just in case we want to enable some additional functionality.\n        bytes reservedDynamic;\n    }\n\n    /// @dev Internal structure that contains the parameters for the forwardRequestL2Transaction\n    /// @param gateway The secondary chain gateway;\n    /// @param isContractCall It\'s true when the request come from a contract.\n    /// @param sender The sender\'s address.\n    /// @param txId The id of the priority transaction.\n    /// @param contractAddressL2 The address of the contract on L2 to call.\n    /// @param l2Value The msg.value of the L2 transaction.\n    /// @param l2CallData The call data of the L2 transaction.\n    /// @param l2GasLimit The limit of the L2 gas for the L2 transaction\n    /// @param l2GasPrice The price of the L2 gas in Wei to be used for this transaction.\n    /// @param l2GasPricePerPubdata The price for a single pubdata byte in L2 gas.\n    /// @param refundRecipient The recipient of the refund for the transaction on L2. If the transaction fails, then\n    /// this address will receive the `l2Value`.\n    struct ForwardL2Request {\n        address gateway;\n        bool isContractCall;\n        address sender;\n        uint256 txId;\n        address contractAddressL2;\n        uint256 l2Value;\n        bytes l2CallData;\n        uint256 l2GasLimit;\n        uint256 l2GasPricePerPubdata;\n        bytes[] factoryDeps;\n        address refundRecipient;\n    }\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _l2BatchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _l2BatchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn\'t mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.l2TransactionBaseCost', 'start_line': 279, 'end_line': 283, 'offset_start': 14736, 'offset_end': 14903, 'content': 'function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);', 'contract_name': 'IMailbox', 'contract_code': '{\n    /// @dev Structure that includes all fields of the L2 transaction\n    /// @dev The hash of this structure is the "canonical L2 transaction hash" and can be used as a unique identifier of a tx\n    /// @param txType The tx type number, depending on which the L2 transaction can be interpreted differently\n    /// @param from The sender\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param to The recipient\'s address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param gasLimit The L2 gas limit for L2 transaction. Analog to the `gasLimit` on an L1 transactions\n    /// @param gasPerPubdataByteLimit Maximum number of L2 gas that will cost one byte of pubdata (every piece of data that will be stored on L1 as calldata)\n    /// @param maxFeePerGas The absolute maximum sender willing to pay per unit of L2 gas to get the transaction included in a batch. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions\n    /// @param maxPriorityFeePerGas The additional fee that is paid directly to the validator to incentivize them to include the transaction in a batch. Analog to the EIP-1559 `maxPriorityFeePerGas` on an L1 transactions\n    /// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the transaction. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param nonce The nonce of the transaction. For L1->L2 transactions it is the priority operation Id.\n    /// @param value The value to pass with the transaction\n    /// @param reserved The fixed-length fields for usage in a future extension of transaction formats\n    /// @param data The calldata that is transmitted for the transaction call\n    /// @param signature An abstract set of bytes that are used for transaction authorization\n    /// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1\n    /// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call\n    /// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats\n    struct L2CanonicalTransaction {\n        uint256 txType;\n        uint256 from;\n        uint256 to;\n        uint256 gasLimit;\n        uint256 gasPerPubdataByteLimit;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        uint256 paymaster;\n        uint256 nonce;\n        uint256 value;\n        // In the future, we might want to add some\n        // new fields to the struct. The `txData` struct\n        // is to be passed to account and any changes to its structure\n        // would mean a breaking change to these accounts. To prevent this,\n        // we should keep some fields as "reserved".\n        // It is also recommended that their length is fixed, since\n        // it would allow easier proof integration (in case we will need\n        // some special circuit for preprocessing transactions).\n        uint256[4] reserved;\n        bytes data;\n        bytes signature;\n        uint256[] factoryDeps;\n        bytes paymasterInput;\n        // Reserved dynamic type for the future use-case. Using it should be avoided,\n        // But it is still here, just in case we want to enable some additional functionality.\n        bytes reservedDynamic;\n    }\n\n    /// @dev Internal structure that contains the parameters for the forwardRequestL2Transaction\n    /// @param gateway The secondary chain gateway;\n    /// @param isContractCall It\'s true when the request come from a contract.\n    /// @param sender The sender\'s address.\n    /// @param txId The id of the priority transaction.\n    /// @param contractAddressL2 The address of the contract on L2 to call.\n    /// @param l2Value The msg.value of the L2 transaction.\n    /// @param l2CallData The call data of the L2 transaction.\n    /// @param l2GasLimit The limit of the L2 gas for the L2 transaction\n    /// @param l2GasPrice The price of the L2 gas in Wei to be used for this transaction.\n    /// @param l2GasPricePerPubdata The price for a single pubdata byte in L2 gas.\n    /// @param refundRecipient The recipient of the refund for the transaction on L2. If the transaction fails, then\n    /// this address will receive the `l2Value`.\n    struct ForwardL2Request {\n        address gateway;\n        bool isContractCall;\n        address sender;\n        uint256 txId;\n        address contractAddressL2;\n        uint256 l2Value;\n        bytes l2CallData;\n        uint256 l2GasLimit;\n        uint256 l2GasPricePerPubdata;\n        bytes[] factoryDeps;\n        address refundRecipient;\n    }\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _l2BatchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _l2BatchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn\'t mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.isContract', 'start_line': 325, 'end_line': 331, 'offset_start': 16320, 'offset_end': 16639, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 349, 'end_line': 354, 'offset_start': 17555, 'offset_end': 17866, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 374, 'end_line': 376, 'offset_start': 18609, 'offset_end': 18793, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 384, 'end_line': 390, 'offset_start': 19016, 'offset_end': 19238, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 403, 'end_line': 405, 'offset_start': 19601, 'offset_end': 19824, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 413, 'end_line': 422, 'offset_start': 20073, 'offset_end': 20518, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 430, 'end_line': 432, 'offset_start': 20696, 'offset_end': 20892, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 440, 'end_line': 447, 'offset_start': 21077, 'offset_end': 21402, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 455, 'end_line': 457, 'offset_start': 21582, 'offset_end': 21779, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 465, 'end_line': 472, 'offset_start': 21966, 'offset_end': 22290, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 480, 'end_line': 496, 'offset_start': 22579, 'offset_end': 23206, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 504, 'end_line': 514, 'offset_start': 23428, 'offset_end': 23722, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 516, 'end_line': 528, 'offset_start': 23729, 'offset_end': 24268, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2ERC20Bridge.initialize', 'start_line': 537, 'end_line': 537, 'offset_start': 24386, 'offset_end': 24487, 'content': 'function initialize(address _l1Bridge, bytes32 _l2TokenProxyBytecodeHash, address _governor) external;', 'contract_name': 'IL2ERC20Bridge', 'contract_code': '{\n    function initialize(address _l1Bridge, bytes32 _l2TokenProxyBytecodeHash, address _governor) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2Bridge.finalizeDeposit', 'start_line': 546, 'end_line': 552, 'offset_start': 24600, 'offset_end': 24784, 'content': 'function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;', 'contract_name': 'IL2Bridge', 'contract_code': '{\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function finalizeDepositToMerge(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external;\n\n    function l1TokenAddress(address _l2Token) external view returns (address);\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l1Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2Bridge.finalizeDepositToMerge', 'start_line': 554, 'end_line': 560, 'offset_start': 24791, 'offset_end': 24982, 'content': 'function finalizeDepositToMerge(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;', 'contract_name': 'IL2Bridge', 'contract_code': '{\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function finalizeDepositToMerge(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external;\n\n    function l1TokenAddress(address _l2Token) external view returns (address);\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l1Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2Bridge.withdraw', 'start_line': 562, 'end_line': 562, 'offset_start': 24989, 'offset_end': 25071, 'content': 'function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external;', 'contract_name': 'IL2Bridge', 'contract_code': '{\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function finalizeDepositToMerge(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external;\n\n    function l1TokenAddress(address _l2Token) external view returns (address);\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l1Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2Bridge.l1TokenAddress', 'start_line': 564, 'end_line': 564, 'offset_start': 25078, 'offset_end': 25151, 'content': 'function l1TokenAddress(address _l2Token) external view returns (address);', 'contract_name': 'IL2Bridge', 'contract_code': '{\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function finalizeDepositToMerge(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external;\n\n    function l1TokenAddress(address _l2Token) external view returns (address);\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l1Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2Bridge.l2TokenAddress', 'start_line': 566, 'end_line': 566, 'offset_start': 25158, 'offset_end': 25231, 'content': 'function l2TokenAddress(address _l1Token) external view returns (address);', 'contract_name': 'IL2Bridge', 'contract_code': '{\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function finalizeDepositToMerge(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external;\n\n    function l1TokenAddress(address _l2Token) external view returns (address);\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l1Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2Bridge.l1Bridge', 'start_line': 568, 'end_line': 568, 'offset_start': 25238, 'offset_end': 25289, 'content': 'function l1Bridge() external view returns (address);', 'contract_name': 'IL2Bridge', 'contract_code': '{\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function finalizeDepositToMerge(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external;\n\n    function l1TokenAddress(address _l2Token) external view returns (address);\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l1Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 596, 'end_line': 598, 'offset_start': 26235, 'offset_end': 26409, 'content': 'function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 604, 'end_line': 606, 'offset_start': 26649, 'offset_end': 26851, 'content': 'function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeApprove', 'start_line': 615, 'end_line': 624, 'offset_start': 27112, 'offset_end': 27684, 'content': 'function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 630, 'end_line': 633, 'offset_start': 27876, 'offset_end': 28155, 'content': 'function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 639, 'end_line': 645, 'offset_start': 28347, 'offset_end': 28753, 'content': 'function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.forceApprove', 'start_line': 652, 'end_line': 659, 'offset_start': 29073, 'offset_end': 29482, 'content': 'function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safePermit', 'start_line': 665, 'end_line': 679, 'offset_start': 29635, 'offset_end': 30106, 'content': 'function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 687, 'end_line': 694, 'offset_start': 30490, 'offset_end': 31131, 'content': 'function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturnBool', 'start_line': 704, 'end_line': 712, 'offset_start': 31633, 'offset_end': 32226, 'content': "function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }", 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge.tor', 'start_line': 778, 'end_line': 780, 'offset_start': 35397, 'offset_end': 35486, 'content': 'constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge.initialize', 'start_line': 796, 'end_line': 855, 'offset_start': 36818, 'offset_end': 39447, 'content': 'function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge.deposit', 'start_line': 869, 'end_line': 877, 'offset_start': 40544, 'offset_end': 40879, 'content': 'function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge.deposit', 'start_line': 903, 'end_line': 920, 'offset_start': 43070, 'offset_end': 43558, 'content': 'function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge.depositToMerge', 'start_line': 946, 'end_line': 963, 'offset_start': 45778, 'offset_end': 46274, 'content': 'function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge._deposit', 'start_line': 965, 'end_line': 1003, 'offset_start': 46281, 'offset_end': 48058, 'content': 'function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge._depositFunds', 'start_line': 1007, 'end_line': 1013, 'offset_start': 48255, 'offset_end': 48597, 'content': 'function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge._getDepositL2Calldata', 'start_line': 1016, 'end_line': 1035, 'offset_start': 48700, 'offset_end': 49386, 'content': 'function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge._getERC20Getters', 'start_line': 1038, 'end_line': 1043, 'offset_start': 49475, 'offset_end': 49898, 'content': 'function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge.claimFailedDeposit', 'start_line': 1053, 'end_line': 1080, 'offset_start': 50632, 'offset_end': 51536, 'content': 'function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge.finalizeWithdrawal', 'start_line': 1088, 'end_line': 1115, 'offset_start': 52088, 'offset_end': 53132, 'content': 'function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge._parseL2WithdrawalMessage', 'start_line': 1118, 'end_line': 1132, 'offset_start': 53198, 'offset_end': 54024, 'content': 'function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L1ERC20Bridge.l2TokenAddress', 'start_line': 1135, 'end_line': 1140, 'offset_start': 54123, 'offset_end': 54462, 'content': 'function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }', 'contract_name': 'L1ERC20Bridge', 'contract_code': '{\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _factoryDepByteCodeHashes A list of raw bytecode sha256 hashes that are needed for deployment of the L2 bridge\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        bytes32[] calldata _factoryDepByteCodeHashes,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), "nf");\n        require(_governor != address(0), "nh");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, "mk");\n        require(_factoryDeps.length == _factoryDepByteCodeHashes.length, "mg");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, "fee");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[2].length,\n            _factoryDepByteCodeHashes[2]\n        );\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[0].length,\n            _factoryDepByteCodeHashes[0]\n        );\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(\n            _factoryDeps[1].length,\n            _factoryDepByteCodeHashes[1]\n        );\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            "", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for the L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn\'t use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            false\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where merge tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token and merge token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens\' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient\'s address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of depositToMerge finalization\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant returns (bytes32 l2TxHash) {\n        l2TxHash = _deposit(\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient,\n            true\n        );\n    }\n\n    function _deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient,\n        bool _toMerge\n    ) internal returns (bytes32 l2TxHash) {\n        require(_amount != 0, "2T"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, "1T"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n        if (_toMerge) {\n            emit DepositToMergeInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount, _toMerge);\n        } else {\n            emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n        }\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bool _toMerge\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        if (_toMerge) {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDepositToMerge,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        } else {\n            txCalldata = abi.encodeCall(\n                IL2Bridge.finalizeDeposit,\n                (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n            );\n        }\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, "yn");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, "y1");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], "pw");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, "nq");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, "kk");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, "nt");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, ""));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L2ContractHelper.hashL2Bytecode', 'start_line': 1164, 'end_line': 1179, 'offset_start': 55331, 'offset_end': 56196, 'content': 'function hashL2Bytecode(\n        uint256 _bytecodeLength,\n        bytes32 _bytecodeHash\n    ) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecodeLength % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecodeLength / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = _bytecodeHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }', 'contract_name': 'L2ContractHelper', 'contract_code': '{\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256("zksyncCreate2");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecodeLength The bytecode length.\n    /// @param _bytecodeHash The bytecode hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(\n        uint256 _bytecodeLength,\n        bytes32 _bytecodeHash\n    ) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecodeLength % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecodeLength / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = _bytecodeHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash formam.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(_bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L2ContractHelper.validateBytecodeHash', 'start_line': 1185, 'end_line': 1190, 'offset_start': 56516, 'offset_end': 56844, 'content': 'function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(_bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }', 'contract_name': 'L2ContractHelper', 'contract_code': '{\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256("zksyncCreate2");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecodeLength The bytecode length.\n    /// @param _bytecodeHash The bytecode hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(\n        uint256 _bytecodeLength,\n        bytes32 _bytecodeHash\n    ) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecodeLength % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecodeLength / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = _bytecodeHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash formam.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(_bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L2ContractHelper._bytecodeLen', 'start_line': 1195, 'end_line': 1197, 'offset_start': 57060, 'offset_end': 57263, 'content': 'function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }', 'contract_name': 'L2ContractHelper', 'contract_code': '{\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256("zksyncCreate2");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecodeLength The bytecode length.\n    /// @param _bytecodeHash The bytecode hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(\n        uint256 _bytecodeLength,\n        bytes32 _bytecodeHash\n    ) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecodeLength % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecodeLength / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = _bytecodeHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash formam.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(_bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'L2ContractHelper.computeCreate2Address', 'start_line': 1206, 'end_line': 1218, 'offset_start': 57724, 'offset_end': 58176, 'content': 'function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }', 'contract_name': 'L2ContractHelper', 'contract_code': '{\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256("zksyncCreate2");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecodeLength The bytecode length.\n    /// @param _bytecodeHash The bytecode hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(\n        uint256 _bytecodeLength,\n        bytes32 _bytecodeHash\n    ) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecodeLength % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecodeLength / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = _bytecodeHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash formam.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(_bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2ContractDeployer.forceDeployOnAddresses', 'start_line': 1245, 'end_line': 1245, 'offset_start': 59108, 'offset_end': 59190, 'content': 'function forceDeployOnAddresses(ForceDeployment[] calldata _deployParams) external;', 'contract_name': 'IL2ContractDeployer', 'contract_code': "{\n    /// @notice A struct that describes a forced deployment on an address.\n    /// @param bytecodeHash The bytecode hash to put on an address.\n    /// @param newAddress The address on which to deploy the bytecodehash to.\n    /// @param callConstructor Whether to run the constructor on the force deployment.\n    /// @param value The `msg.value` with which to initialize a contract.\n    /// @param input The constructor calldata.\n    struct ForceDeployment {\n        bytes32 bytecodeHash;\n        address newAddress;\n        bool callConstructor;\n        uint256 value;\n        bytes input;\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployParams) external;\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The create2 salt.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    function create2(bytes32 _salt, bytes32 _bytecodeHash, bytes calldata _input) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL2ContractDeployer.create2', 'start_line': 1251, 'end_line': 1251, 'offset_start': 59463, 'offset_end': 59549, 'content': 'function create2(bytes32 _salt, bytes32 _bytecodeHash, bytes calldata _input) external;', 'contract_name': 'IL2ContractDeployer', 'contract_code': "{\n    /// @notice A struct that describes a forced deployment on an address.\n    /// @param bytecodeHash The bytecode hash to put on an address.\n    /// @param newAddress The address on which to deploy the bytecodehash to.\n    /// @param callConstructor Whether to run the constructor on the force deployment.\n    /// @param value The `msg.value` with which to initialize a contract.\n    /// @param input The constructor calldata.\n    struct ForceDeployment {\n        bytes32 bytecodeHash;\n        address newAddress;\n        bool callConstructor;\n        uint256 value;\n        bytes input;\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployParams) external;\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The create2 salt.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    function create2(bytes32 _salt, bytes32 _bytecodeHash, bytes calldata _input) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 1280, 'end_line': 1280, 'offset_start': 60328, 'offset_end': 60382, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 1285, 'end_line': 1285, 'offset_start': 60466, 'offset_end': 60533, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 1294, 'end_line': 1294, 'offset_start': 60747, 'offset_end': 60816, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 1303, 'end_line': 1303, 'offset_start': 61092, 'offset_end': 61174, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 1319, 'end_line': 1319, 'offset_start': 61828, 'offset_end': 61901, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 1330, 'end_line': 1330, 'offset_start': 62200, 'offset_end': 62287, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1Bridge.isWithdrawalFinalized', 'start_line': 1429, 'end_line': 1429, 'offset_start': 65955, 'offset_end': 66063, 'content': 'function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);', 'contract_name': 'IL1Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event DepositToMergeInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount,\n        bool toMerge\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l2Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1Bridge.deposit', 'start_line': 1431, 'end_line': 1438, 'offset_start': 66070, 'offset_end': 66319, 'content': 'function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);', 'contract_name': 'IL1Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event DepositToMergeInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount,\n        bool toMerge\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l2Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1Bridge.depositToMerge', 'start_line': 1440, 'end_line': 1447, 'offset_start': 66326, 'offset_end': 66582, 'content': 'function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);', 'contract_name': 'IL1Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event DepositToMergeInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount,\n        bool toMerge\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l2Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1Bridge.claimFailedDeposit', 'start_line': 1449, 'end_line': 1457, 'offset_start': 66589, 'offset_end': 66857, 'content': 'function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;', 'contract_name': 'IL1Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event DepositToMergeInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount,\n        bool toMerge\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l2Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1Bridge.finalizeWithdrawal', 'start_line': 1459, 'end_line': 1465, 'offset_start': 66864, 'offset_end': 67080, 'content': 'function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;', 'contract_name': 'IL1Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event DepositToMergeInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount,\n        bool toMerge\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l2Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1Bridge.l2TokenAddress', 'start_line': 1467, 'end_line': 1467, 'offset_start': 67087, 'offset_end': 67160, 'content': 'function l2TokenAddress(address _l1Token) external view returns (address);', 'contract_name': 'IL1Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event DepositToMergeInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount,\n        bool toMerge\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l2Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1Bridge.l2Bridge', 'start_line': 1469, 'end_line': 1469, 'offset_start': 67167, 'offset_end': 67218, 'content': 'function l2Bridge() external view returns (address);', 'contract_name': 'IL1Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event DepositToMergeInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount,\n        bool toMerge\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function depositToMerge(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function l2Bridge() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'BridgeInitializationHelper.requestDeployTransaction', 'start_line': 1501, 'end_line': 1529, 'offset_start': 68831, 'offset_end': 69919, 'content': 'function requestDeployTransaction(\n        IMailbox _zkSync,\n        uint256 _deployTransactionFee,\n        bytes32 _bytecodeHash,\n        bytes memory _constructorData,\n        bytes[] memory _factoryDeps\n    ) internal returns (address deployedAddress) {\n        bytes memory deployCalldata = abi.encodeCall(\n            IL2ContractDeployer.create2,\n            (bytes32(0), _bytecodeHash, _constructorData)\n        );\n        _zkSync.requestL2Transaction{value: _deployTransactionFee}(\n            L2_DEPLOYER_SYSTEM_CONTRACT_ADDR,\n            0,\n            deployCalldata,\n            DEPLOY_L2_BRIDGE_COUNTERPART_GAS_LIMIT,\n            REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            _factoryDeps,\n            msg.sender\n        );\n\n        deployedAddress = L2ContractHelper.computeCreate2Address(\n            // Apply the alias to the address of the bridge contract, to get the `msg.sender` in L2.\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            bytes32(0), // Zero salt\n            _bytecodeHash,\n            keccak256(_constructorData)\n        );\n    }', 'contract_name': 'BridgeInitializationHelper', 'contract_code': '{\n    /// @dev The L2 gas limit for requesting L1 -> L2 transaction of deploying L2 bridge instance.\n    /// @dev It is big enough to deploy any contract, so we can use the same value for all bridges.\n    /// NOTE: this constant will be accurately calculated in the future.\n    uint256 constant DEPLOY_L2_BRIDGE_COUNTERPART_GAS_LIMIT = 10000000;\n\n    /// @dev The default l2GasPricePerPubdata to be used in bridges.\n    uint256 constant REQUIRED_L2_GAS_PRICE_PER_PUBDATA = 800;\n\n    /// @notice Requests L2 transaction that will deploy a contract with a given bytecode hash and constructor data.\n    /// NOTE: it is always used to deploy via create2 with ZERO salt\n    /// @param _zkSync The address of the zkSync contract\n    /// @param _deployTransactionFee The fee that will be paid for the L1 -> L2 transaction\n    /// @param _bytecodeHash The hash of the bytecode of the contract to be deployed\n    /// @param _constructorData The data to be passed to the contract constructor\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment\n    function requestDeployTransaction(\n        IMailbox _zkSync,\n        uint256 _deployTransactionFee,\n        bytes32 _bytecodeHash,\n        bytes memory _constructorData,\n        bytes[] memory _factoryDeps\n    ) internal returns (address deployedAddress) {\n        bytes memory deployCalldata = abi.encodeCall(\n            IL2ContractDeployer.create2,\n            (bytes32(0), _bytecodeHash, _constructorData)\n        );\n        _zkSync.requestL2Transaction{value: _deployTransactionFee}(\n            L2_DEPLOYER_SYSTEM_CONTRACT_ADDR,\n            0,\n            deployCalldata,\n            DEPLOY_L2_BRIDGE_COUNTERPART_GAS_LIMIT,\n            REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            _factoryDeps,\n            msg.sender\n        );\n\n        deployedAddress = L2ContractHelper.computeCreate2Address(\n            // Apply the alias to the address of the bridge contract, to get the `msg.sender` in L2.\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            bytes32(0), // Zero salt\n            _bytecodeHash,\n            keccak256(_constructorData)\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'UnsafeBytes.readUint32', 'start_line': 1550, 'end_line': 1555, 'offset_start': 70727, 'offset_end': 70959, 'content': 'function readUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 4)\n            result := mload(add(_bytes, offset))\n        }\n    }', 'contract_name': 'UnsafeBytes', 'contract_code': '{\n    function readUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 4)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readAddress(bytes memory _bytes, uint256 _start) internal pure returns (address result, uint256 offset) {\n        assembly {\n            offset := add(_start, 20)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\n    // Get slice from bytes arrays\n    // Returns the newly created \'bytes memory\'\n    // NOTE: theoretically possible overflow of (_start + _length)\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_bytes.length >= (_start + _length), "Z"); // bytes length is less then start byte + length bytes\n\n        bytes memory tempBytes = new bytes(_length);\n\n        if (_length != 0) {\n            assembly {\n                let slice_curr := add(tempBytes, 0x20)\n                let slice_end := add(slice_curr, _length)\n\n                for {\n                    let array_current := add(_bytes, add(_start, 0x20))\n                } lt(slice_curr, slice_end) {\n                    slice_curr := add(slice_curr, 0x20)\n                    array_current := add(array_current, 0x20)\n                } {\n                    mstore(slice_curr, mload(array_current))\n                }\n            }\n        }\n\n        return tempBytes;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'UnsafeBytes.readAddress', 'start_line': 1557, 'end_line': 1562, 'offset_start': 70966, 'offset_end': 71201, 'content': 'function readAddress(bytes memory _bytes, uint256 _start) internal pure returns (address result, uint256 offset) {\n        assembly {\n            offset := add(_start, 20)\n            result := mload(add(_bytes, offset))\n        }\n    }', 'contract_name': 'UnsafeBytes', 'contract_code': '{\n    function readUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 4)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readAddress(bytes memory _bytes, uint256 _start) internal pure returns (address result, uint256 offset) {\n        assembly {\n            offset := add(_start, 20)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\n    // Get slice from bytes arrays\n    // Returns the newly created \'bytes memory\'\n    // NOTE: theoretically possible overflow of (_start + _length)\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_bytes.length >= (_start + _length), "Z"); // bytes length is less then start byte + length bytes\n\n        bytes memory tempBytes = new bytes(_length);\n\n        if (_length != 0) {\n            assembly {\n                let slice_curr := add(tempBytes, 0x20)\n                let slice_end := add(slice_curr, _length)\n\n                for {\n                    let array_current := add(_bytes, add(_start, 0x20))\n                } lt(slice_curr, slice_end) {\n                    slice_curr := add(slice_curr, 0x20)\n                    array_current := add(array_current, 0x20)\n                } {\n                    mstore(slice_curr, mload(array_current))\n                }\n            }\n        }\n\n        return tempBytes;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'UnsafeBytes.readUint256', 'start_line': 1564, 'end_line': 1569, 'offset_start': 71208, 'offset_end': 71443, 'content': 'function readUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }', 'contract_name': 'UnsafeBytes', 'contract_code': '{\n    function readUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 4)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readAddress(bytes memory _bytes, uint256 _start) internal pure returns (address result, uint256 offset) {\n        assembly {\n            offset := add(_start, 20)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\n    // Get slice from bytes arrays\n    // Returns the newly created \'bytes memory\'\n    // NOTE: theoretically possible overflow of (_start + _length)\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_bytes.length >= (_start + _length), "Z"); // bytes length is less then start byte + length bytes\n\n        bytes memory tempBytes = new bytes(_length);\n\n        if (_length != 0) {\n            assembly {\n                let slice_curr := add(tempBytes, 0x20)\n                let slice_end := add(slice_curr, _length)\n\n                for {\n                    let array_current := add(_bytes, add(_start, 0x20))\n                } lt(slice_curr, slice_end) {\n                    slice_curr := add(slice_curr, 0x20)\n                    array_current := add(array_current, 0x20)\n                } {\n                    mstore(slice_curr, mload(array_current))\n                }\n            }\n        }\n\n        return tempBytes;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'UnsafeBytes.readBytes32', 'start_line': 1571, 'end_line': 1576, 'offset_start': 71450, 'offset_end': 71685, 'content': 'function readBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }', 'contract_name': 'UnsafeBytes', 'contract_code': '{\n    function readUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 4)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readAddress(bytes memory _bytes, uint256 _start) internal pure returns (address result, uint256 offset) {\n        assembly {\n            offset := add(_start, 20)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\n    // Get slice from bytes arrays\n    // Returns the newly created \'bytes memory\'\n    // NOTE: theoretically possible overflow of (_start + _length)\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_bytes.length >= (_start + _length), "Z"); // bytes length is less then start byte + length bytes\n\n        bytes memory tempBytes = new bytes(_length);\n\n        if (_length != 0) {\n            assembly {\n                let slice_curr := add(tempBytes, 0x20)\n                let slice_end := add(slice_curr, _length)\n\n                for {\n                    let array_current := add(_bytes, add(_start, 0x20))\n                } lt(slice_curr, slice_end) {\n                    slice_curr := add(slice_curr, 0x20)\n                    array_current := add(array_current, 0x20)\n                } {\n                    mstore(slice_curr, mload(array_current))\n                }\n            }\n        }\n\n        return tempBytes;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'UnsafeBytes.slice', 'start_line': 1582, 'end_line': 1604, 'offset_start': 71957, 'offset_end': 72811, 'content': 'function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_bytes.length >= (_start + _length), "Z"); // bytes length is less then start byte + length bytes\n\n        bytes memory tempBytes = new bytes(_length);\n\n        if (_length != 0) {\n            assembly {\n                let slice_curr := add(tempBytes, 0x20)\n                let slice_end := add(slice_curr, _length)\n\n                for {\n                    let array_current := add(_bytes, add(_start, 0x20))\n                } lt(slice_curr, slice_end) {\n                    slice_curr := add(slice_curr, 0x20)\n                    array_current := add(array_current, 0x20)\n                } {\n                    mstore(slice_curr, mload(array_current))\n                }\n            }\n        }\n\n        return tempBytes;\n    }', 'contract_name': 'UnsafeBytes', 'contract_code': '{\n    function readUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 4)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readAddress(bytes memory _bytes, uint256 _start) internal pure returns (address result, uint256 offset) {\n        assembly {\n            offset := add(_start, 20)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\n    // Get slice from bytes arrays\n    // Returns the newly created \'bytes memory\'\n    // NOTE: theoretically possible overflow of (_start + _length)\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_bytes.length >= (_start + _length), "Z"); // bytes length is less then start byte + length bytes\n\n        bytes memory tempBytes = new bytes(_length);\n\n        if (_length != 0) {\n            assembly {\n                let slice_curr := add(tempBytes, 0x20)\n                let slice_end := add(slice_curr, _length)\n\n                for {\n                    let array_current := add(_bytes, add(_start, 0x20))\n                } lt(slice_curr, slice_end) {\n                    slice_curr := add(slice_curr, 0x20)\n                    array_current := add(array_current, 0x20)\n                } {\n                    mstore(slice_curr, mload(array_current))\n                }\n            }\n        }\n\n        return tempBytes;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Metadata.name', 'start_line': 1623, 'end_line': 1623, 'offset_start': 73193, 'offset_end': 73246, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC20Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Metadata.symbol', 'start_line': 1628, 'end_line': 1628, 'offset_start': 73314, 'offset_end': 73369, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC20Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Metadata.decimals', 'start_line': 1633, 'end_line': 1633, 'offset_start': 73446, 'offset_end': 73495, 'content': 'function decimals() external view returns (uint8);', 'contract_name': 'IERC20Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 1701, 'end_line': 1709, 'offset_start': 76496, 'offset_end': 76678, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 1718, 'end_line': 1718, 'offset_start': 76984, 'offset_end': 77046, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 1724, 'end_line': 1724, 'offset_start': 77239, 'offset_end': 77298, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressAliasHelper.applyL1ToL2Alias', 'start_line': 1754, 'end_line': 1758, 'offset_start': 78371, 'offset_end': 78556, 'content': 'function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + OFFSET);\n        }\n    }', 'contract_name': 'AddressAliasHelper', 'contract_code': '{\n    uint160 internal constant OFFSET = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function converts the address that submitted a tx\n    /// to the inbox on L1 to the msg.sender viewed on L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + OFFSET);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed on L2 to the\n    /// address that submitted a tx to the inbox on L1\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - OFFSET);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressAliasHelper.undoL1ToL2Alias', 'start_line': 1764, 'end_line': 1768, 'offset_start': 78836, 'offset_end': 79020, 'content': 'function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - OFFSET);\n        }\n    }', 'contract_name': 'AddressAliasHelper', 'contract_code': '{\n    uint160 internal constant OFFSET = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function converts the address that submitted a tx\n    /// to the inbox on L1 to the msg.sender viewed on L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + OFFSET);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed on L2 to the\n    /// address that submitted a tx to the inbox on L1\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - OFFSET);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xad16edcf7deb7e90096a259c81269d811544b6b6/0xad16edcf7deb7e90096a259c81269d811544b6b6.sol'}
