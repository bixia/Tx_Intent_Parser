{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.sortTokens', 'start_line': 12, 'end_line': 16, 'offset_start': 297, 'offset_end': 641, 'content': "function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }", 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        if (factory == address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f)) {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        } else {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        }\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.pairFor', 'start_line': 19, 'end_line': 44, 'offset_start': 731, 'offset_end': 1808, 'content': "function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        if (factory == address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f)) {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        } else {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        }\n    }", 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        if (factory == address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f)) {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        } else {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        }\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.getReserves', 'start_line': 47, 'end_line': 51, 'offset_start': 1864, 'offset_end': 2250, 'content': 'function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }', 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        if (factory == address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f)) {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        } else {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        }\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.quote', 'start_line': 54, 'end_line': 58, 'offset_start': 2361, 'offset_end': 2677, 'content': "function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }", 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        if (factory == address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f)) {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        } else {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        }\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.getAmountOut', 'start_line': 61, 'end_line': 68, 'offset_start': 2797, 'offset_end': 3306, 'content': "function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }", 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        if (factory == address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f)) {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        } else {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        }\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.getAmountIn', 'start_line': 71, 'end_line': 77, 'offset_start': 3425, 'offset_end': 3890, 'content': "function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }", 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        if (factory == address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f)) {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        } else {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        }\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.getAmountsOut', 'start_line': 80, 'end_line': 88, 'offset_start': 3970, 'offset_end': 4472, 'content': "function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }", 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        if (factory == address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f)) {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        } else {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        }\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'UniswapV2Library.getAmountsIn', 'start_line': 91, 'end_line': 99, 'offset_start': 4551, 'offset_end': 5074, 'content': "function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }", 'contract_name': 'UniswapV2Library', 'contract_code': "{\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        if (factory == address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f)) {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        } else {\n          bytes32 pubKey = keccak256(abi.encodePacked(\n                  hex'ff',\n                  factory,\n                  keccak256(abi.encodePacked(token0, token1)),\n                  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n              ));\n          assembly {\n              mstore(0x0, pubKey)\n              pair := mload(0x0)\n          }\n        }\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 140, 'end_line': 142, 'offset_start': 6408, 'offset_end': 6534, 'content': 'function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 144, 'end_line': 146, 'offset_start': 6541, 'offset_end': 6671, 'content': 'function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        _transferOwnership(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 159, 'end_line': 161, 'offset_start': 6898, 'offset_end': 6982, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 166, 'end_line': 170, 'offset_start': 7056, 'offset_end': 7217, 'content': 'function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 179, 'end_line': 181, 'offset_start': 7553, 'offset_end': 7653, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 187, 'end_line': 192, 'offset_start': 7803, 'offset_end': 8017, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 198, 'end_line': 202, 'offset_start': 8172, 'offset_end': 8358, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3SwapCallback.uniswapV3SwapCallback', 'start_line': 225, 'end_line': 229, 'offset_start': 9655, 'offset_end': 9787, 'content': 'function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;', 'contract_name': 'IUniswapV3SwapCallback', 'contract_code': '{\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3Pool.factory', 'start_line': 240, 'end_line': 240, 'offset_start': 10027, 'offset_end': 10077, 'content': 'function factory() external view returns (address);', 'contract_name': 'IUniswapV3Pool', 'contract_code': "{\n\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n    \n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3Pool.token0', 'start_line': 244, 'end_line': 244, 'offset_start': 10202, 'offset_end': 10251, 'content': 'function token0() external view returns (address);', 'contract_name': 'IUniswapV3Pool', 'contract_code': "{\n\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n    \n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3Pool.token1', 'start_line': 248, 'end_line': 248, 'offset_start': 10377, 'offset_end': 10426, 'content': 'function token1() external view returns (address);', 'contract_name': 'IUniswapV3Pool', 'contract_code': "{\n\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n    \n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3Pool.fee', 'start_line': 252, 'end_line': 252, 'offset_start': 10522, 'offset_end': 10567, 'content': 'function fee() external view returns (uint24);', 'contract_name': 'IUniswapV3Pool', 'contract_code': "{\n\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n    \n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV3Pool.swap', 'start_line': 254, 'end_line': 260, 'offset_start': 10578, 'offset_end': 10795, 'content': 'function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);', 'contract_name': 'IUniswapV3Pool', 'contract_code': "{\n\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n    \n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.totalSupply', 'start_line': 289, 'end_line': 289, 'offset_start': 11585, 'offset_end': 11639, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.balanceOf', 'start_line': 294, 'end_line': 294, 'offset_start': 11722, 'offset_end': 11789, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transfer', 'start_line': 303, 'end_line': 303, 'offset_start': 12014, 'offset_end': 12082, 'content': 'function transfer(address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.allowance', 'start_line': 312, 'end_line': 312, 'offset_start': 12358, 'offset_end': 12440, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.approve', 'start_line': 329, 'end_line': 329, 'offset_start': 13119, 'offset_end': 13191, 'content': 'function approve(address spender, uint256 value) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transferFrom', 'start_line': 340, 'end_line': 340, 'offset_start': 13500, 'offset_end': 13586, 'content': 'function transferFrom(address from, address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'TickMath.getSqrtRatioAtTick', 'start_line': 365, 'end_line': 396, 'offset_start': 14934, 'offset_end': 17515, 'content': "function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= toUint256(MAX_TICK), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }", 'contract_name': 'TickMath', 'contract_code': '{\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= toUint256(MAX_TICK), \'T\');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \'R\');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n\n    function toUint256(int24 value) pure public returns (uint256) {\n        require(value >= 0, "Input value is negative");\n\n        int256 convertedInt = int256(value);\n        return uint256(convertedInt);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'TickMath.getTickAtSqrtRatio', 'start_line': 403, 'end_line': 546, 'offset_start': 17935, 'offset_end': 22215, 'content': "function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }", 'contract_name': 'TickMath', 'contract_code': '{\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= toUint256(MAX_TICK), \'T\');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \'R\');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n\n    function toUint256(int24 value) pure public returns (uint256) {\n        require(value >= 0, "Input value is negative");\n\n        int256 convertedInt = int256(value);\n        return uint256(convertedInt);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'TickMath.toUint256', 'start_line': 548, 'end_line': 553, 'offset_start': 22222, 'offset_end': 22430, 'content': 'function toUint256(int24 value) pure public returns (uint256) {\n        require(value >= 0, "Input value is negative");\n\n        int256 convertedInt = int256(value);\n        return uint256(convertedInt);\n    }', 'contract_name': 'TickMath', 'contract_code': '{\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= toUint256(MAX_TICK), \'T\');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \'R\');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n\n    function toUint256(int24 value) pure public returns (uint256) {\n        require(value >= 0, "Input value is negative");\n\n        int256 convertedInt = int256(value);\n        return uint256(convertedInt);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.deposit', 'start_line': 595, 'end_line': 595, 'offset_start': 23710, 'offset_end': 23745, 'content': 'function deposit() external payable;', 'contract_name': 'IWETH', 'contract_code': '{\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.withdraw', 'start_line': 598, 'end_line': 598, 'offset_start': 23804, 'offset_end': 23839, 'content': 'function withdraw(uint256) external;', 'contract_name': 'IWETH', 'contract_code': '{\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.', 'start_line': 685, 'end_line': 685, 'offset_start': 25940, 'offset_end': 25968, 'content': 'receive() external payable {}', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.initialize', 'start_line': 687, 'end_line': 705, 'offset_start': 25975, 'offset_end': 26489, 'content': 'function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.takeFee', 'start_line': 708, 'end_line': 723, 'offset_start': 26512, 'offset_end': 27153, 'content': 'function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapV2ExactIn', 'start_line': 726, 'end_line': 790, 'offset_start': 27232, 'offset_end': 29963, 'content': 'function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapV2ExactOut', 'start_line': 793, 'end_line': 847, 'offset_start': 30052, 'offset_end': 32279, 'content': 'function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX._swap', 'start_line': 851, 'end_line': 862, 'offset_start': 32388, 'offset_end': 33131, 'content': 'function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX._swapSupportingFeeOnTransferTokens', 'start_line': 866, 'end_line': 883, 'offset_start': 33275, 'offset_end': 34518, 'content': 'function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapV2MultiHopExactIn', 'start_line': 886, 'end_line': 931, 'offset_start': 34602, 'offset_end': 36366, 'content': 'function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapV2MultiHopExactOut', 'start_line': 934, 'end_line': 972, 'offset_start': 36460, 'offset_end': 37856, 'content': 'function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.uniswapV3SwapCallback', 'start_line': 975, 'end_line': 1002, 'offset_start': 37893, 'offset_end': 39188, 'content': 'function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapV3ExactIn', 'start_line': 1005, 'end_line': 1045, 'offset_start': 39226, 'offset_end': 40796, 'content': 'function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapV3ExactOut', 'start_line': 1048, 'end_line': 1094, 'offset_start': 40835, 'offset_end': 42533, 'content': 'function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapV3MultiHopExactIn', 'start_line': 1097, 'end_line': 1143, 'offset_start': 42573, 'offset_end': 44380, 'content': 'function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapV3MultiHopExactOut', 'start_line': 1146, 'end_line': 1177, 'offset_start': 44421, 'offset_end': 45531, 'content': 'function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.isStrEqual', 'start_line': 1179, 'end_line': 1181, 'offset_start': 45538, 'offset_end': 45697, 'content': 'function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapMixedMultiHopExactIn', 'start_line': 1184, 'end_line': 1304, 'offset_start': 45772, 'offset_end': 51296, 'content': 'function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.swapMixedMultiHopExactOut', 'start_line': 1307, 'end_line': 1401, 'offset_start': 51337, 'offset_end': 55569, 'content': 'function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None, None, None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.getPool', 'start_line': 1404, 'end_line': 1410, 'offset_start': 55608, 'offset_end': 55857, 'content': 'function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.exactInputInternal', 'start_line': 1413, 'end_line': 1438, 'offset_start': 55911, 'offset_end': 56844, 'content': 'function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.exactOutputInternal', 'start_line': 1441, 'end_line': 1472, 'offset_start': 56895, 'offset_end': 58228, 'content': "function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it's technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }", 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.pay', 'start_line': 1474, 'end_line': 1491, 'offset_start': 58235, 'offset_end': 58933, 'content': 'function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.pause', 'start_line': 1493, 'end_line': 1495, 'offset_start': 58940, 'offset_end': 59000, 'content': 'function pause() external onlyOwner {\n        _pause();\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.unpause', 'start_line': 1497, 'end_line': 1499, 'offset_start': 59007, 'offset_end': 59071, 'content': 'function unpause() external onlyOwner {\n        _unpause();\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.setFeeRate', 'start_line': 1501, 'end_line': 1504, 'offset_start': 59078, 'offset_end': 59220, 'content': 'function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.setFeeCollector', 'start_line': 1506, 'end_line': 1509, 'offset_start': 59227, 'offset_end': 59373, 'content': 'function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.setWETH', 'start_line': 1511, 'end_line': 1514, 'offset_start': 59380, 'offset_end': 59510, 'content': 'function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.setFeeExclude', 'start_line': 1516, 'end_line': 1519, 'offset_start': 59517, 'offset_end': 59692, 'content': 'function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SwapX.rescueERC20Token', 'start_line': 1521, 'end_line': 1524, 'offset_start': 59699, 'offset_end': 59950, 'content': 'function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }', 'contract_name': 'SwapX', 'contract_code': '{\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMath for uint;\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address tokenIn;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct ExactInputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputMixedParams {\n        string[] routes;\n        bytes path1;\n        address factory1;\n        bytes path2;\n        address factory2;\n        uint256 amountIn2; // only for v2-v3 router\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    event FeeCollected(address indexed token, address indexed payer, uint256 amount, uint256 timestamp);\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \'Transaction too old\');\n        _;\n    }\n\n    receive() external payable {}\n\n    function initialize (\n        address _factoryV2,\n        address _factoryV3,\n        address _WETH,\n        address _feeCollector,\n        uint256 _feeRate\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        factoryV2 = _factoryV2;\n        factoryV3 = _factoryV3;\n        feeCollector = _feeCollector;\n        feeRate = _feeRate;\n        feeDenominator = 10000;\n        WETH = _WETH;\n        amountInCached = type(uint256).max;\n    }\n\n    // take fee\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if (( tokenIn == address(0) || tokenIn == WETH ) && address(this).balance > fee ) {\n            (bool success, ) = address(feeCollector).call{ value: fee }("");\n            require(success, "SwapX: take fee error");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n        \n        emit FeeCollected(tokenIn, msg.sender, fee, block.timestamp);\n\n        return fee; \n    }\n\n    // V2: Any swap, ExactIn single-hop - SupportingFeeOnTransferTokens\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        if (nativeIn) {\n            pay(tokenIn, address(this), poolAddress, amountIn);\n        } else\n            pay(tokenIn, msg.sender, poolAddress, amountIn);\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true;\n\n        uint balanceBefore = nativeOut ? \n            IERC20Upgradeable(WETH).balanceOf(address(this)) :  IERC20Upgradeable(tokenOut).balanceOf(msg.sender);\n        \n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        uint amountInput;\n        uint amountOutput;\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20Upgradeable(tokenIn).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore);\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2: Any swap, ExactOut single-hop - * not support fee-on-transfer tokens *\n    function swapV2ExactOut(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address poolAddress\n     ) payable public nonReentrant whenNotPaused returns (uint amountIn){\n\n        require(poolAddress != address(0), "SwapX: invalid pool address");\n        require(amountInMax > 0, "SwapX: amout in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            tokenIn = WETH;\n            nativeIn = true;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (tokenOut == address(0)) {\n            nativeOut = true;\n        }\n\n        IUniswapV2Pair pair = IUniswapV2Pair(poolAddress);\n        address token0 = pair.token0();\n        { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountIn = UniswapV2Library.getAmountIn(amountOut, reserveInput, reserveOutput);\n\n            uint256 fee = takeFee(tokenIn, amountIn);\n\n            require(amountIn + fee <= amountInMax, "SwapX: excessive input amount");\n            if(nativeIn) {\n                pay(tokenIn, address(this), poolAddress, amountIn);\n                uint amount = msg.value - amountIn - fee;\n                // refund\n                if (amount > 0) {\n                    (bool success, ) = address(msg.sender).call{value: amount}("");\n                    require(success, "SwapX: refund ETH error");\n                }\n            } else { \n                pay(tokenIn, msg.sender, poolAddress, amountIn);\n            }\n        }\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = nativeOut ? address(this) : msg.sender;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(msg.sender).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n     // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, address _factory) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1,) = pair.getReserves();\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                amountInput = IERC20Upgradeable(input).balanceOf(address(pair)).sub(reserveInput);\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    // V2-V2: Uniswap/Sushiswap, SupportingFeeOnTransferTokens and multi-hop\n    function swapV2MultiHopExactIn(\n        address tokenIn,\n        uint256 amountIn, \n        uint256 amountOutMin, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountIn > 0, "SwapX: amout in is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        amountIn = amountIn - fee;\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amountIn);\n        } else\n            pay(tokenIn, msg.sender, firstPool, amountIn);\n        require(tokenIn == path[0], "invalid path");\n\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n\n        uint balanceBefore = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient);\n        _swapSupportingFeeOnTransferTokens(path, recipient, factory);\n        uint balanceChanged = IERC20Upgradeable(path[path.length - 1]).balanceOf(recipient).sub(balanceBefore);\n        amounts[path.length - 1] = balanceChanged;\n        require(\n            balanceChanged >= amountOutMin,\n            \'SwapX: insufficient output amount\'\n        );\n    }\n\n    // V2-V2: Uniswap, ExactOut multi-hop, not support fee-on-transfer token in output\n    function swapV2MultiHopExactOut(\n        address tokenIn, \n        uint256 amountInMax, \n        uint256 amountOut, \n        address[] calldata path, \n        address recipient,\n        uint deadline,\n        address factory\n    ) payable public nonReentrant whenNotPaused checkDeadline(deadline) returns (uint[] memory amounts){\n\n        require(amountInMax > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            nativeIn = true;\n            tokenIn = WETH;\n            require(msg.value >= amountInMax, "SwapX: amount in and value mismatch");\n        }\n\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n\n        uint256 fee = takeFee(tokenIn, amounts[0]);\n\n        require(amounts[0] + fee <= amountInMax, \'SwapX: excessive input amount\');\n\n        address firstPool = UniswapV2Library.pairFor(factory, path[0], path[1]);\n        if (nativeIn) {\n            pay(tokenIn, address(this), firstPool, amounts[0]);\n            uint amount = msg.value - amounts[0] - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } else\n            pay(tokenIn, msg.sender, firstPool, amounts[0]);\n\n        _swap(amounts, path, recipient, factory);\n    }\n\n    /// UniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factoryV3, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    // V3: ExactIn single-hop \n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        if (params.tokenIn == address(0)) {\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        uint256 fee = takeFee(params.tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountOut = exactInputInternal(\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, "SwapX: insufficient out amount");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            (bool success, ) = address(params.recipient).call{value: amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n    }\n\n    // V3: ExactOut single-hop \n    function swapV3ExactOut (\n        ExactOutputSingleParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n\n        bool nativeIn = false;\n        if (params.tokenIn == address(0)) {\n            nativeIn = true;\n            params.tokenIn = WETH;\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n        }\n\n        bool nativeOut = false;\n        if (params.tokenOut == address(0)) {\n            params.tokenOut = WETH;\n            nativeOut = true;\n        }\n\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n        \n        if (nativeIn) {\n            uint amount = msg.value - amountIn - fee;\n            // refund\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        } \n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(params.amountOut);\n            (bool success, ) = address(params.recipient).call{value: params.amountOut}("");\n            require(success, "SwapX: send ETH out error");\n        }\n\n        amountInCached = type(uint256).max; \n    }\n\n    // V3-V3: ExactIn multi-hop \n    function swapV3MultiHopExactIn (\n        ExactInputParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n        if (msg.value > 0) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), \n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // V3-V3: ExactOut multi-hop \n    function swapV3MultiHopExactOut(\n        ExactOutputParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n\n        uint256 fee = takeFee(params.tokenIn, amountIn);\n\n        require(amountIn + fee <= params.amountInMaximum, \'SwapX: too much requested\');\n\n        if (msg.value > 0) {\n            // refund\n            uint256 amount = msg.value - amountIn - fee;\n            if (amount > 0) {\n                (bool success, ) = address(msg.sender).call{value: amount}("");\n                require(success, "SwapX: refund ETH error");\n            }\n        }\n\n        amountInCached = type(uint256).max;\n    }\n\n    function isStrEqual(string memory str1, string memory str2) internal pure returns(bool) {\n        return keccak256(bytes(str1)) == keccak256(bytes(str2));\n    }\n\n    // Mixed: ExactIn multi-hop, token not supporting zero address \n    function swapMixedMultiHopExactIn (\n        ExactInputMixedParams memory params\n    ) payable public nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n\n        require(params.routes.length == 2, "SwapX: only 2 routes supported");\n\n        require(params.amountIn > 0, "SwapX: amount in is zero");\n\n        (address tokenIn, address tokenOut1, uint24 fee1) = params.path1.decodeFirstPool();\n        bool nativeIn = false;\n        if (tokenIn == address(0)) {\n            require(msg.value >= params.amountIn, "SwapX: amount in and value mismatch");\n            nativeIn = true;\n            tokenIn = WETH;\n            // refund\n            uint amount = msg.value - params.amountIn;\n            if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n            }\n        }\n        uint256 fee = takeFee(tokenIn, params.amountIn);\n        params.amountIn = params.amountIn - fee;\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, poolAddress2, params.factory1);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            if (nativeIn) {\n                pay(tokenIn, address(this), poolAddress1, params.amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, params.amountIn);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsOut(params.factory1, params.amountIn, path1);\n            uint amountOut1 = amounts1[amounts1.length-1];\n\n            (, address tokenOut,) = params.path2.decodeFirstPool();\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path1, address(this), params.factory1);\n\n            amountOut = exactInputInternal(\n                amountOut1,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n            (address tokenIn2, address tokenOut,) = params.path2.decodeFirstPool();\n            address pairV2Address = UniswapV2Library.pairFor(params.factory2, tokenIn2, tokenOut);\n\n            uint amountOut1 = exactInputInternal(\n                params.amountIn,\n                pairV2Address, \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenIn2;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsOut(params.factory2, amountOut1, path2);\n            amountOut = amounts2[amounts2.length - 1];\n\n            uint balanceBefore = IERC20Upgradeable(tokenOut).balanceOf(params.recipient);\n            _swapSupportingFeeOnTransferTokens(path2, params.recipient, params.factory2);\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(params.recipient).sub(balanceBefore);\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v3")) {\n            // uni - uni, same as swapMultiHopExactIn\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                address(this), \n                0,\n                SwapCallbackData({\n                    path: abi.encodePacked(tokenIn, fee1, tokenOut1), \n                    payer: msg.sender \n                })\n            );\n\n            amountOut = exactInputInternal(\n                params.amountIn,\n                params.recipient, \n                0,\n                SwapCallbackData({\n                    path: params.path2, \n                    payer: address(this) \n                })\n            );\n        }\n\n        require(amountOut >= params.amountOutMinimum, \'SwapX: too little received\');\n    }\n\n    // Mixed: ExactOut multi-hop \n    function swapMixedMultiHopExactOut(\n        ExactOutputMixedParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountIn) {\n\n        require(params.amountInMaximum > 0, "SwapX: amount in max is zero");\n        if (msg.value > 0)\n            require(msg.value >= params.amountInMaximum, "SwapX: amount in max and value mismatch");\n\n        (address tokenIn, address tokenOut1,) = params.path1.decodeFirstPool();\n        (, address tokenOut,) = params.path2.decodeFirstPool();\n\n        if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v2")) {\n            // uni - sushi, or verse\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n\n            address poolAddress2 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            address[] memory path2 = new address[](2);\n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, amounts2[0], path1);\n            amountIn = amounts1[0];\n\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, poolAddress2, params.factory1);\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n\n        } else if (isStrEqual(params.routes[0], "v2") && isStrEqual(params.routes[1], "v3")) {\n            // NOTE: v3 not support fee-on-transfer token, so the mid-token amountIn is exactly same as params.amountIn2 \n            // v3 path bytes is reversed\n            (tokenOut, ,) = params.path2.decodeFirstPool();\n\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory1, tokenIn, tokenOut1);\n            address[] memory path1 = new address[](2);\n            path1[0] = tokenIn;\n            path1[1] = tokenOut1;\n            uint[] memory amounts1 = UniswapV2Library.getAmountsIn(params.factory1, params.amountIn2, path1);\n            amountIn = amounts1[0];\n            if (tokenIn == WETH) {\n                pay(tokenIn, address(this), poolAddress1, amountIn);\n            } else\n                pay(tokenIn, msg.sender, poolAddress1, amountIn);\n\n            _swap(amounts1, path1, address(this), params.factory1);\n\n            uint amountIn2 = exactOutputInternal(\n                params.amountOut,\n                params.recipient,\n                0,\n                SwapCallbackData({path: params.path2, payer: address(this)})\n            );\n            require(amountIn2 == params.amountIn2, "SwapX: not support fee-on-transfer token for V3");\n\n        } else if (isStrEqual(params.routes[0], "v3") && isStrEqual(params.routes[1], "v2")) {\n\n            (tokenOut1, tokenIn,) = params.path1.decodeFirstPool();\n\n            address[] memory path2 = new address[](2); \n            path2[0] = tokenOut1;\n            path2[1] = tokenOut;\n            address poolAddress1 = UniswapV2Library.pairFor(params.factory2, tokenOut1, tokenOut);\n            uint[] memory amounts2 = UniswapV2Library.getAmountsIn(params.factory2, params.amountOut, path2);\n            uint amountIn2 = amounts2[0];\n\n            amountIn = exactOutputInternal(\n                amountIn2,\n                poolAddress1,\n                0,\n                SwapCallbackData({path: params.path1, payer: msg.sender})\n            );\n\n            _swap(amounts2, path2, params.recipient, params.factory2);\n        } \n\n        uint256 fee = takeFee(tokenIn, amountIn);\n        require(amountIn + fee <= params.amountInMaximum, "SwapX: too much requested");\n\n        if (msg.value > 0) {\n          uint amount = msg.value - amountIn - fee;\n          // refund\n          if (amount > 0) {\n              (bool success, ) = address(msg.sender).call{value: amount}("");\n              require(success, "SwapX: refund ETH error");\n          }\n        }\n    }\n\n    // V3: compute pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factoryV3, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    /// V3: Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it\'s technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WETH && address(this).balance >= value) {\n            // pay with WETH\n            IWETH(WETH).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            IERC20Upgradeable(token).safeTransfer(recipient, value);\n        } else {\n            // pull payment\n            IERC20Upgradeable(token).safeTransferFrom(payer, recipient, value);\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setFeeRate(uint256 rate) external onlyOwner {\n        require(rate < 10000, "rate over feeDenominator");\n        feeRate = rate;\n    }\n\n    function setFeeCollector(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeCollector = addr;\n    }\n\n    function setWETH(address addr) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        WETH = addr;\n    }\n\n    function setFeeExclude(address addr, bool isExcluded) external onlyOwner {\n        require(addr != address(0), "invalid addr");\n        feeExcludeList[addr] = isExcluded;\n    }\n\n    function rescueERC20Token(address token, address recipient) external onlyOwner {\n        require(recipient!= address(0), "invalid addr");\n        IERC20Upgradeable(token).safeTransfer(recipient, IERC20Upgradeable(token).balanceOf(address(this)));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.add', 'start_line': 1533, 'end_line': 1535, 'offset_start': 60143, 'offset_end': 60268, 'content': "function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }", 'contract_name': 'SafeMath', 'contract_code': "{\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n\n    function div(uint a, uint b) internal pure returns (uint) {\n        assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.sub', 'start_line': 1537, 'end_line': 1539, 'offset_start': 60275, 'offset_end': 60401, 'content': "function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }", 'contract_name': 'SafeMath', 'contract_code': "{\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n\n    function div(uint a, uint b) internal pure returns (uint) {\n        assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.mul', 'start_line': 1541, 'end_line': 1543, 'offset_start': 60408, 'offset_end': 60547, 'content': "function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }", 'contract_name': 'SafeMath', 'contract_code': "{\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n\n    function div(uint a, uint b) internal pure returns (uint) {\n        assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.div', 'start_line': 1545, 'end_line': 1550, 'offset_start': 60554, 'offset_end': 60831, 'content': "function div(uint a, uint b) internal pure returns (uint) {\n        assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }", 'contract_name': 'SafeMath', 'contract_code': "{\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n\n    function div(uint a, uint b) internal pure returns (uint) {\n        assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'CallbackValidation.verifyCallback', 'start_line': 1568, 'end_line': 1575, 'offset_start': 61485, 'offset_end': 61743, 'content': 'function verifyCallback(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal view returns (IUniswapV3Pool pool) {\n        return verifyCallback(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee));\n    }', 'contract_name': 'CallbackValidation', 'contract_code': '{\n    /// @notice Returns the address of a valid Uniswap V3 Pool\n    /// @param factory The contract address of the Uniswap V3 factory\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The V3 pool contract address\n    function verifyCallback(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal view returns (IUniswapV3Pool pool) {\n        return verifyCallback(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee));\n    }\n\n    /// @notice Returns the address of a valid Uniswap V3 Pool\n    /// @param factory The contract address of the Uniswap V3 factory\n    /// @param poolKey The identifying key of the V3 pool\n    /// @return pool The V3 pool contract address\n    function verifyCallback(address factory, PoolAddress.PoolKey memory poolKey)\n        internal\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));\n        require(msg.sender == address(pool));\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'CallbackValidation.verifyCallback', 'start_line': 1581, 'end_line': 1588, 'offset_start': 61991, 'offset_end': 62269, 'content': 'function verifyCallback(address factory, PoolAddress.PoolKey memory poolKey)\n        internal\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));\n        require(msg.sender == address(pool));\n    }', 'contract_name': 'CallbackValidation', 'contract_code': '{\n    /// @notice Returns the address of a valid Uniswap V3 Pool\n    /// @param factory The contract address of the Uniswap V3 factory\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The V3 pool contract address\n    function verifyCallback(\n        address factory,\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal view returns (IUniswapV3Pool pool) {\n        return verifyCallback(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee));\n    }\n\n    /// @notice Returns the address of a valid Uniswap V3 Pool\n    /// @param factory The contract address of the Uniswap V3 factory\n    /// @param poolKey The identifying key of the V3 pool\n    /// @return pool The V3 pool contract address\n    function verifyCallback(address factory, PoolAddress.PoolKey memory poolKey)\n        internal\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));\n        require(msg.sender == address(pool));\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast.toUint160', 'start_line': 1600, 'end_line': 1602, 'offset_start': 62619, 'offset_end': 62729, 'content': 'function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }', 'contract_name': 'SafeCast', 'contract_code': '{\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast.toInt128', 'start_line': 1607, 'end_line': 1609, 'offset_start': 62914, 'offset_end': 63020, 'content': 'function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }', 'contract_name': 'SafeCast', 'contract_code': '{\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast.toInt256', 'start_line': 1614, 'end_line': 1617, 'offset_start': 63186, 'offset_end': 63306, 'content': 'function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }', 'contract_name': 'SafeCast', 'contract_code': '{\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 1660, 'end_line': 1669, 'offset_start': 64853, 'offset_end': 65183, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 1689, 'end_line': 1691, 'offset_start': 66027, 'offset_end': 66177, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 1702, 'end_line': 1708, 'offset_start': 66502, 'offset_end': 66893, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 1714, 'end_line': 1717, 'offset_start': 67033, 'offset_end': 67286, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 1723, 'end_line': 1726, 'offset_start': 67428, 'offset_end': 67680, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 1733, 'end_line': 1748, 'offset_start': 67947, 'offset_end': 68528, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 1754, 'end_line': 1760, 'offset_start': 68729, 'offset_end': 68952, 'content': 'function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 1765, 'end_line': 1777, 'offset_start': 69065, 'offset_end': 69580, 'content': 'function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.slice', 'start_line': 1791, 'end_line': 1855, 'offset_start': 69982, 'offset_end': 72988, 'content': "function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }", 'contract_name': 'BytesLib', 'contract_code': "{\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toAddress', 'start_line': 1857, 'end_line': 1867, 'offset_start': 72995, 'offset_end': 73410, 'content': "function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }", 'contract_name': 'BytesLib', 'contract_code': "{\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toUint24', 'start_line': 1869, 'end_line': 1879, 'offset_start': 73417, 'offset_end': 73781, 'content': "function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }", 'contract_name': 'BytesLib', 'contract_code': "{\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Path.hasMultiplePools', 'start_line': 1906, 'end_line': 1908, 'offset_start': 74778, 'offset_end': 74915, 'content': 'function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }', 'contract_name': 'Path', 'contract_code': '{\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Path.numPools', 'start_line': 1913, 'end_line': 1916, 'offset_start': 75068, 'offset_end': 75302, 'content': 'function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }', 'contract_name': 'Path', 'contract_code': '{\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Path.decodeFirstPool', 'start_line': 1923, 'end_line': 1935, 'offset_start': 75565, 'offset_end': 75878, 'content': 'function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }', 'contract_name': 'Path', 'contract_code': '{\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Path.getFirstPool', 'start_line': 1940, 'end_line': 1942, 'offset_start': 76105, 'offset_end': 76231, 'content': 'function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }', 'contract_name': 'Path', 'contract_code': '{\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Path.skipToken', 'start_line': 1947, 'end_line': 1949, 'offset_start': 76421, 'offset_end': 76569, 'content': 'function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }', 'contract_name': 'Path', 'contract_code': '{\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 2118, 'end_line': 2122, 'offset_start': 83033, 'offset_end': 83173, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error AlreadyInitialized();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        if (!(isTopLevelCall && initialized < 1) && !(address(this).code.length == 0 && initialized == 1)) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert AlreadyInitialized();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 2132, 'end_line': 2143, 'offset_start': 83660, 'offset_end': 84078, 'content': 'function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert AlreadyInitialized();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error AlreadyInitialized();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        if (!(isTopLevelCall && initialized < 1) && !(address(this).code.length == 0 && initialized == 1)) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert AlreadyInitialized();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 2148, 'end_line': 2150, 'offset_start': 84189, 'offset_end': 84316, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error AlreadyInitialized();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        if (!(isTopLevelCall && initialized < 1) && !(address(this).code.length == 0 && initialized == 1)) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert AlreadyInitialized();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 2155, 'end_line': 2157, 'offset_start': 84433, 'offset_end': 84552, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error AlreadyInitialized();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        if (!(isTopLevelCall && initialized < 1) && !(address(this).code.length == 0 && initialized == 1)) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert AlreadyInitialized();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 2163, 'end_line': 2167, 'offset_start': 84683, 'offset_end': 84852, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\'s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error AlreadyInitialized();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        if (!(isTopLevelCall && initialized < 1) && !(address(this).code.length == 0 && initialized == 1)) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\'t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert AlreadyInitialized();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert AlreadyInitialized();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init', 'start_line': 2213, 'end_line': 2215, 'offset_start': 86171, 'offset_end': 86267, 'content': 'function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init_unchained', 'start_line': 2217, 'end_line': 2219, 'offset_start': 86274, 'offset_end': 86368, 'content': 'function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.paused', 'start_line': 2248, 'end_line': 2250, 'offset_start': 86966, 'offset_end': 87049, 'content': 'function paused() public view virtual returns (bool) {\n        return _paused;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requireNotPaused', 'start_line': 2255, 'end_line': 2259, 'offset_start': 87118, 'offset_end': 87245, 'content': 'function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requirePaused', 'start_line': 2264, 'end_line': 2268, 'offset_start': 87318, 'offset_end': 87443, 'content': 'function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._pause', 'start_line': 2277, 'end_line': 2280, 'offset_start': 87579, 'offset_end': 87693, 'content': 'function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._unpause', 'start_line': 2289, 'end_line': 2292, 'offset_start': 87826, 'offset_end': 87942, 'content': 'function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 2319, 'end_line': 2320, 'offset_start': 88950, 'offset_end': 89008, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 2322, 'end_line': 2323, 'offset_start': 89015, 'offset_end': 89083, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 2324, 'end_line': 2326, 'offset_start': 89089, 'offset_end': 89184, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 2328, 'end_line': 2330, 'offset_start': 89191, 'offset_end': 89289, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.permit', 'start_line': 2375, 'end_line': 2383, 'offset_start': 91052, 'offset_end': 91234, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.nonces', 'start_line': 2392, 'end_line': 2392, 'offset_start': 91540, 'offset_end': 91602, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20PermitUpgradeable.DOMAIN_SEPARATOR', 'start_line': 2398, 'end_line': 2398, 'offset_start': 91795, 'offset_end': 91854, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20PermitUpgradeable', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.name', 'start_line': 2409, 'end_line': 2409, 'offset_start': 92104, 'offset_end': 92157, 'content': 'function name() external pure returns (string memory);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.symbol', 'start_line': 2410, 'end_line': 2410, 'offset_start': 92163, 'offset_end': 92218, 'content': 'function symbol() external pure returns (string memory);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.decimals', 'start_line': 2411, 'end_line': 2411, 'offset_start': 92224, 'offset_end': 92273, 'content': 'function decimals() external pure returns (uint8);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.totalSupply', 'start_line': 2412, 'end_line': 2412, 'offset_start': 92279, 'offset_end': 92330, 'content': 'function totalSupply() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.balanceOf', 'start_line': 2413, 'end_line': 2413, 'offset_start': 92336, 'offset_end': 92398, 'content': 'function balanceOf(address owner) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.allowance', 'start_line': 2414, 'end_line': 2414, 'offset_start': 92404, 'offset_end': 92483, 'content': 'function allowance(address owner, address spender) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.approve', 'start_line': 2416, 'end_line': 2416, 'offset_start': 92490, 'offset_end': 92559, 'content': 'function approve(address spender, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.transfer', 'start_line': 2417, 'end_line': 2417, 'offset_start': 92565, 'offset_end': 92630, 'content': 'function transfer(address to, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.transferFrom', 'start_line': 2418, 'end_line': 2418, 'offset_start': 92636, 'offset_end': 92719, 'content': 'function transferFrom(address from, address to, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.DOMAIN_SEPARATOR', 'start_line': 2420, 'end_line': 2420, 'offset_start': 92726, 'offset_end': 92785, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.PERMIT_TYPEHASH', 'start_line': 2421, 'end_line': 2421, 'offset_start': 92791, 'offset_end': 92849, 'content': 'function PERMIT_TYPEHASH() external pure returns (bytes32);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.nonces', 'start_line': 2422, 'end_line': 2422, 'offset_start': 92855, 'offset_end': 92914, 'content': 'function nonces(address owner) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.permit', 'start_line': 2424, 'end_line': 2424, 'offset_start': 92921, 'offset_end': 93035, 'content': 'function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.MINIMUM_LIQUIDITY', 'start_line': 2438, 'end_line': 2438, 'offset_start': 93431, 'offset_end': 93488, 'content': 'function MINIMUM_LIQUIDITY() external pure returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.factory', 'start_line': 2439, 'end_line': 2439, 'offset_start': 93494, 'offset_end': 93544, 'content': 'function factory() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.token0', 'start_line': 2440, 'end_line': 2440, 'offset_start': 93550, 'offset_end': 93599, 'content': 'function token0() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.token1', 'start_line': 2441, 'end_line': 2441, 'offset_start': 93605, 'offset_end': 93654, 'content': 'function token1() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.getReserves', 'start_line': 2442, 'end_line': 2442, 'offset_start': 93660, 'offset_end': 93768, 'content': 'function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.price0CumulativeLast', 'start_line': 2443, 'end_line': 2443, 'offset_start': 93774, 'offset_end': 93834, 'content': 'function price0CumulativeLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.price1CumulativeLast', 'start_line': 2444, 'end_line': 2444, 'offset_start': 93840, 'offset_end': 93900, 'content': 'function price1CumulativeLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.kLast', 'start_line': 2445, 'end_line': 2445, 'offset_start': 93906, 'offset_end': 93951, 'content': 'function kLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.mint', 'start_line': 2447, 'end_line': 2447, 'offset_start': 93958, 'offset_end': 94017, 'content': 'function mint(address to) external returns (uint liquidity);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.burn', 'start_line': 2448, 'end_line': 2448, 'offset_start': 94023, 'offset_end': 94094, 'content': 'function burn(address to) external returns (uint amount0, uint amount1);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.swap', 'start_line': 2449, 'end_line': 2449, 'offset_start': 94100, 'offset_end': 94189, 'content': 'function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.skim', 'start_line': 2450, 'end_line': 2450, 'offset_start': 94195, 'offset_end': 94229, 'content': 'function skim(address to) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.sync', 'start_line': 2451, 'end_line': 2451, 'offset_start': 94235, 'offset_end': 94259, 'content': 'function sync() external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.initialize', 'start_line': 2453, 'end_line': 2453, 'offset_start': 94266, 'offset_end': 94312, 'content': 'function initialize(address, address) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 2500, 'end_line': 2502, 'offset_start': 96284, 'offset_end': 96394, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 2504, 'end_line': 2506, 'offset_start': 96401, 'offset_end': 96508, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 2521, 'end_line': 2529, 'offset_start': 96995, 'offset_end': 97301, 'content': 'function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 2531, 'end_line': 2535, 'offset_start': 97308, 'offset_end': 97515, 'content': 'function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 2541, 'end_line': 2543, 'offset_start': 97695, 'offset_end': 97800, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeTransfer', 'start_line': 2588, 'end_line': 2590, 'offset_start': 99493, 'offset_end': 99663, 'content': 'function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': "{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeTransferFrom', 'start_line': 2596, 'end_line': 2598, 'offset_start': 99903, 'offset_end': 100101, 'content': 'function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': "{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeIncreaseAllowance', 'start_line': 2604, 'end_line': 2607, 'offset_start': 100293, 'offset_end': 100528, 'content': 'function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': "{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safeDecreaseAllowance', 'start_line': 2613, 'end_line': 2621, 'offset_start': 100732, 'offset_end': 101210, 'content': 'function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': "{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.forceApprove', 'start_line': 2628, 'end_line': 2635, 'offset_start': 101530, 'offset_end': 101920, 'content': 'function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': "{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable.safePermit', 'start_line': 2641, 'end_line': 2657, 'offset_start': 102073, 'offset_end': 102586, 'content': 'function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }', 'contract_name': 'SafeERC20Upgradeable', 'contract_code': "{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable._callOptionalReturn', 'start_line': 2665, 'end_line': 2674, 'offset_start': 102970, 'offset_end': 103609, 'content': "function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }", 'contract_name': 'SafeERC20Upgradeable', 'contract_code': "{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20Upgradeable._callOptionalReturnBool', 'start_line': 2684, 'end_line': 2691, 'offset_start': 104111, 'offset_end': 104699, 'content': "function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }", 'contract_name': 'SafeERC20Upgradeable', 'contract_code': "{\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        if (nonceAfter != nonceBefore + 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'PoolAddress.getPoolKey', 'start_line': 2713, 'end_line': 2720, 'offset_start': 105476, 'offset_end': 105749, 'content': 'function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }', 'contract_name': 'PoolAddress', 'contract_code': "{\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        bytes32 pubKey = \n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                );\n        // bytes32 to address:\n        assembly {\n            mstore(0x0, pubKey)\n            pool := mload(0x0)\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
{'type': 'FunctionDefinition', 'name': 'PoolAddress.computeAddress', 'start_line': 2726, 'end_line': 2742, 'offset_start': 105997, 'offset_end': 106588, 'content': "function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        bytes32 pubKey = \n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                );\n        // bytes32 to address:\n        assembly {\n            mstore(0x0, pubKey)\n            pool := mload(0x0)\n        }\n    }", 'contract_name': 'PoolAddress', 'contract_code': "{\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        bytes32 pubKey = \n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                );\n        // bytes32 to address:\n        assembly {\n            mstore(0x0, pubKey)\n            pool := mload(0x0)\n        }\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x4313c378cc91ea583c91387b9216e2c03096b27f/0x4313c378cc91ea583c91387b9216e2c03096b27f.sol'}
