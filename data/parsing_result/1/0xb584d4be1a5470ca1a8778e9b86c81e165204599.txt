{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 17, 'end_line': 19, 'offset_start': 640, 'offset_end': 735, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 21, 'end_line': 23, 'offset_start': 742, 'offset_end': 840, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable.tor', 'start_line': 58, 'end_line': 60, 'offset_start': 1802, 'offset_end': 1847, 'content': 'constructor() {\n        _paused = false;\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), "Pausable: paused");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), "Pausable: not paused");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable.paused', 'start_line': 65, 'end_line': 67, 'offset_start': 1943, 'offset_end': 2026, 'content': 'function paused() public view virtual returns (bool) {\n        return _paused;\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), "Pausable: paused");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), "Pausable: not paused");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._pause', 'start_line': 100, 'end_line': 103, 'offset_start': 2708, 'offset_end': 2822, 'content': 'function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), "Pausable: paused");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), "Pausable: not paused");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._unpause', 'start_line': 112, 'end_line': 115, 'offset_start': 2955, 'offset_end': 3071, 'content': 'function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), "Pausable: paused");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), "Pausable: not paused");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.tor', 'start_line': 161, 'end_line': 163, 'offset_start': 4103, 'offset_end': 4161, 'content': 'constructor() {\n        _grantSenderRole(msg.sender);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.', 'start_line': 165, 'end_line': 167, 'offset_start': 4168, 'offset_end': 4247, 'content': 'receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.depositNativeToken', 'start_line': 169, 'end_line': 180, 'offset_start': 4254, 'offset_end': 4570, 'content': 'function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.withdrawBalance', 'start_line': 182, 'end_line': 184, 'offset_start': 4577, 'offset_end': 4695, 'content': 'function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.withdrawFullBalance', 'start_line': 186, 'end_line': 188, 'offset_start': 4702, 'offset_end': 4821, 'content': 'function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr._withdrawBalance', 'start_line': 190, 'end_line': 195, 'offset_start': 4828, 'offset_end': 5045, 'content': 'function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.setIsEnabled', 'start_line': 197, 'end_line': 204, 'offset_start': 5052, 'offset_end': 5274, 'content': 'function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.setPause', 'start_line': 206, 'end_line': 209, 'offset_start': 5281, 'offset_end': 5382, 'content': 'function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.setUnPause', 'start_line': 211, 'end_line': 214, 'offset_start': 5389, 'offset_end': 5494, 'content': 'function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.addRoutes', 'start_line': 216, 'end_line': 220, 'offset_start': 5501, 'offset_end': 5698, 'content': 'function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.getChainData', 'start_line': 222, 'end_line': 228, 'offset_start': 5705, 'offset_end': 5856, 'content': 'function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.batchSendNativeToken', 'start_line': 230, 'end_line': 258, 'offset_start': 5863, 'offset_end': 6776, 'content': 'function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.sendNativeToken', 'start_line': 260, 'end_line': 276, 'offset_start': 6783, 'offset_end': 7303, 'content': 'function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr._sendNativeToken', 'start_line': 278, 'end_line': 293, 'offset_start': 7310, 'offset_end': 7805, 'content': 'function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.grantSenderRole', 'start_line': 295, 'end_line': 297, 'offset_start': 7812, 'offset_end': 7910, 'content': 'function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr.revokeSenderRole', 'start_line': 299, 'end_line': 301, 'offset_start': 7917, 'offset_end': 8017, 'content': 'function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr._grantSenderRole', 'start_line': 303, 'end_line': 306, 'offset_start': 8024, 'offset_end': 8146, 'content': 'function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'GasMovr._revokeSenderRole', 'start_line': 308, 'end_line': 311, 'offset_start': 8153, 'offset_end': 8278, 'content': 'function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }', 'contract_name': 'GasMovr', 'contract_code': '{\n    /* \n        Variables\n    */\n    mapping(uint256 => ChainData) public chainConfig;\n    mapping(bytes32 => bool) public processedHashes;\n    mapping(address => bool) public senders;\n\n    struct ChainData {\n        uint256 chainId;\n        bool isEnabled;\n    }\n\n    /* \n        Events\n    */\n    event Deposit(\n        address indexed destinationReceiver,\n        uint256 amount,\n        uint256 indexed destinationChainId\n    );\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    event Donation(address sender, uint256 amount);\n\n    event Send(address receiver, uint256 amount, bytes32 srcChainTxHash);\n\n    event GrantSender(address sender);\n    event RevokeSender(address sender);\n\n    modifier onlySender() {\n        require(senders[msg.sender], "Sender role required");\n        _;\n    }\n\n    constructor() {\n        _grantSenderRole(msg.sender);\n    }\n\n    receive() external payable {\n        emit Donation(msg.sender, msg.value);\n    }\n\n    function depositNativeToken(uint256 destinationChainId, address _to)\n        public\n        payable\n        whenNotPaused\n    {\n        require(\n            chainConfig[destinationChainId].isEnabled,\n            "Chain is currently disabled"\n        );\n\n        emit Deposit(_to, msg.value, destinationChainId);\n    }\n\n    function withdrawBalance(address _to, uint256 _amount) public onlyOwner {\n        _withdrawBalance(_to, _amount);\n    }\n\n    function withdrawFullBalance(address _to) public onlyOwner {\n        _withdrawBalance(_to, address(this).balance);\n    }\n\n    function _withdrawBalance(address _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n\n        emit Withdrawal(_to, _amount);\n    }\n\n    function setIsEnabled(uint256 chainId, bool _isEnabled)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        chainConfig[chainId].isEnabled = _isEnabled;\n        return chainConfig[chainId].isEnabled;\n    }\n\n    function setPause() public onlyOwner returns (bool) {\n        _pause();\n        return paused();\n    }\n\n    function setUnPause() public onlyOwner returns (bool) {\n        _unpause();\n        return paused();\n    }\n\n    function addRoutes(ChainData[] calldata _routes) external onlyOwner {\n        for (uint256 i = 0; i < _routes.length; i++) {\n            chainConfig[_routes[i].chainId] = _routes[i];\n        }\n    }\n\n    function getChainData(uint256 chainId)\n        public\n        view\n        returns (ChainData memory)\n    {\n        return (chainConfig[chainId]);\n    }\n\n    function batchSendNativeToken(\n        address payable[] memory receivers,\n        uint256[] memory amounts,\n        bytes32[] memory srcChainTxHashes,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        require(\n            receivers.length == amounts.length &&\n                receivers.length == srcChainTxHashes.length,\n            "Input length mismatch"\n        );\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint256 _gasFees = amounts[i] > maxLimit\n                ? (amounts[i] - maxLimit + (gasPrice * perUserGasAmount))\n                : gasPrice * perUserGasAmount;\n            _sendNativeToken(\n                receivers[i],\n                amounts[i],\n                srcChainTxHashes[i],\n                _gasFees\n            );\n        }\n    }\n\n    function sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 perUserGasAmount,\n        uint256 maxLimit\n    ) public onlySender {\n        uint256 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        uint256 _gasFees = amount > maxLimit\n            ? (amount - maxLimit + (gasPrice * perUserGasAmount))\n            : gasPrice * perUserGasAmount;\n\n        _sendNativeToken(receiver, amount, srcChainTxHash, _gasFees);\n    }\n\n    function _sendNativeToken(\n        address payable receiver,\n        uint256 amount,\n        bytes32 srcChainTxHash,\n        uint256 gasFees\n    ) private {\n        if (processedHashes[srcChainTxHash]) return;\n        processedHashes[srcChainTxHash] = true;\n\n        uint256 sendAmount = amount - gasFees;\n\n        emit Send(receiver, sendAmount, srcChainTxHash);\n\n        (bool success, ) = receiver.call{value: sendAmount, gas: 5000}("");\n        require(success, "Failed to send Ether");\n    }\n\n    function grantSenderRole(address sender) public onlyOwner {\n        _grantSenderRole(sender);\n    }\n\n    function revokeSenderRole(address sender) public onlyOwner {\n        _revokeSenderRole(sender);\n    }\n\n    function _grantSenderRole(address sender) private {\n        senders[sender] = true;\n        emit GrantSender(sender);\n    }\n\n    function _revokeSenderRole(address sender) private {\n        senders[sender] = false;\n        emit RevokeSender(sender);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 341, 'end_line': 343, 'offset_start': 9180, 'offset_end': 9242, 'content': 'constructor() {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 348, 'end_line': 350, 'offset_start': 9319, 'offset_end': 9403, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 367, 'end_line': 369, 'offset_start': 9951, 'offset_end': 10051, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 375, 'end_line': 378, 'offset_start': 10201, 'offset_end': 10398, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 384, 'end_line': 388, 'offset_start': 10553, 'offset_end': 10739, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/data/code/1/0xb584d4be1a5470ca1a8778e9b86c81e165204599/0xb584d4be1a5470ca1a8778e9b86c81e165204599.sol'}
