{'type': 'FunctionDefinition', 'name': 'UncheckedMath.uncheckedInc', 'start_line': 11, 'end_line': 15, 'offset_start': 212, 'offset_end': 351, 'content': 'function uncheckedInc(uint256 _number) internal pure returns (uint256) {\n        unchecked {\n            return _number + 1;\n        }\n    }', 'contract_name': 'UncheckedMath', 'contract_code': '{\n    function uncheckedInc(uint256 _number) internal pure returns (uint256) {\n        unchecked {\n            return _number + 1;\n        }\n    }\n\n    function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {\n        unchecked {\n            return _lhs + _rhs;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'UncheckedMath.uncheckedAdd', 'start_line': 17, 'end_line': 21, 'offset_start': 358, 'offset_end': 508, 'content': 'function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {\n        unchecked {\n            return _lhs + _rhs;\n        }\n    }', 'contract_name': 'UncheckedMath', 'contract_code': '{\n    function uncheckedInc(uint256 _number) internal pure returns (uint256) {\n        unchecked {\n            return _number + 1;\n        }\n    }\n\n    function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {\n        unchecked {\n            return _lhs + _rhs;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.proveL2MessageInclusion', 'start_line': 41, 'end_line': 46, 'offset_start': 1576, 'offset_end': 1769, 'content': 'function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);', 'contract_name': 'IMailbox', 'contract_code': "{\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    /// @notice transfer Eth to shared bridge as part of migration process\n    function transferEthToSharedBridge() external;\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data.\n    /// Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationTimestamp,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.proveL2LogInclusion', 'start_line': 54, 'end_line': 59, 'offset_start': 2202, 'offset_end': 2381, 'content': 'function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);', 'contract_name': 'IMailbox', 'contract_code': "{\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    /// @notice transfer Eth to shared bridge as part of migration process\n    function transferEthToSharedBridge() external;\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data.\n    /// Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationTimestamp,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.proveL1ToL2TransactionStatus', 'start_line': 70, 'end_line': 77, 'offset_start': 3264, 'offset_end': 3530, 'content': 'function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);', 'contract_name': 'IMailbox', 'contract_code': "{\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    /// @notice transfer Eth to shared bridge as part of migration process\n    function transferEthToSharedBridge() external;\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data.\n    /// Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationTimestamp,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.finalizeEthWithdrawal', 'start_line': 85, 'end_line': 91, 'offset_start': 4080, 'offset_end': 4299, 'content': 'function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;', 'contract_name': 'IMailbox', 'contract_code': "{\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    /// @notice transfer Eth to shared bridge as part of migration process\n    function transferEthToSharedBridge() external;\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data.\n    /// Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationTimestamp,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.requestL2Transaction', 'start_line': 111, 'end_line': 119, 'offset_start': 6230, 'offset_end': 6550, 'content': 'function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);', 'contract_name': 'IMailbox', 'contract_code': "{\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    /// @notice transfer Eth to shared bridge as part of migration process\n    function transferEthToSharedBridge() external;\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data.\n    /// Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationTimestamp,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n}", 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.bridgehubRequestL2Transaction', 'start_line': 121, 'end_line': 123, 'offset_start': 6557, 'offset_end': 6701, 'content': 'function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);', 'contract_name': 'IMailbox', 'contract_code': "{\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    /// @notice transfer Eth to shared bridge as part of migration process\n    function transferEthToSharedBridge() external;\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data.\n    /// Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationTimestamp,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.l2TransactionBaseCost', 'start_line': 130, 'end_line': 134, 'offset_start': 7217, 'offset_end': 7384, 'content': 'function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);', 'contract_name': 'IMailbox', 'contract_code': "{\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    /// @notice transfer Eth to shared bridge as part of migration process\n    function transferEthToSharedBridge() external;\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data.\n    /// Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationTimestamp,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IMailbox.transferEthToSharedBridge', 'start_line': 137, 'end_line': 137, 'offset_start': 7466, 'offset_end': 7511, 'content': 'function transferEthToSharedBridge() external;', 'contract_name': 'IMailbox', 'contract_code': "{\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external returns (bytes32 canonicalTxHash);\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    /// @notice transfer Eth to shared bridge as part of migration process\n    function transferEthToSharedBridge() external;\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationTimestamp Timestamp up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data.\n    /// Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationTimestamp,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressAliasHelper.applyL1ToL2Alias', 'start_line': 182, 'end_line': 186, 'offset_start': 9331, 'offset_end': 9516, 'content': 'function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }', 'contract_name': 'AddressAliasHelper', 'contract_code': '{\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function converts the address that submitted a tx\n    /// to the inbox on L1 to the msg.sender viewed on L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed on L2 to the\n    /// address that submitted a tx to the inbox on L1\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n\n    /// @notice Utility function used to calculate the correct refund recipient\n    /// @param _refundRecipient the address that should receive the refund\n    /// @param _prevMsgSender the address that triggered the tx to L2\n    /// @return _recipient the corrected address that should receive the refund\n    function actualRefundRecipient(\n        address _refundRecipient,\n        address _prevMsgSender\n    ) internal view returns (address _recipient) {\n        if (_refundRecipient == address(0)) {\n            // If the `_refundRecipient` is not provided, we use the `_prevMsgSender` as the recipient.\n            // slither-disable-next-line tx-origin\n            _recipient = _prevMsgSender == tx.origin\n                ? _prevMsgSender\n                : AddressAliasHelper.applyL1ToL2Alias(_prevMsgSender);\n        } else if (_refundRecipient.code.length > 0) {\n            // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n            _recipient = AddressAliasHelper.applyL1ToL2Alias(_refundRecipient);\n        } else {\n            _recipient = _refundRecipient;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressAliasHelper.undoL1ToL2Alias', 'start_line': 192, 'end_line': 196, 'offset_start': 9796, 'offset_end': 9980, 'content': 'function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }', 'contract_name': 'AddressAliasHelper', 'contract_code': '{\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function converts the address that submitted a tx\n    /// to the inbox on L1 to the msg.sender viewed on L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed on L2 to the\n    /// address that submitted a tx to the inbox on L1\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n\n    /// @notice Utility function used to calculate the correct refund recipient\n    /// @param _refundRecipient the address that should receive the refund\n    /// @param _prevMsgSender the address that triggered the tx to L2\n    /// @return _recipient the corrected address that should receive the refund\n    function actualRefundRecipient(\n        address _refundRecipient,\n        address _prevMsgSender\n    ) internal view returns (address _recipient) {\n        if (_refundRecipient == address(0)) {\n            // If the `_refundRecipient` is not provided, we use the `_prevMsgSender` as the recipient.\n            // slither-disable-next-line tx-origin\n            _recipient = _prevMsgSender == tx.origin\n                ? _prevMsgSender\n                : AddressAliasHelper.applyL1ToL2Alias(_prevMsgSender);\n        } else if (_refundRecipient.code.length > 0) {\n            // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n            _recipient = AddressAliasHelper.applyL1ToL2Alias(_refundRecipient);\n        } else {\n            _recipient = _refundRecipient;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressAliasHelper.actualRefundRecipient', 'start_line': 202, 'end_line': 218, 'offset_start': 10292, 'offset_end': 11119, 'content': 'function actualRefundRecipient(\n        address _refundRecipient,\n        address _prevMsgSender\n    ) internal view returns (address _recipient) {\n        if (_refundRecipient == address(0)) {\n            // If the `_refundRecipient` is not provided, we use the `_prevMsgSender` as the recipient.\n            // slither-disable-next-line tx-origin\n            _recipient = _prevMsgSender == tx.origin\n                ? _prevMsgSender\n                : AddressAliasHelper.applyL1ToL2Alias(_prevMsgSender);\n        } else if (_refundRecipient.code.length > 0) {\n            // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n            _recipient = AddressAliasHelper.applyL1ToL2Alias(_refundRecipient);\n        } else {\n            _recipient = _refundRecipient;\n        }\n    }', 'contract_name': 'AddressAliasHelper', 'contract_code': '{\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function converts the address that submitted a tx\n    /// to the inbox on L1 to the msg.sender viewed on L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed on L2 to the\n    /// address that submitted a tx to the inbox on L1\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n\n    /// @notice Utility function used to calculate the correct refund recipient\n    /// @param _refundRecipient the address that should receive the refund\n    /// @param _prevMsgSender the address that triggered the tx to L2\n    /// @return _recipient the corrected address that should receive the refund\n    function actualRefundRecipient(\n        address _refundRecipient,\n        address _prevMsgSender\n    ) internal view returns (address _recipient) {\n        if (_refundRecipient == address(0)) {\n            // If the `_refundRecipient` is not provided, we use the `_prevMsgSender` as the recipient.\n            // slither-disable-next-line tx-origin\n            _recipient = _prevMsgSender == tx.origin\n                ? _prevMsgSender\n                : AddressAliasHelper.applyL1ToL2Alias(_prevMsgSender);\n        } else if (_refundRecipient.code.length > 0) {\n            // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n            _recipient = AddressAliasHelper.applyL1ToL2Alias(_refundRecipient);\n        } else {\n            _recipient = _refundRecipient;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IVerifier.verify', 'start_line': 239, 'end_line': 243, 'offset_start': 11810, 'offset_end': 11992, 'content': 'function verify(\n        uint256[] calldata _publicInputs,\n        uint256[] calldata _proof,\n        uint256[] calldata _recursiveAggregationInput\n    ) external view returns (bool);', 'contract_name': 'IVerifier', 'contract_code': '{\n    /// @dev Verifies a zk-SNARK proof.\n    /// @return A boolean value indicating whether the zk-SNARK proof is valid.\n    /// Note: The function may revert execution instead of returning false in some cases.\n    function verify(\n        uint256[] calldata _publicInputs,\n        uint256[] calldata _proof,\n        uint256[] calldata _recursiveAggregationInput\n    ) external view returns (bool);\n\n    /// @notice Calculates a keccak256 hash of the runtime loaded verification keys.\n    /// @return vkHash The keccak256 hash of the loaded verification keys.\n    function verificationKeyHash() external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IVerifier.verificationKeyHash', 'start_line': 247, 'end_line': 247, 'offset_start': 12159, 'offset_end': 12221, 'content': 'function verificationKeyHash() external pure returns (bytes32);', 'contract_name': 'IVerifier', 'contract_code': '{\n    /// @dev Verifies a zk-SNARK proof.\n    /// @return A boolean value indicating whether the zk-SNARK proof is valid.\n    /// Note: The function may revert execution instead of returning false in some cases.\n    function verify(\n        uint256[] calldata _publicInputs,\n        uint256[] calldata _proof,\n        uint256[] calldata _recursiveAggregationInput\n    ) external view returns (bool);\n\n    /// @notice Calculates a keccak256 hash of the runtime loaded verification keys.\n    /// @return vkHash The keccak256 hash of the loaded verification keys.\n    function verificationKeyHash() external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.isWithdrawalFinalized', 'start_line': 331, 'end_line': 331, 'offset_start': 14769, 'offset_end': 14877, 'content': 'function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.deposit', 'start_line': 333, 'end_line': 340, 'offset_start': 14884, 'offset_end': 15133, 'content': 'function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.deposit', 'start_line': 342, 'end_line': 348, 'offset_start': 15140, 'offset_end': 15355, 'content': 'function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.claimFailedDeposit', 'start_line': 350, 'end_line': 358, 'offset_start': 15362, 'offset_end': 15630, 'content': 'function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.finalizeWithdrawal', 'start_line': 360, 'end_line': 366, 'offset_start': 15637, 'offset_end': 15853, 'content': 'function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.l2TokenAddress', 'start_line': 368, 'end_line': 368, 'offset_start': 15860, 'offset_end': 15933, 'content': 'function l2TokenAddress(address _l1Token) external view returns (address);', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.SHARED_BRIDGE', 'start_line': 370, 'end_line': 370, 'offset_start': 15940, 'offset_end': 16004, 'content': 'function SHARED_BRIDGE() external view returns (IL1SharedBridge);', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.l2TokenBeacon', 'start_line': 372, 'end_line': 372, 'offset_start': 16011, 'offset_end': 16067, 'content': 'function l2TokenBeacon() external view returns (address);', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.l2Bridge', 'start_line': 374, 'end_line': 374, 'offset_start': 16074, 'offset_end': 16125, 'content': 'function l2Bridge() external view returns (address);', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.depositAmount', 'start_line': 376, 'end_line': 380, 'offset_start': 16132, 'offset_end': 16280, 'content': 'function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1ERC20Bridge.transferTokenToSharedBridge', 'start_line': 382, 'end_line': 382, 'offset_start': 16287, 'offset_end': 16348, 'content': 'function transferTokenToSharedBridge(address _token) external;', 'contract_name': 'IL1ERC20Bridge', 'contract_code': '{\n    event DepositInitiated(\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address indexed to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event WithdrawalFinalized(address indexed to, address indexed l1Token, uint256 amount);\n\n    event ClaimedFailedDeposit(address indexed to, address indexed l1Token, uint256 amount);\n\n    function isWithdrawalFinalized(uint256 _l2BatchNumber, uint256 _l2MessageIndex) external view returns (bool);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function l2TokenAddress(address _l1Token) external view returns (address);\n\n    function SHARED_BRIDGE() external view returns (IL1SharedBridge);\n\n    function l2TokenBeacon() external view returns (address);\n\n    function l2Bridge() external view returns (address);\n\n    function depositAmount(\n        address _account,\n        address _l1Token,\n        bytes32 _depositL2TxHash\n    ) external returns (uint256 amount);\n\n    function transferTokenToSharedBridge(address _token) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'TransactionValidator.validateL1ToL2Transaction', 'start_line': 403, 'end_line': 426, 'offset_start': 17371, 'offset_end': 18428, 'content': 'function validateL1ToL2Transaction(\n        L2CanonicalTransaction memory _transaction,\n        bytes memory _encoded,\n        uint256 _priorityTxMaxGasLimit,\n        uint256 _priorityTxMaxPubdata\n    ) internal pure {\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(_transaction.gasLimit, _encoded.length);\n\n        // Ensuring that the transaction is provable\n        require(l2GasForTxBody <= _priorityTxMaxGasLimit, "ui");\n        // Ensuring that the transaction cannot output more pubdata than is processable\n        require(l2GasForTxBody / _transaction.gasPerPubdataByteLimit <= _priorityTxMaxPubdata, "uk");\n\n        // Ensuring that the transaction covers the minimal costs for its processing:\n        // hashing its content, publishing the factory dependencies, etc.\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= l2GasForTxBody,\n            "up"\n        );\n    }', 'contract_name': 'TransactionValidator', 'contract_code': '{\n    /// @dev Used to validate key properties of an L1->L2 transaction\n    /// @param _transaction The transaction to validate\n    /// @param _encoded The abi encoded bytes of the transaction\n    /// @param _priorityTxMaxGasLimit The max gas limit, generally provided from Storage.sol\n    /// @param _priorityTxMaxPubdata The maximal amount of pubdata that a single L1->L2 transaction can emit\n    function validateL1ToL2Transaction(\n        L2CanonicalTransaction memory _transaction,\n        bytes memory _encoded,\n        uint256 _priorityTxMaxGasLimit,\n        uint256 _priorityTxMaxPubdata\n    ) internal pure {\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(_transaction.gasLimit, _encoded.length);\n\n        // Ensuring that the transaction is provable\n        require(l2GasForTxBody <= _priorityTxMaxGasLimit, "ui");\n        // Ensuring that the transaction cannot output more pubdata than is processable\n        require(l2GasForTxBody / _transaction.gasPerPubdataByteLimit <= _priorityTxMaxPubdata, "uk");\n\n        // Ensuring that the transaction covers the minimal costs for its processing:\n        // hashing its content, publishing the factory dependencies, etc.\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= l2GasForTxBody,\n            "up"\n        );\n    }\n\n    /// @dev Used to validate upgrade transactions\n    /// @param _transaction The transaction to validate\n    function validateUpgradeTransaction(L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, "ua");\n        require(_transaction.to <= type(uint160).max, "ub");\n        require(_transaction.paymaster == 0, "uc");\n        require(_transaction.value == 0, "ud");\n        require(_transaction.maxFeePerGas == 0, "uq");\n        require(_transaction.maxPriorityFeePerGas == 0, "ux");\n        require(_transaction.reserved[0] == 0, "ue");\n        require(_transaction.reserved[1] <= type(uint160).max, "uf");\n        require(_transaction.reserved[2] == 0, "ug");\n        require(_transaction.reserved[3] == 0, "uo");\n        require(_transaction.signature.length == 0, "uh");\n        require(_transaction.paymasterInput.length == 0, "ul1");\n        require(_transaction.reservedDynamic.length == 0, "um");\n    }\n\n    /// @dev Calculates the approximate minimum gas limit required for executing a priority transaction.\n    /// @param _encodingLength The length of the priority transaction encoding in bytes.\n    /// @param _numberOfFactoryDependencies The number of new factory dependencies that will be added.\n    /// @param _l2GasPricePerPubdata The L2 gas price for publishing the priority transaction on L2.\n    /// @return The minimum gas limit required to execute the priority transaction.\n    /// Note: The calculation includes the main cost of the priority transaction, however, in reality, the operator can spend a little more gas on overheads.\n    function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        uint256 costForComputation;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForComputation = L1_TX_INTRINSIC_L2_GAS;\n\n            // Taking into account the hashing costs that depend on the length of the transaction\n            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n            // the transaction\'s encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n            // and the size of each new encoding word).\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n\n            // There is a minimal amount of computational L2 gas that the transaction should cover\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n        }\n\n        uint256 costForPubdata = 0;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n        }\n\n        return costForComputation + costForPubdata;\n    }\n\n    /// @notice Based on the full L2 gas limit (that includes the batch overhead) and other\n    /// properties of the transaction, returns the l2GasLimit for the body of the transaction (the actual execution).\n    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the batch\n    /// and the L2 gas needed to process the transaction itself (i.e. the actual l2GasLimit that will be used for the transaction).\n    /// @param _encodingLength The length of the ABI-encoding of the transaction.\n    function getTransactionBodyGasLimit(\n        uint256 _totalGasLimit,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 txBodyGasLimit) {\n        uint256 overhead = getOverheadForTransaction(_encodingLength);\n\n        require(_totalGasLimit >= overhead, "my"); // provided gas limit doesn\'t cover transaction overhead\n        unchecked {\n            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.\n            txBodyGasLimit = _totalGasLimit - overhead;\n        }\n    }\n\n    /// @notice Based on the total L2 gas limit and several other parameters of the transaction\n    /// returns the part of the L2 gas that will be spent on the batch\'s overhead.\n    /// @dev The details of how this function works can be checked in the documentation\n    /// of the fee model of zkSync. The appropriate comments are also present\n    /// in the Rust implementation description of function `get_maximal_allowed_overhead`.\n    /// @param _encodingLength The length of the binary encoding of the transaction in bytes\n    function getOverheadForTransaction(\n        uint256 _encodingLength\n    ) internal pure returns (uint256 batchOverheadForTransaction) {\n        // The overhead from taking up the transaction\'s slot\n        batchOverheadForTransaction = TX_SLOT_OVERHEAD_L2_GAS;\n\n        // The overhead for occupying the bootloader memory can be derived from encoded_len\n        uint256 overheadForLength = MEMORY_OVERHEAD_GAS * _encodingLength;\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'TransactionValidator.validateUpgradeTransaction', 'start_line': 430, 'end_line': 445, 'offset_start': 18542, 'offset_end': 19479, 'content': 'function validateUpgradeTransaction(L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, "ua");\n        require(_transaction.to <= type(uint160).max, "ub");\n        require(_transaction.paymaster == 0, "uc");\n        require(_transaction.value == 0, "ud");\n        require(_transaction.maxFeePerGas == 0, "uq");\n        require(_transaction.maxPriorityFeePerGas == 0, "ux");\n        require(_transaction.reserved[0] == 0, "ue");\n        require(_transaction.reserved[1] <= type(uint160).max, "uf");\n        require(_transaction.reserved[2] == 0, "ug");\n        require(_transaction.reserved[3] == 0, "uo");\n        require(_transaction.signature.length == 0, "uh");\n        require(_transaction.paymasterInput.length == 0, "ul1");\n        require(_transaction.reservedDynamic.length == 0, "um");\n    }', 'contract_name': 'TransactionValidator', 'contract_code': '{\n    /// @dev Used to validate key properties of an L1->L2 transaction\n    /// @param _transaction The transaction to validate\n    /// @param _encoded The abi encoded bytes of the transaction\n    /// @param _priorityTxMaxGasLimit The max gas limit, generally provided from Storage.sol\n    /// @param _priorityTxMaxPubdata The maximal amount of pubdata that a single L1->L2 transaction can emit\n    function validateL1ToL2Transaction(\n        L2CanonicalTransaction memory _transaction,\n        bytes memory _encoded,\n        uint256 _priorityTxMaxGasLimit,\n        uint256 _priorityTxMaxPubdata\n    ) internal pure {\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(_transaction.gasLimit, _encoded.length);\n\n        // Ensuring that the transaction is provable\n        require(l2GasForTxBody <= _priorityTxMaxGasLimit, "ui");\n        // Ensuring that the transaction cannot output more pubdata than is processable\n        require(l2GasForTxBody / _transaction.gasPerPubdataByteLimit <= _priorityTxMaxPubdata, "uk");\n\n        // Ensuring that the transaction covers the minimal costs for its processing:\n        // hashing its content, publishing the factory dependencies, etc.\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= l2GasForTxBody,\n            "up"\n        );\n    }\n\n    /// @dev Used to validate upgrade transactions\n    /// @param _transaction The transaction to validate\n    function validateUpgradeTransaction(L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, "ua");\n        require(_transaction.to <= type(uint160).max, "ub");\n        require(_transaction.paymaster == 0, "uc");\n        require(_transaction.value == 0, "ud");\n        require(_transaction.maxFeePerGas == 0, "uq");\n        require(_transaction.maxPriorityFeePerGas == 0, "ux");\n        require(_transaction.reserved[0] == 0, "ue");\n        require(_transaction.reserved[1] <= type(uint160).max, "uf");\n        require(_transaction.reserved[2] == 0, "ug");\n        require(_transaction.reserved[3] == 0, "uo");\n        require(_transaction.signature.length == 0, "uh");\n        require(_transaction.paymasterInput.length == 0, "ul1");\n        require(_transaction.reservedDynamic.length == 0, "um");\n    }\n\n    /// @dev Calculates the approximate minimum gas limit required for executing a priority transaction.\n    /// @param _encodingLength The length of the priority transaction encoding in bytes.\n    /// @param _numberOfFactoryDependencies The number of new factory dependencies that will be added.\n    /// @param _l2GasPricePerPubdata The L2 gas price for publishing the priority transaction on L2.\n    /// @return The minimum gas limit required to execute the priority transaction.\n    /// Note: The calculation includes the main cost of the priority transaction, however, in reality, the operator can spend a little more gas on overheads.\n    function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        uint256 costForComputation;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForComputation = L1_TX_INTRINSIC_L2_GAS;\n\n            // Taking into account the hashing costs that depend on the length of the transaction\n            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n            // the transaction\'s encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n            // and the size of each new encoding word).\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n\n            // There is a minimal amount of computational L2 gas that the transaction should cover\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n        }\n\n        uint256 costForPubdata = 0;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n        }\n\n        return costForComputation + costForPubdata;\n    }\n\n    /// @notice Based on the full L2 gas limit (that includes the batch overhead) and other\n    /// properties of the transaction, returns the l2GasLimit for the body of the transaction (the actual execution).\n    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the batch\n    /// and the L2 gas needed to process the transaction itself (i.e. the actual l2GasLimit that will be used for the transaction).\n    /// @param _encodingLength The length of the ABI-encoding of the transaction.\n    function getTransactionBodyGasLimit(\n        uint256 _totalGasLimit,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 txBodyGasLimit) {\n        uint256 overhead = getOverheadForTransaction(_encodingLength);\n\n        require(_totalGasLimit >= overhead, "my"); // provided gas limit doesn\'t cover transaction overhead\n        unchecked {\n            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.\n            txBodyGasLimit = _totalGasLimit - overhead;\n        }\n    }\n\n    /// @notice Based on the total L2 gas limit and several other parameters of the transaction\n    /// returns the part of the L2 gas that will be spent on the batch\'s overhead.\n    /// @dev The details of how this function works can be checked in the documentation\n    /// of the fee model of zkSync. The appropriate comments are also present\n    /// in the Rust implementation description of function `get_maximal_allowed_overhead`.\n    /// @param _encodingLength The length of the binary encoding of the transaction in bytes\n    function getOverheadForTransaction(\n        uint256 _encodingLength\n    ) internal pure returns (uint256 batchOverheadForTransaction) {\n        // The overhead from taking up the transaction\'s slot\n        batchOverheadForTransaction = TX_SLOT_OVERHEAD_L2_GAS;\n\n        // The overhead for occupying the bootloader memory can be derived from encoded_len\n        uint256 overheadForLength = MEMORY_OVERHEAD_GAS * _encodingLength;\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'TransactionValidator.getMinimalPriorityTransactionGasLimit', 'start_line': 453, 'end_line': 486, 'offset_start': 20126, 'offset_end': 21960, 'content': "function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        uint256 costForComputation;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForComputation = L1_TX_INTRINSIC_L2_GAS;\n\n            // Taking into account the hashing costs that depend on the length of the transaction\n            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n            // the transaction's encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n            // and the size of each new encoding word).\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n\n            // There is a minimal amount of computational L2 gas that the transaction should cover\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n        }\n\n        uint256 costForPubdata = 0;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n        }\n\n        return costForComputation + costForPubdata;\n    }", 'contract_name': 'TransactionValidator', 'contract_code': '{\n    /// @dev Used to validate key properties of an L1->L2 transaction\n    /// @param _transaction The transaction to validate\n    /// @param _encoded The abi encoded bytes of the transaction\n    /// @param _priorityTxMaxGasLimit The max gas limit, generally provided from Storage.sol\n    /// @param _priorityTxMaxPubdata The maximal amount of pubdata that a single L1->L2 transaction can emit\n    function validateL1ToL2Transaction(\n        L2CanonicalTransaction memory _transaction,\n        bytes memory _encoded,\n        uint256 _priorityTxMaxGasLimit,\n        uint256 _priorityTxMaxPubdata\n    ) internal pure {\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(_transaction.gasLimit, _encoded.length);\n\n        // Ensuring that the transaction is provable\n        require(l2GasForTxBody <= _priorityTxMaxGasLimit, "ui");\n        // Ensuring that the transaction cannot output more pubdata than is processable\n        require(l2GasForTxBody / _transaction.gasPerPubdataByteLimit <= _priorityTxMaxPubdata, "uk");\n\n        // Ensuring that the transaction covers the minimal costs for its processing:\n        // hashing its content, publishing the factory dependencies, etc.\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= l2GasForTxBody,\n            "up"\n        );\n    }\n\n    /// @dev Used to validate upgrade transactions\n    /// @param _transaction The transaction to validate\n    function validateUpgradeTransaction(L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, "ua");\n        require(_transaction.to <= type(uint160).max, "ub");\n        require(_transaction.paymaster == 0, "uc");\n        require(_transaction.value == 0, "ud");\n        require(_transaction.maxFeePerGas == 0, "uq");\n        require(_transaction.maxPriorityFeePerGas == 0, "ux");\n        require(_transaction.reserved[0] == 0, "ue");\n        require(_transaction.reserved[1] <= type(uint160).max, "uf");\n        require(_transaction.reserved[2] == 0, "ug");\n        require(_transaction.reserved[3] == 0, "uo");\n        require(_transaction.signature.length == 0, "uh");\n        require(_transaction.paymasterInput.length == 0, "ul1");\n        require(_transaction.reservedDynamic.length == 0, "um");\n    }\n\n    /// @dev Calculates the approximate minimum gas limit required for executing a priority transaction.\n    /// @param _encodingLength The length of the priority transaction encoding in bytes.\n    /// @param _numberOfFactoryDependencies The number of new factory dependencies that will be added.\n    /// @param _l2GasPricePerPubdata The L2 gas price for publishing the priority transaction on L2.\n    /// @return The minimum gas limit required to execute the priority transaction.\n    /// Note: The calculation includes the main cost of the priority transaction, however, in reality, the operator can spend a little more gas on overheads.\n    function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        uint256 costForComputation;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForComputation = L1_TX_INTRINSIC_L2_GAS;\n\n            // Taking into account the hashing costs that depend on the length of the transaction\n            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n            // the transaction\'s encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n            // and the size of each new encoding word).\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n\n            // There is a minimal amount of computational L2 gas that the transaction should cover\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n        }\n\n        uint256 costForPubdata = 0;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n        }\n\n        return costForComputation + costForPubdata;\n    }\n\n    /// @notice Based on the full L2 gas limit (that includes the batch overhead) and other\n    /// properties of the transaction, returns the l2GasLimit for the body of the transaction (the actual execution).\n    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the batch\n    /// and the L2 gas needed to process the transaction itself (i.e. the actual l2GasLimit that will be used for the transaction).\n    /// @param _encodingLength The length of the ABI-encoding of the transaction.\n    function getTransactionBodyGasLimit(\n        uint256 _totalGasLimit,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 txBodyGasLimit) {\n        uint256 overhead = getOverheadForTransaction(_encodingLength);\n\n        require(_totalGasLimit >= overhead, "my"); // provided gas limit doesn\'t cover transaction overhead\n        unchecked {\n            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.\n            txBodyGasLimit = _totalGasLimit - overhead;\n        }\n    }\n\n    /// @notice Based on the total L2 gas limit and several other parameters of the transaction\n    /// returns the part of the L2 gas that will be spent on the batch\'s overhead.\n    /// @dev The details of how this function works can be checked in the documentation\n    /// of the fee model of zkSync. The appropriate comments are also present\n    /// in the Rust implementation description of function `get_maximal_allowed_overhead`.\n    /// @param _encodingLength The length of the binary encoding of the transaction in bytes\n    function getOverheadForTransaction(\n        uint256 _encodingLength\n    ) internal pure returns (uint256 batchOverheadForTransaction) {\n        // The overhead from taking up the transaction\'s slot\n        batchOverheadForTransaction = TX_SLOT_OVERHEAD_L2_GAS;\n\n        // The overhead for occupying the bootloader memory can be derived from encoded_len\n        uint256 overheadForLength = MEMORY_OVERHEAD_GAS * _encodingLength;\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'TransactionValidator.getTransactionBodyGasLimit', 'start_line': 493, 'end_line': 504, 'offset_start': 22495, 'offset_end': 23008, 'content': 'function getTransactionBodyGasLimit(\n        uint256 _totalGasLimit,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 txBodyGasLimit) {\n        uint256 overhead = getOverheadForTransaction(_encodingLength);\n\n        require(_totalGasLimit >= overhead, "my"); // provided gas limit doesn\'t cover transaction overhead\n        unchecked {\n            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.\n            txBodyGasLimit = _totalGasLimit - overhead;\n        }\n    }', 'contract_name': 'TransactionValidator', 'contract_code': '{\n    /// @dev Used to validate key properties of an L1->L2 transaction\n    /// @param _transaction The transaction to validate\n    /// @param _encoded The abi encoded bytes of the transaction\n    /// @param _priorityTxMaxGasLimit The max gas limit, generally provided from Storage.sol\n    /// @param _priorityTxMaxPubdata The maximal amount of pubdata that a single L1->L2 transaction can emit\n    function validateL1ToL2Transaction(\n        L2CanonicalTransaction memory _transaction,\n        bytes memory _encoded,\n        uint256 _priorityTxMaxGasLimit,\n        uint256 _priorityTxMaxPubdata\n    ) internal pure {\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(_transaction.gasLimit, _encoded.length);\n\n        // Ensuring that the transaction is provable\n        require(l2GasForTxBody <= _priorityTxMaxGasLimit, "ui");\n        // Ensuring that the transaction cannot output more pubdata than is processable\n        require(l2GasForTxBody / _transaction.gasPerPubdataByteLimit <= _priorityTxMaxPubdata, "uk");\n\n        // Ensuring that the transaction covers the minimal costs for its processing:\n        // hashing its content, publishing the factory dependencies, etc.\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= l2GasForTxBody,\n            "up"\n        );\n    }\n\n    /// @dev Used to validate upgrade transactions\n    /// @param _transaction The transaction to validate\n    function validateUpgradeTransaction(L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, "ua");\n        require(_transaction.to <= type(uint160).max, "ub");\n        require(_transaction.paymaster == 0, "uc");\n        require(_transaction.value == 0, "ud");\n        require(_transaction.maxFeePerGas == 0, "uq");\n        require(_transaction.maxPriorityFeePerGas == 0, "ux");\n        require(_transaction.reserved[0] == 0, "ue");\n        require(_transaction.reserved[1] <= type(uint160).max, "uf");\n        require(_transaction.reserved[2] == 0, "ug");\n        require(_transaction.reserved[3] == 0, "uo");\n        require(_transaction.signature.length == 0, "uh");\n        require(_transaction.paymasterInput.length == 0, "ul1");\n        require(_transaction.reservedDynamic.length == 0, "um");\n    }\n\n    /// @dev Calculates the approximate minimum gas limit required for executing a priority transaction.\n    /// @param _encodingLength The length of the priority transaction encoding in bytes.\n    /// @param _numberOfFactoryDependencies The number of new factory dependencies that will be added.\n    /// @param _l2GasPricePerPubdata The L2 gas price for publishing the priority transaction on L2.\n    /// @return The minimum gas limit required to execute the priority transaction.\n    /// Note: The calculation includes the main cost of the priority transaction, however, in reality, the operator can spend a little more gas on overheads.\n    function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        uint256 costForComputation;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForComputation = L1_TX_INTRINSIC_L2_GAS;\n\n            // Taking into account the hashing costs that depend on the length of the transaction\n            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n            // the transaction\'s encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n            // and the size of each new encoding word).\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n\n            // There is a minimal amount of computational L2 gas that the transaction should cover\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n        }\n\n        uint256 costForPubdata = 0;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n        }\n\n        return costForComputation + costForPubdata;\n    }\n\n    /// @notice Based on the full L2 gas limit (that includes the batch overhead) and other\n    /// properties of the transaction, returns the l2GasLimit for the body of the transaction (the actual execution).\n    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the batch\n    /// and the L2 gas needed to process the transaction itself (i.e. the actual l2GasLimit that will be used for the transaction).\n    /// @param _encodingLength The length of the ABI-encoding of the transaction.\n    function getTransactionBodyGasLimit(\n        uint256 _totalGasLimit,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 txBodyGasLimit) {\n        uint256 overhead = getOverheadForTransaction(_encodingLength);\n\n        require(_totalGasLimit >= overhead, "my"); // provided gas limit doesn\'t cover transaction overhead\n        unchecked {\n            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.\n            txBodyGasLimit = _totalGasLimit - overhead;\n        }\n    }\n\n    /// @notice Based on the total L2 gas limit and several other parameters of the transaction\n    /// returns the part of the L2 gas that will be spent on the batch\'s overhead.\n    /// @dev The details of how this function works can be checked in the documentation\n    /// of the fee model of zkSync. The appropriate comments are also present\n    /// in the Rust implementation description of function `get_maximal_allowed_overhead`.\n    /// @param _encodingLength The length of the binary encoding of the transaction in bytes\n    function getOverheadForTransaction(\n        uint256 _encodingLength\n    ) internal pure returns (uint256 batchOverheadForTransaction) {\n        // The overhead from taking up the transaction\'s slot\n        batchOverheadForTransaction = TX_SLOT_OVERHEAD_L2_GAS;\n\n        // The overhead for occupying the bootloader memory can be derived from encoded_len\n        uint256 overheadForLength = MEMORY_OVERHEAD_GAS * _encodingLength;\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'TransactionValidator.getOverheadForTransaction', 'start_line': 512, 'end_line': 521, 'offset_start': 23544, 'offset_end': 24073, 'content': "function getOverheadForTransaction(\n        uint256 _encodingLength\n    ) internal pure returns (uint256 batchOverheadForTransaction) {\n        // The overhead from taking up the transaction's slot\n        batchOverheadForTransaction = TX_SLOT_OVERHEAD_L2_GAS;\n\n        // The overhead for occupying the bootloader memory can be derived from encoded_len\n        uint256 overheadForLength = MEMORY_OVERHEAD_GAS * _encodingLength;\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n    }", 'contract_name': 'TransactionValidator', 'contract_code': '{\n    /// @dev Used to validate key properties of an L1->L2 transaction\n    /// @param _transaction The transaction to validate\n    /// @param _encoded The abi encoded bytes of the transaction\n    /// @param _priorityTxMaxGasLimit The max gas limit, generally provided from Storage.sol\n    /// @param _priorityTxMaxPubdata The maximal amount of pubdata that a single L1->L2 transaction can emit\n    function validateL1ToL2Transaction(\n        L2CanonicalTransaction memory _transaction,\n        bytes memory _encoded,\n        uint256 _priorityTxMaxGasLimit,\n        uint256 _priorityTxMaxPubdata\n    ) internal pure {\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(_transaction.gasLimit, _encoded.length);\n\n        // Ensuring that the transaction is provable\n        require(l2GasForTxBody <= _priorityTxMaxGasLimit, "ui");\n        // Ensuring that the transaction cannot output more pubdata than is processable\n        require(l2GasForTxBody / _transaction.gasPerPubdataByteLimit <= _priorityTxMaxPubdata, "uk");\n\n        // Ensuring that the transaction covers the minimal costs for its processing:\n        // hashing its content, publishing the factory dependencies, etc.\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= l2GasForTxBody,\n            "up"\n        );\n    }\n\n    /// @dev Used to validate upgrade transactions\n    /// @param _transaction The transaction to validate\n    function validateUpgradeTransaction(L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, "ua");\n        require(_transaction.to <= type(uint160).max, "ub");\n        require(_transaction.paymaster == 0, "uc");\n        require(_transaction.value == 0, "ud");\n        require(_transaction.maxFeePerGas == 0, "uq");\n        require(_transaction.maxPriorityFeePerGas == 0, "ux");\n        require(_transaction.reserved[0] == 0, "ue");\n        require(_transaction.reserved[1] <= type(uint160).max, "uf");\n        require(_transaction.reserved[2] == 0, "ug");\n        require(_transaction.reserved[3] == 0, "uo");\n        require(_transaction.signature.length == 0, "uh");\n        require(_transaction.paymasterInput.length == 0, "ul1");\n        require(_transaction.reservedDynamic.length == 0, "um");\n    }\n\n    /// @dev Calculates the approximate minimum gas limit required for executing a priority transaction.\n    /// @param _encodingLength The length of the priority transaction encoding in bytes.\n    /// @param _numberOfFactoryDependencies The number of new factory dependencies that will be added.\n    /// @param _l2GasPricePerPubdata The L2 gas price for publishing the priority transaction on L2.\n    /// @return The minimum gas limit required to execute the priority transaction.\n    /// Note: The calculation includes the main cost of the priority transaction, however, in reality, the operator can spend a little more gas on overheads.\n    function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        uint256 costForComputation;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForComputation = L1_TX_INTRINSIC_L2_GAS;\n\n            // Taking into account the hashing costs that depend on the length of the transaction\n            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n            // the transaction\'s encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n            // and the size of each new encoding word).\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n\n            // There is a minimal amount of computational L2 gas that the transaction should cover\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n        }\n\n        uint256 costForPubdata = 0;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n        }\n\n        return costForComputation + costForPubdata;\n    }\n\n    /// @notice Based on the full L2 gas limit (that includes the batch overhead) and other\n    /// properties of the transaction, returns the l2GasLimit for the body of the transaction (the actual execution).\n    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the batch\n    /// and the L2 gas needed to process the transaction itself (i.e. the actual l2GasLimit that will be used for the transaction).\n    /// @param _encodingLength The length of the ABI-encoding of the transaction.\n    function getTransactionBodyGasLimit(\n        uint256 _totalGasLimit,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 txBodyGasLimit) {\n        uint256 overhead = getOverheadForTransaction(_encodingLength);\n\n        require(_totalGasLimit >= overhead, "my"); // provided gas limit doesn\'t cover transaction overhead\n        unchecked {\n            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.\n            txBodyGasLimit = _totalGasLimit - overhead;\n        }\n    }\n\n    /// @notice Based on the total L2 gas limit and several other parameters of the transaction\n    /// returns the part of the L2 gas that will be spent on the batch\'s overhead.\n    /// @dev The details of how this function works can be checked in the documentation\n    /// of the fee model of zkSync. The appropriate comments are also present\n    /// in the Rust implementation description of function `get_maximal_allowed_overhead`.\n    /// @param _encodingLength The length of the binary encoding of the transaction in bytes\n    function getOverheadForTransaction(\n        uint256 _encodingLength\n    ) internal pure returns (uint256 batchOverheadForTransaction) {\n        // The overhead from taking up the transaction\'s slot\n        batchOverheadForTransaction = TX_SLOT_OVERHEAD_L2_GAS;\n\n        // The overhead for occupying the bootloader memory can be derived from encoded_len\n        uint256 overheadForLength = MEMORY_OVERHEAD_GAS * _encodingLength;\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._initializeReentrancyGuard', 'start_line': 569, 'end_line': 582, 'offset_start': 26179, 'offset_end': 26722, 'content': 'function _initializeReentrancyGuard() private {\n        uint256 lockSlotOldValue;\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive but in exchange every call to nonReentrant\n        // will be cheaper.\n        assembly {\n            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n\n        // Check that storage slot for reentrancy guard is empty to rule out possibility of slot conflict\n        require(lockSlotOldValue == 0, "1B");\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    /// @dev Address of lock flag variable.\n    /// @dev Flag is placed at random memory location to not interfere with Storage contract.\n    // keccak256("ReentrancyGuard") - 1;\n    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4;\n\n    // solhint-disable-next-line max-line-length\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/security/ReentrancyGuard.sol\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    modifier reentrancyGuardInitializer() {\n        _initializeReentrancyGuard();\n        _;\n    }\n\n    function _initializeReentrancyGuard() private {\n        uint256 lockSlotOldValue;\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive but in exchange every call to nonReentrant\n        // will be cheaper.\n        assembly {\n            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n\n        // Check that storage slot for reentrancy guard is empty to rule out possibility of slot conflict\n        require(lockSlotOldValue == 0, "1B");\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        uint256 _status;\n        assembly {\n            _status := sload(LOCK_FLAG_ADDRESS)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status == _NOT_ENTERED, "r1");\n\n        // Any calls to nonReentrant after this point will fail\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IZkSyncHyperchainBase.getName', 'start_line': 913, 'end_line': 913, 'offset_start': 42960, 'offset_end': 43016, 'content': 'function getName() external view returns (string memory);', 'contract_name': 'IZkSyncHyperchainBase', 'contract_code': '{\n    /// @return Returns facet name.\n    function getName() external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'PriorityQueue.getFirstUnprocessedPriorityTx', 'start_line': 950, 'end_line': 952, 'offset_start': 44600, 'offset_end': 44727, 'content': 'function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }', 'contract_name': 'PriorityQueue', 'contract_code': '{\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 priorityOpId => PriorityOperation priorityOp) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn\'t processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), "D"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), "s"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'PriorityQueue.getTotalPriorityTxs', 'start_line': 955, 'end_line': 957, 'offset_start': 44858, 'offset_end': 44975, 'content': 'function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }', 'contract_name': 'PriorityQueue', 'contract_code': '{\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 priorityOpId => PriorityOperation priorityOp) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn\'t processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), "D"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), "s"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'PriorityQueue.getSize', 'start_line': 960, 'end_line': 962, 'offset_start': 45070, 'offset_end': 45198, 'content': 'function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }', 'contract_name': 'PriorityQueue', 'contract_code': '{\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 priorityOpId => PriorityOperation priorityOp) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn\'t processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), "D"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), "s"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'PriorityQueue.isEmpty', 'start_line': 965, 'end_line': 967, 'offset_start': 45271, 'offset_end': 45388, 'content': 'function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }', 'contract_name': 'PriorityQueue', 'contract_code': '{\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 priorityOpId => PriorityOperation priorityOp) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn\'t processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), "D"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), "s"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'PriorityQueue.pushBack', 'start_line': 970, 'end_line': 976, 'offset_start': 45471, 'offset_end': 45750, 'content': 'function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }', 'contract_name': 'PriorityQueue', 'contract_code': '{\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 priorityOpId => PriorityOperation priorityOp) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn\'t processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), "D"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), "s"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'PriorityQueue.front', 'start_line': 979, 'end_line': 983, 'offset_start': 45829, 'offset_end': 46031, 'content': 'function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), "D"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }', 'contract_name': 'PriorityQueue', 'contract_code': '{\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 priorityOpId => PriorityOperation priorityOp) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn\'t processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), "D"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), "s"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'PriorityQueue.popFront', 'start_line': 987, 'end_line': 996, 'offset_start': 46191, 'offset_end': 46596, 'content': 'function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), "s"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }', 'contract_name': 'PriorityQueue', 'contract_code': '{\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 priorityOpId => PriorityOperation priorityOp) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn\'t processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), "D"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), "s"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet.tor', 'start_line': 1037, 'end_line': 1039, 'offset_start': 48712, 'offset_end': 48787, 'content': 'constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet.transferEthToSharedBridge', 'start_line': 1042, 'end_line': 1048, 'offset_start': 48823, 'offset_end': 49209, 'content': 'function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet.bridgehubRequestL2Transaction', 'start_line': 1051, 'end_line': 1055, 'offset_start': 49283, 'offset_end': 49513, 'content': 'function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet.proveL2MessageInclusion', 'start_line': 1058, 'end_line': 1065, 'offset_start': 49549, 'offset_end': 49839, 'content': 'function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet.proveL2LogInclusion', 'start_line': 1068, 'end_line': 1075, 'offset_start': 49875, 'offset_end': 50134, 'content': 'function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet.proveL1ToL2TransactionStatus', 'start_line': 1078, 'end_line': 1105, 'offset_start': 50170, 'offset_end': 51504, 'content': 'function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet._proveL2LogInclusion', 'start_line': 1108, 'end_line': 1132, 'offset_start': 51592, 'offset_end': 52716, 'content': 'function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet._L2MessageToLog', 'start_line': 1135, 'end_line': 1145, 'offset_start': 52787, 'offset_end': 53233, 'content': 'function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet.l2TransactionBaseCost', 'start_line': 1148, 'end_line': 1155, 'offset_start': 53269, 'offset_end': 53568, 'content': 'function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet._deriveL2GasPrice', 'start_line': 1161, 'end_line': 1182, 'offset_start': 53819, 'offset_end': 55120, 'content': 'function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet.finalizeEthWithdrawal', 'start_line': 1185, 'end_line': 1201, 'offset_start': 55156, 'offset_end': 55832, 'content': 'function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet.requestL2Transaction', 'start_line': 1204, 'end_line': 1233, 'offset_start': 55869, 'offset_end': 57008, 'content': 'function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet._requestL2TransactionSender', 'start_line': 1235, 'end_line': 1264, 'offset_start': 57015, 'offset_end': 58586, 'content': 'function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet._requestL2Transaction', 'start_line': 1266, 'end_line': 1289, 'offset_start': 58593, 'offset_end': 60026, 'content': 'function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet._serializeL2Transaction', 'start_line': 1291, 'end_line': 1314, 'offset_start': 60033, 'offset_end': 61254, 'content': 'function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet._writePriorityOp', 'start_line': 1317, 'end_line': 1350, 'offset_start': 61340, 'offset_end': 62608, 'content': 'function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'MailboxFacet._hashFactoryDeps', 'start_line': 1353, 'end_line': 1364, 'offset_start': 62732, 'offset_end': 63318, 'content': 'function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }', 'contract_name': 'MailboxFacet', 'contract_code': '{\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncHyperchainBase\n    string public constant override getName = "MailboxFacet";\n\n    /// @dev Era\'s chainID\n    uint256 immutable ERA_CHAIN_ID;\n\n    constructor(uint256 _eraChainId) {\n        ERA_CHAIN_ID = _eraChainId;\n    }\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: transferEthToSharedBridge only available for Era on mailbox");\n\n        uint256 amount = address(this).balance;\n        address baseTokenBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(baseTokenBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest calldata _request\n    ) external onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, "xx");\n\n        bytes32 hashedLog = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, "tw");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in base token to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in the base token\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, "Mailbox: baseTokenGasPriceDenominator not set");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            // slither-disable-next-line divide-before-multiply\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        // slither-disable-next-line divide-before-multiply\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: finalizeEthWithdrawal only available for Era on mailbox");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal({\n            _chainId: ERA_CHAIN_ID,\n            _l2BatchNumber: _l2BatchNumber,\n            _l2MessageIndex: _l2MessageIndex,\n            _l2TxNumberInBatch: _l2TxNumberInBatch,\n            _message: _message,\n            _merkleProof: _merkleProof\n        });\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, "Mailbox: legacy interface only available for Era");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Check that the transaction is allowed by the filterer (if the filterer is set).\n        if (s.transactionFilterer != address(0)) {\n            require(\n                ITransactionFilterer(s.transactionFilterer).isTransactionAllowed({\n                    sender: _request.sender,\n                    contractL2: _request.contractL2,\n                    mintValue: _request.mintValue,\n                    l2Value: _request.l2Value,\n                    l2Calldata: _request.l2Calldata,\n                    refundRecipient: _request.refundRecipient\n                }),\n                "tf"\n            );\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using "exotic" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, "qp");\n\n        WritePriorityOpParams memory params;\n        params.request = _request;\n\n        canonicalTxHash = _requestL2Transaction(params);\n    }\n\n    function _requestL2Transaction(WritePriorityOpParams memory _params) internal returns (bytes32 canonicalTxHash) {\n        BridgehubL2TransactionRequest memory request = _params.request;\n\n        require(request.factoryDeps.length <= MAX_NEW_FACTORY_DEPS, "uj");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, request.l2GasPerPubdataByteLimit);\n        uint256 baseCost = _params.l2GasPrice * request.l2GasLimit;\n        require(request.mintValue >= baseCost + request.l2Value, "mv"); // The `msg.value` doesn\'t cover the transaction cost\n\n        request.refundRecipient = AddressAliasHelper.actualRefundRecipient(request.refundRecipient, request.sender);\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        // slither-disable-next-line tx-origin\n        if (request.sender != tx.origin) {\n            request.sender = AddressAliasHelper.applyL1ToL2Alias(request.sender);\n        }\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n\n        canonicalTxHash = _writePriorityOp(_params);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        BridgehubL2TransactionRequest memory request = _priorityOpParams.request;\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(request.sender)),\n            to: uint256(uint160(request.contractL2)),\n            gasLimit: request.l2GasLimit,\n            gasPerPubdataByteLimit: request.l2GasPerPubdataByteLimit,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as "nonce" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: request.l2Value,\n            reserved: [request.mintValue, uint256(uint160(request.refundRecipient)), 0, 0],\n            data: request.l2Calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(request.factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        // solhint-disable-next-line func-named-parameters\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _priorityOpParams.request.factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Merkle.calculateRoot', 'start_line': 1384, 'end_line': 1403, 'offset_start': 63972, 'offset_end': 64625, 'content': 'function calculateRoot(\n        bytes32[] calldata _path,\n        uint256 _index,\n        bytes32 _itemHash\n    ) internal pure returns (bytes32) {\n        uint256 pathLength = _path.length;\n        require(pathLength > 0, "xc");\n        require(pathLength < 256, "bt");\n        require(_index < (1 << pathLength), "px");\n\n        bytes32 currentHash = _itemHash;\n        for (uint256 i; i < pathLength; i = i.uncheckedInc()) {\n            currentHash = (_index % 2 == 0)\n                ? _efficientHash(currentHash, _path[i])\n                : _efficientHash(_path[i], currentHash);\n            _index /= 2;\n        }\n\n        return currentHash;\n    }', 'contract_name': 'Merkle', 'contract_code': '{\n    using UncheckedMath for uint256;\n\n    /// @dev Calculate Merkle root by the provided Merkle proof.\n    /// NOTE: When using this function, check that the _path length is equal to the tree height to prevent shorter/longer paths attack\n    /// @param _path Merkle path from the leaf to the root\n    /// @param _index Leaf index in the tree\n    /// @param _itemHash Hash of leaf content\n    /// @return The Merkle root\n    function calculateRoot(\n        bytes32[] calldata _path,\n        uint256 _index,\n        bytes32 _itemHash\n    ) internal pure returns (bytes32) {\n        uint256 pathLength = _path.length;\n        require(pathLength > 0, "xc");\n        require(pathLength < 256, "bt");\n        require(_index < (1 << pathLength), "px");\n\n        bytes32 currentHash = _itemHash;\n        for (uint256 i; i < pathLength; i = i.uncheckedInc()) {\n            currentHash = (_index % 2 == 0)\n                ? _efficientHash(currentHash, _path[i])\n                : _efficientHash(_path[i], currentHash);\n            _index /= 2;\n        }\n\n        return currentHash;\n    }\n\n    /// @dev Keccak hash of the concatenation of two 32-byte words\n    function _efficientHash(bytes32 _lhs, bytes32 _rhs) private pure returns (bytes32 result) {\n        assembly {\n            mstore(0x00, _lhs)\n            mstore(0x20, _rhs)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Merkle._efficientHash', 'start_line': 1406, 'end_line': 1412, 'offset_start': 64699, 'offset_end': 64930, 'content': 'function _efficientHash(bytes32 _lhs, bytes32 _rhs) private pure returns (bytes32 result) {\n        assembly {\n            mstore(0x00, _lhs)\n            mstore(0x20, _rhs)\n            result := keccak256(0x00, 0x40)\n        }\n    }', 'contract_name': 'Merkle', 'contract_code': '{\n    using UncheckedMath for uint256;\n\n    /// @dev Calculate Merkle root by the provided Merkle proof.\n    /// NOTE: When using this function, check that the _path length is equal to the tree height to prevent shorter/longer paths attack\n    /// @param _path Merkle path from the leaf to the root\n    /// @param _index Leaf index in the tree\n    /// @param _itemHash Hash of leaf content\n    /// @return The Merkle root\n    function calculateRoot(\n        bytes32[] calldata _path,\n        uint256 _index,\n        bytes32 _itemHash\n    ) internal pure returns (bytes32) {\n        uint256 pathLength = _path.length;\n        require(pathLength > 0, "xc");\n        require(pathLength < 256, "bt");\n        require(_index < (1 << pathLength), "px");\n\n        bytes32 currentHash = _itemHash;\n        for (uint256 i; i < pathLength; i = i.uncheckedInc()) {\n            currentHash = (_index % 2 == 0)\n                ? _efficientHash(currentHash, _path[i])\n                : _efficientHash(_path[i], currentHash);\n            _index /= 2;\n        }\n\n        return currentHash;\n    }\n\n    /// @dev Keccak hash of the concatenation of two 32-byte words\n    function _efficientHash(bytes32 _lhs, bytes32 _rhs) private pure returns (bytes32 result) {\n        assembly {\n            mstore(0x00, _lhs)\n            mstore(0x20, _rhs)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 1544, 'end_line': 1546, 'offset_start': 71013, 'offset_end': 71116, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 1551, 'end_line': 1553, 'offset_start': 71188, 'offset_end': 71291, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 1559, 'end_line': 1562, 'offset_start': 71405, 'offset_end': 71557, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 1570, 'end_line': 1573, 'offset_start': 71757, 'offset_end': 71950, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 1580, 'end_line': 1659, 'offset_start': 72267, 'offset_end': 76479, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 1664, 'end_line': 1670, 'offset_start': 76612, 'offset_end': 76910, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 1677, 'end_line': 1708, 'offset_start': 77130, 'offset_end': 78767, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 1713, 'end_line': 1718, 'offset_start': 78868, 'offset_end': 79104, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 1724, 'end_line': 1760, 'offset_start': 79229, 'offset_end': 80211, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 1766, 'end_line': 1771, 'offset_start': 80365, 'offset_end': 80609, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 1777, 'end_line': 1809, 'offset_start': 80735, 'offset_end': 81650, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 1815, 'end_line': 1820, 'offset_start': 81805, 'offset_end': 82052, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 1828, 'end_line': 1852, 'offset_start': 82304, 'offset_end': 82966, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 1858, 'end_line': 1863, 'offset_start': 83122, 'offset_end': 83377, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'L2ContractHelper.hashL2Bytecode', 'start_line': 1886, 'end_line': 1898, 'offset_start': 84193, 'offset_end': 85018, 'content': 'function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }', 'contract_name': 'L2ContractHelper', 'contract_code': '{\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256("zksyncCreate2");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash format.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function bytecodeLen(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'L2ContractHelper.validateBytecodeHash', 'start_line': 1904, 'end_line': 1909, 'offset_start': 85338, 'offset_end': 85665, 'content': 'function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }', 'contract_name': 'L2ContractHelper', 'contract_code': '{\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256("zksyncCreate2");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash format.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function bytecodeLen(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'L2ContractHelper.bytecodeLen', 'start_line': 1914, 'end_line': 1916, 'offset_start': 85881, 'offset_end': 86084, 'content': 'function bytecodeLen(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }', 'contract_name': 'L2ContractHelper', 'contract_code': '{\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256("zksyncCreate2");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash format.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function bytecodeLen(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'L2ContractHelper.computeCreate2Address', 'start_line': 1925, 'end_line': 1938, 'offset_start': 86545, 'offset_end': 87060, 'content': 'function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }', 'contract_name': 'L2ContractHelper', 'contract_code': '{\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256("zksyncCreate2");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, "pq");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, "pp"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, "ps"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash format.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), "zf"); // Incorrectly formatted bytecodeHash\n\n        require(bytecodeLen(_bytecodeHash) % 2 == 1, "uy"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function bytecodeLen(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            // solhint-disable-next-line func-named-parameters\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'ITransactionFilterer.isTransactionAllowed', 'start_line': 1957, 'end_line': 1964, 'offset_start': 87752, 'offset_end': 87986, 'content': 'function isTransactionAllowed(\n        address sender,\n        address contractL2,\n        uint256 mintValue,\n        uint256 l2Value,\n        bytes memory l2Calldata,\n        address refundRecipient\n    ) external view returns (bool);', 'contract_name': 'ITransactionFilterer', 'contract_code': '{\n    /// @notice Check if the transaction is allowed\n    /// @param sender The sender of the transaction\n    /// @param contractL2 The L2 receiver address\n    /// @param mintValue The value of the L1 transaction\n    /// @param l2Value The msg.value of the L2 transaction\n    /// @param l2Calldata The calldata of the L2 transaction\n    /// @param refundRecipient The address to refund the excess value\n    /// @return Whether the transaction is allowed\n    function isTransactionAllowed(\n        address sender,\n        address contractL2,\n        uint256 mintValue,\n        uint256 l2Value,\n        bytes memory l2Calldata,\n        address refundRecipient\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.setPendingAdmin', 'start_line': 2017, 'end_line': 2017, 'offset_start': 89549, 'offset_end': 89608, 'content': 'function setPendingAdmin(address _newPendingAdmin) external;', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.acceptAdmin', 'start_line': 2020, 'end_line': 2020, 'offset_start': 89705, 'offset_end': 89736, 'content': 'function acceptAdmin() external;', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.stateTransitionManagerIsRegistered', 'start_line': 2023, 'end_line': 2023, 'offset_start': 89759, 'offset_end': 89864, 'content': 'function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.stateTransitionManager', 'start_line': 2025, 'end_line': 2025, 'offset_start': 89871, 'offset_end': 89952, 'content': 'function stateTransitionManager(uint256 _chainId) external view returns (address);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.tokenIsRegistered', 'start_line': 2027, 'end_line': 2027, 'offset_start': 89959, 'offset_end': 90034, 'content': 'function tokenIsRegistered(address _baseToken) external view returns (bool);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.baseToken', 'start_line': 2029, 'end_line': 2029, 'offset_start': 90041, 'offset_end': 90109, 'content': 'function baseToken(uint256 _chainId) external view returns (address);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.sharedBridge', 'start_line': 2031, 'end_line': 2031, 'offset_start': 90116, 'offset_end': 90179, 'content': 'function sharedBridge() external view returns (IL1SharedBridge);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.getHyperchain', 'start_line': 2033, 'end_line': 2033, 'offset_start': 90186, 'offset_end': 90258, 'content': 'function getHyperchain(uint256 _chainId) external view returns (address);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.proveL2MessageInclusion', 'start_line': 2037, 'end_line': 2043, 'offset_start': 90292, 'offset_end': 90511, 'content': 'function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.proveL2LogInclusion', 'start_line': 2045, 'end_line': 2051, 'offset_start': 90518, 'offset_end': 90723, 'content': 'function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.proveL1ToL2TransactionStatus', 'start_line': 2053, 'end_line': 2061, 'offset_start': 90730, 'offset_end': 91022, 'content': 'function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.requestL2TransactionDirect', 'start_line': 2063, 'end_line': 2065, 'offset_start': 91029, 'offset_end': 91175, 'content': 'function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.requestL2TransactionTwoBridges', 'start_line': 2067, 'end_line': 2069, 'offset_start': 91182, 'offset_end': 91341, 'content': 'function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.l2TransactionBaseCost', 'start_line': 2071, 'end_line': 2076, 'offset_start': 91348, 'offset_end': 91541, 'content': 'function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.createNewChain', 'start_line': 2080, 'end_line': 2087, 'offset_start': 91567, 'offset_end': 91807, 'content': 'function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.addStateTransitionManager', 'start_line': 2089, 'end_line': 2089, 'offset_start': 91814, 'offset_end': 91890, 'content': 'function addStateTransitionManager(address _stateTransitionManager) external;', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.removeStateTransitionManager', 'start_line': 2091, 'end_line': 2091, 'offset_start': 91897, 'offset_end': 91976, 'content': 'function removeStateTransitionManager(address _stateTransitionManager) external;', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.addToken', 'start_line': 2093, 'end_line': 2093, 'offset_start': 91983, 'offset_end': 92025, 'content': 'function addToken(address _token) external;', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IBridgehub.setSharedBridge', 'start_line': 2095, 'end_line': 2095, 'offset_start': 92032, 'offset_end': 92088, 'content': 'function setSharedBridge(address _sharedBridge) external;', 'contract_name': 'IBridgehub', 'contract_code': '{\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// Getters\n    function stateTransitionManagerIsRegistered(address _stateTransitionManager) external view returns (bool);\n\n    function stateTransitionManager(uint256 _chainId) external view returns (address);\n\n    function tokenIsRegistered(address _baseToken) external view returns (bool);\n\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    function sharedBridge() external view returns (IL1SharedBridge);\n\n    function getHyperchain(uint256 _chainId) external view returns (address);\n\n    /// Mailbox forwarder\n\n    function proveL2MessageInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _chainId,\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL1ToL2TransactionStatus(\n        uint256 _chainId,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) external view returns (bool);\n\n    function requestL2TransactionDirect(\n        L2TransactionRequestDirect calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function requestL2TransactionTwoBridges(\n        L2TransactionRequestTwoBridgesOuter calldata _request\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n\n    //// Registry\n\n    function createNewChain(\n        uint256 _chainId,\n        address _stateTransitionManager,\n        address _baseToken,\n        uint256 _salt,\n        address _admin,\n        bytes calldata _initData\n    ) external returns (uint256 chainId);\n\n    function addStateTransitionManager(address _stateTransitionManager) external;\n\n    function removeStateTransitionManager(address _stateTransitionManager) external;\n\n    function addToken(address _token) external;\n\n    function setSharedBridge(address _sharedBridge) external;\n\n    event NewChain(uint256 indexed chainId, address stateTransitionManager, address indexed chainGovernance);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.isWithdrawalFinalized', 'start_line': 2157, 'end_line': 2161, 'offset_start': 93690, 'offset_end': 93846, 'content': 'function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.depositLegacyErc20Bridge', 'start_line': 2163, 'end_line': 2171, 'offset_start': 93853, 'offset_end': 94147, 'content': 'function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.claimFailedDepositLegacyErc20Bridge', 'start_line': 2173, 'end_line': 2182, 'offset_start': 94154, 'offset_end': 94464, 'content': 'function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.claimFailedDeposit', 'start_line': 2184, 'end_line': 2194, 'offset_start': 94471, 'offset_end': 94790, 'content': 'function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.finalizeWithdrawalLegacyErc20Bridge', 'start_line': 2196, 'end_line': 2202, 'offset_start': 94797, 'offset_end': 95092, 'content': 'function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.finalizeWithdrawal', 'start_line': 2204, 'end_line': 2211, 'offset_start': 95099, 'offset_end': 95341, 'content': 'function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.setEraPostDiamondUpgradeFirstBatch', 'start_line': 2213, 'end_line': 2213, 'offset_start': 95348, 'offset_end': 95442, 'content': 'function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.setEraPostLegacyBridgeUpgradeFirstBatch', 'start_line': 2215, 'end_line': 2215, 'offset_start': 95449, 'offset_end': 95553, 'content': 'function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.setEraLegacyBridgeLastDepositTime', 'start_line': 2217, 'end_line': 2220, 'offset_start': 95560, 'offset_end': 95720, 'content': 'function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.L1_WETH_TOKEN', 'start_line': 2222, 'end_line': 2222, 'offset_start': 95727, 'offset_end': 95783, 'content': 'function L1_WETH_TOKEN() external view returns (address);', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.BRIDGE_HUB', 'start_line': 2224, 'end_line': 2224, 'offset_start': 95790, 'offset_end': 95846, 'content': 'function BRIDGE_HUB() external view returns (IBridgehub);', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.legacyBridge', 'start_line': 2226, 'end_line': 2226, 'offset_start': 95853, 'offset_end': 95915, 'content': 'function legacyBridge() external view returns (IL1ERC20Bridge);', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.l2BridgeAddress', 'start_line': 2228, 'end_line': 2228, 'offset_start': 95922, 'offset_end': 95996, 'content': 'function l2BridgeAddress(uint256 _chainId) external view returns (address);', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.depositHappened', 'start_line': 2230, 'end_line': 2230, 'offset_start': 96003, 'offset_end': 96096, 'content': 'function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.bridgehubDeposit', 'start_line': 2236, 'end_line': 2241, 'offset_start': 96212, 'offset_end': 96435, 'content': 'function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.bridgehubDepositBaseToken', 'start_line': 2243, 'end_line': 2248, 'offset_start': 96442, 'offset_end': 96608, 'content': 'function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.bridgehubConfirmL2Transaction', 'start_line': 2250, 'end_line': 2250, 'offset_start': 96615, 'offset_end': 96718, 'content': 'function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
{'type': 'FunctionDefinition', 'name': 'IL1SharedBridge.receiveEth', 'start_line': 2252, 'end_line': 2252, 'offset_start': 96725, 'offset_end': 96779, 'content': 'function receiveEth(uint256 _chainId) external payable;', 'contract_name': 'IL1SharedBridge', 'contract_code': '{\n    event LegacyDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed l2DepositTxHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositInitiated(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        address indexed from,\n        address to,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositBaseTokenInitiated(\n        uint256 indexed chainId,\n        address indexed from,\n        address l1Token,\n        uint256 amount\n    );\n\n    event BridgehubDepositFinalized(\n        uint256 indexed chainId,\n        bytes32 indexed txDataHash,\n        bytes32 indexed l2DepositTxHash\n    );\n\n    event WithdrawalFinalizedSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    event ClaimedFailedDepositSharedBridge(\n        uint256 indexed chainId,\n        address indexed to,\n        address indexed l1Token,\n        uint256 amount\n    );\n\n    function isWithdrawalFinalized(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex\n    ) external view returns (bool);\n\n    function depositLegacyErc20Bridge(\n        address _msgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n\n    function claimFailedDepositLegacyErc20Bridge(\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function finalizeWithdrawalLegacyErc20Bridge(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external returns (address l1Receiver, address l1Token, uint256 amount);\n\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external;\n\n    function setEraPostDiamondUpgradeFirstBatch(uint256 _eraPostDiamondUpgradeFirstBatch) external;\n\n    function setEraPostLegacyBridgeUpgradeFirstBatch(uint256 _eraPostLegacyBridgeUpgradeFirstBatch) external;\n\n    function setEraLegacyBridgeLastDepositTime(\n        uint256 _eraLegacyBridgeLastDepositBatch,\n        uint256 _eraLegacyBridgeLastDepositTxNumber\n    ) external;\n\n    function L1_WETH_TOKEN() external view returns (address);\n\n    function BRIDGE_HUB() external view returns (IBridgehub);\n\n    function legacyBridge() external view returns (IL1ERC20Bridge);\n\n    function l2BridgeAddress(uint256 _chainId) external view returns (address);\n\n    function depositHappened(uint256 _chainId, bytes32 _l2TxHash) external view returns (bytes32);\n\n    /// data is abi encoded :\n    /// address _l1Token,\n    /// uint256 _amount,\n    /// address _l2Receiver\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256 _l2Value,\n        bytes calldata _data\n    ) external payable returns (L2TransactionRequestTwoBridgesInner memory request);\n\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable;\n\n    function bridgehubConfirmL2Transaction(uint256 _chainId, bytes32 _txDataHash, bytes32 _txHash) external;\n\n    function receiveEth(uint256 _chainId) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x32400084c286cf3e17e7b677ea9583e60a000324/0x32400084c286cf3e17e7b677ea9583e60a000324.sol'}
