{'type': 'FunctionDefinition', 'name': 'SignatureChecker.isValidSignatureNow', 'start_line': 22, 'end_line': 27, 'offset_start': 1039, 'offset_end': 1406, 'content': 'function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }', 'contract_name': 'SignatureChecker', 'contract_code': "{\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SignatureChecker.isValidERC1271SignatureNow', 'start_line': 36, 'end_line': 47, 'offset_start': 1813, 'offset_end': 2270, 'content': 'function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }', 'contract_name': 'SignatureChecker', 'contract_code': "{\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.max', 'start_line': 62, 'end_line': 64, 'offset_start': 2587, 'offset_end': 2687, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.min', 'start_line': 69, 'end_line': 71, 'offset_start': 2766, 'offset_end': 2866, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.average', 'start_line': 77, 'end_line': 81, 'offset_start': 3004, 'offset_end': 3233, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.abs', 'start_line': 86, 'end_line': 91, 'offset_start': 3323, 'offset_end': 3535, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 117, 'end_line': 137, 'offset_start': 4177, 'offset_end': 4874, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn\'t fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toStringSigned', 'start_line': 142, 'end_line': 144, 'offset_start': 4975, 'offset_end': 5142, 'content': 'function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn\'t fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 149, 'end_line': 153, 'offset_start': 5248, 'offset_end': 5421, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn\'t fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 158, 'end_line': 171, 'offset_start': 5545, 'offset_end': 6069, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn\'t fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 177, 'end_line': 179, 'offset_start': 6229, 'offset_end': 6376, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn\'t fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.equal', 'start_line': 184, 'end_line': 186, 'offset_start': 6454, 'offset_end': 6635, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn\'t fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.depositFor', 'start_line': 286, 'end_line': 286, 'offset_start': 12644, 'offset_end': 12719, 'content': 'function depositFor(address _token, address _for, uint256 _amount) external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.depositETHFor', 'start_line': 291, 'end_line': 291, 'offset_start': 12914, 'offset_end': 12967, 'content': 'function depositETHFor(address _for) payable external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.withdraw', 'start_line': 296, 'end_line': 296, 'offset_start': 13230, 'offset_end': 13289, 'content': 'function withdraw(address _token, uint256 _amount) external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.migrate', 'start_line': 305, 'end_line': 311, 'offset_start': 13990, 'offset_end': 14217, 'content': 'function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.migrateWithSig', 'start_line': 321, 'end_line': 328, 'offset_start': 14883, 'offset_end': 15122, 'content': 'function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.setZircuitSigner', 'start_line': 338, 'end_line': 338, 'offset_start': 15569, 'offset_end': 15620, 'content': 'function setZircuitSigner(address _signer) external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.setStakable', 'start_line': 344, 'end_line': 344, 'offset_start': 15900, 'offset_end': 15961, 'content': 'function setStakable(address _token, bool _canStake) external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.blockMigrator', 'start_line': 350, 'end_line': 350, 'offset_start': 16364, 'offset_end': 16433, 'content': 'function blockMigrator(address _migrator, bool _blocklisted) external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.pause', 'start_line': 354, 'end_line': 354, 'offset_start': 16609, 'offset_end': 16634, 'content': 'function pause() external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IZtakingPool.unpause', 'start_line': 358, 'end_line': 358, 'offset_start': 16758, 'offset_end': 16785, 'content': 'function unpause() external;', 'contract_name': 'IZtakingPool', 'contract_code': '{\n\n    /*//////////////////////////////////////////////////////////////\n                            Errors\n    //////////////////////////////////////////////////////////////*/\n\n    error SignerCannotBeZeroAddress(); //Thrown when proposed signer is the zero address\n    error SignerAlreadySetToAddress(); //Thrown when proposed signer is already set\n    error SignatureInvalid(); // Thrown when the migration signature is invalid\n    error SignatureExpired(); // Thrown when the migration signature has expired\n    error TokenCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error WETHCannotBeZeroAddress(); // Thrown when the specified token is the zero address\n    error TokenAlreadyConfiguredWithState(); //Thrown if the token as already been enabled or disabled \n    error DepositAmountCannotBeZero(); // Thrown if staker attempts to call deposit() with zero amount\n    error WithdrawAmountCannotBeZero(); //Thrown if staker attempts to call withdraw() with zero amount\n    error TokenNotAllowedForStaking(); // Thrown if staker attempts to stake unsupported token (or token disabled for staking)\n    error UserDoesNotHaveStake(); //Thrown if the staker is attempting to migrate with no stake\n    error MigratorCannotBeZeroAddress(); //Thrown if the provided migrator is the zero address\n    error MigratorAlreadyAllowedOrBlocked(); //Thrown if attempting to block a migrator which has already been blocked or attempting to allow a migrator which is already allowed\n    error MigratorBlocked(); //Thrown if the provided migrator contract has been blacklisted.\n    error CannotDepositForZeroAddress(); //Thrown if caller tries to deposit on behalf of the zero address\n    error CannotRenounceOwnership(); //Thrown if the renounceOwnership() function is called\n    error DuplicateToken(); //Thrown when there is a duplicate in the provided token address array\n    error TokenArrayCannotBeEmpty(); //Thrown when the provided token address array is empty\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when a staker deposits/stakes a supported token into the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Deposit event\n    ///@param depositor The address of the depositer/staker transfering funds to the Ztaking Pool\n    ///@param token The address of the token deposited/staked into the pool\n    ///@param amount The amount of token deposited/staked into the pool\n    event Deposit(\n        uint256 indexed eventId, \n        address indexed depositor, \n        address indexed token, \n        uint256 amount\n    );\n\n    ///@notice Emitted when a staker withdraws a previously staked tokens from the Ztaking Pool\n    ///@param eventId The unique event Id associated with the Withdraw event\n    ///@param withdrawer The address of the staker withdrawing funds from the Ztaking Pool\n    ///@param token The address of the token being withdrawn from the pool\n    ///@param amount The amount of tokens withdrawn the pool\n    event Withdraw(uint256 indexed eventId, address indexed withdrawer, address indexed token, uint256 amount);\n\n    ///@notice Emitted when a staker migrates their tokens from the ZtakingPool to Zircuit.\n    ///@param eventId The unique event Id associated with the Migrate event\n    ///@param user The address of the staker migrating funds to Zircuit\n    ///@param tokens The addresses of the tokens being being migrated from the ZtakingPool to Zircuit\n    ///@param destination The address which the tokens will be transferred to on Zircuit\n    ///@param migrator The address of the migrator contract which initially receives the migrated tokens\n    ///@param amounts The amounts of each token migrated to Zircuit\n    event Migrate(\n        uint256 indexed eventId, \n        address indexed user, \n        address[] tokens, \n        address destination, \n        address migrator, \n        uint256[] amounts\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Events\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Emitted when the required signer for the migration signature is changed\n    ///@param newSigner The address of the new signer which must sign the migration signature\n    event SignerChanged(address newSigner);\n\n    ///@notice Emitted when a token has been enabled or disabled for staking\n    ///@param token The address of the token which has been enabled/disabled for staking\n    ///@param enabled Is true if the token is being enabled and false if the token is being disabled\n    event TokenStakabilityChanged(address token, bool enabled);\n\n    ///@notice Emitted when a migrator has been added or removed from the blocklist\n    ///@param migrator The address of the migrator which has been added or removed from the blocklist \n    ///@param blocked Is true if the migrator was added to the blocklist, and false if it was removed from the blocklist\n    event BlocklistChanged(address migrator, bool blocked);\n    \n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Stake a specified amount of a particular supported token into the Ztaking Pool\n    ///@param _token The token to deposit/stake in the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@param _amount The amount of token to deposit/stake into the Ztaking Pool\n    function depositFor(address _token, address _for, uint256 _amount) external;\n\n    ///@notice Stake a specified amount of ether into the Ztaking Pool\n    ///@param _for The user to deposit/stake on behalf of\n    ///@dev the amount deposited is specified by msg.value\n    function depositETHFor(address _for) payable external;\n\n    ///@notice Withdraw a specified amount of a particular supported token previously staked into the Ztaking Pool\n    ///@param _token The token to withdraw from the Ztaking Pool\n    ///@param _amount The amount of token to withdraw from the Ztaking Pool\n    function withdraw(address _token, uint256 _amount) external;\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@dev called by the staker\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _authorizationSignatureFromZircuit The authorization signature which is signed by the zircuit signer and indicates the correct migrator contract\n    function migrate(\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _authorizationSignatureFromZircuit\n    ) external;\n\n\n    ///@notice Migrate the staked tokens for the caller from the Ztaking Pool to Zircuit\n    ///@param _user The staker to migrate tokens for\n    ///@param _tokens The tokens to migrate to Zircuit from the Ztaking Pool\n    ///@param _migratorContract The migrator contract which will initially receive the migrated tokens before moving them to Zircuit\n    ///@param _destination The address which will receive the migrated tokens on Zircuit\n    ///@param _signatureExpiry The timestamp at which the signature in _authorizationSignatureFromZircuit expires\n    ///@param _stakerSignature The signature from the staker authorizing the migration of their tokens\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) external;\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    ///@notice Set/Change the required signer for the migration signature (_authorizationSignatureFromZircuit in the migrate() function)\n    ///@param _signer The address of the new signer for the migration signature\n    ///@dev Only callable by the owner\n    function setZircuitSigner(address _signer) external;\n\n    ///@notice Enable or disable the specified token for staking\n    ///@param _token The token to enable or disable for staking\n    ///@param _canStake If true, then staking is to be enabled. If false, then staking will be disabled.\n    ///@dev Only callable by the owner\n    function setStakable(address _token, bool _canStake) external;\n\n    ///@notice Add or remove the migrator to/from the blocklist, such that it can no longer be used from migrating tokens from the staking pool\n    ///@param _migrator The migrator contract to add or remove from the blocklist\n    ///@param _blocklisted If true, then add the migrator to the blocklist. If false, then remove the migrator from the blocklist.\n    ///@dev Only callable by the owner\n    function blockMigrator(address _migrator, bool _blocklisted) external;\n\n    ///@notice Pause further staking through the deposit function.\n    ///@dev Only callable by the owner. Withdrawals and migrations will still be possible when paused\n    function pause() external;\n\n    ///@notice Unpause staking allowing the deposit function to be used again\n    ///@dev Only callable by the owner\n    function unpause() external;\n\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 387, 'end_line': 387, 'offset_start': 17564, 'offset_end': 17618, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 392, 'end_line': 392, 'offset_start': 17701, 'offset_end': 17768, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 401, 'end_line': 401, 'offset_start': 17993, 'offset_end': 18061, 'content': 'function transfer(address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 410, 'end_line': 410, 'offset_start': 18337, 'offset_end': 18419, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 427, 'end_line': 427, 'offset_start': 19098, 'offset_end': 19170, 'content': 'function approve(address spender, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 438, 'end_line': 438, 'offset_start': 19479, 'offset_end': 19565, 'content': 'function transferFrom(address from, address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ShortStrings.toShortString', 'start_line': 492, 'end_line': 498, 'offset_start': 21278, 'offset_end': 21563, 'content': 'function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }', 'contract_name': 'ShortStrings', 'contract_code': '{\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a "normal" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the "byte length" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ShortStrings.toString', 'start_line': 503, 'end_line': 513, 'offset_start': 21648, 'offset_end': 22052, 'content': 'function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }', 'contract_name': 'ShortStrings', 'contract_code': '{\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a "normal" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the "byte length" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ShortStrings.byteLength', 'start_line': 518, 'end_line': 524, 'offset_start': 22125, 'offset_end': 22369, 'content': 'function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }', 'contract_name': 'ShortStrings', 'contract_code': '{\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a "normal" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the "byte length" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ShortStrings.toShortStringWithFallback', 'start_line': 529, 'end_line': 536, 'offset_start': 22484, 'offset_end': 22823, 'content': 'function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }', 'contract_name': 'ShortStrings', 'contract_code': '{\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a "normal" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the "byte length" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ShortStrings.toStringWithFallback', 'start_line': 541, 'end_line': 547, 'offset_start': 22955, 'offset_end': 23221, 'content': 'function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }', 'contract_name': 'ShortStrings', 'contract_code': '{\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a "normal" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the "byte length" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ShortStrings.byteLengthWithFallback', 'start_line': 556, 'end_line': 562, 'offset_start': 23597, 'offset_end': 23875, 'content': 'function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }', 'contract_name': 'ShortStrings', 'contract_code': '{\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a "normal" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the "byte length" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 581, 'end_line': 583, 'offset_start': 24536, 'offset_end': 24631, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 585, 'end_line': 587, 'offset_start': 24638, 'offset_end': 24736, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._contextSuffixLength', 'start_line': 589, 'end_line': 591, 'offset_start': 24743, 'offset_end': 24839, 'content': 'function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getAddressSlot', 'start_line': 652, 'end_line': 657, 'offset_start': 26528, 'offset_end': 26717, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBooleanSlot', 'start_line': 662, 'end_line': 667, 'offset_start': 26816, 'offset_end': 27005, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytes32Slot', 'start_line': 672, 'end_line': 677, 'offset_start': 27104, 'offset_end': 27293, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getUint256Slot', 'start_line': 682, 'end_line': 687, 'offset_start': 27392, 'offset_end': 27581, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 692, 'end_line': 697, 'offset_start': 27679, 'offset_end': 27866, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 702, 'end_line': 707, 'offset_start': 27979, 'offset_end': 28180, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 712, 'end_line': 717, 'offset_start': 28277, 'offset_end': 28462, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 722, 'end_line': 727, 'offset_start': 28573, 'offset_end': 28771, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.tor', 'start_line': 774, 'end_line': 786, 'offset_start': 30548, 'offset_end': 31117, 'content': 'constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.depositFor', 'start_line': 796, 'end_line': 806, 'offset_start': 31357, 'offset_end': 31838, 'content': 'function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.depositETHFor', 'start_line': 808, 'end_line': 817, 'offset_start': 31845, 'offset_end': 32303, 'content': 'function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.withdraw', 'start_line': 822, 'end_line': 829, 'offset_start': 32358, 'offset_end': 32713, 'content': 'function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.migrateWithSig', 'start_line': 834, 'end_line': 864, 'offset_start': 32768, 'offset_end': 33975, 'content': 'function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.migrate', 'start_line': 869, 'end_line': 898, 'offset_start': 34030, 'offset_end': 35232, 'content': "function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    '\\x19Ethereum Signed Message:\\n32',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }", 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool._migrateChecks', 'start_line': 900, 'end_line': 916, 'offset_start': 35239, 'offset_end': 35958, 'content': 'function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool._migrate', 'start_line': 918, 'end_line': 944, 'offset_start': 35965, 'offset_end': 36918, 'content': 'function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.setZircuitSigner', 'start_line': 956, 'end_line': 962, 'offset_start': 37163, 'offset_end': 37447, 'content': 'function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.setStakable', 'start_line': 967, 'end_line': 973, 'offset_start': 37502, 'offset_end': 37842, 'content': 'function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.blockMigrator', 'start_line': 978, 'end_line': 984, 'offset_start': 37897, 'offset_end': 38268, 'content': 'function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.pause', 'start_line': 989, 'end_line': 991, 'offset_start': 38323, 'offset_end': 38397, 'content': 'function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.unpause', 'start_line': 996, 'end_line': 998, 'offset_start': 38452, 'offset_end': 38526, 'content': 'function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ZtakingPool.renounceOwnership', 'start_line': 1001, 'end_line': 1003, 'offset_start': 38534, 'offset_end': 38626, 'content': 'function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }', 'contract_name': 'ZtakingPool', 'contract_code': '{\n\n    using SafeERC20 for IERC20;\n\n    bytes32 private constant MIGRATE_TYPEHASH =\n        keccak256("Migrate(address user,address migratorContract,address destination,address[] tokens,uint256 signatureExpiry,uint256 nonce)");\n    \n    // (tokenAddress => isAllowedForStaking)\n    mapping(address => bool) public tokenAllowlist;\n\n    // (tokenAddress => stakerAddress => stakedAmount)\n    mapping(address => mapping(address => uint256)) public balance;\n\n    // (migratorContract => isBlocklisted)\n    mapping(address => bool) public migratorBlocklist;\n\n    // Next eventId to emit\n    uint256 private eventId; \n\n    // Required signer for the migration message\n    address public zircuitSigner;\n\n    // ETH\'s special address\n    address immutable WETH_ADDRESS;\n\n    constructor(address _signer, address[] memory _tokensAllowed, address _weth) Ownable(msg.sender) EIP712("ZtakingPool", "1"){\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_weth == address(0)) revert WETHCannotBeZeroAddress();\n\n        WETH_ADDRESS = _weth;\n\n        zircuitSigner = _signer;\n        uint256 length = _tokensAllowed.length;\n        for(uint256 i; i < length; ++i){\n            if (_tokensAllowed[i] == address(0)) revert TokenCannotBeZeroAddress();\n            tokenAllowlist[_tokensAllowed[i]] = true;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Staker Functions\n    //////////////////////////////////////////////////////////////*/\n\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function depositFor(address _token, address _for, uint256 _amount) whenNotPaused external {\n        if (_amount == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[_token]) revert TokenNotAllowedForStaking();\n\n        balance[_token][_for] += _amount;\n\n        emit Deposit(++eventId, _for, _token, _amount);\n\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);   \n    }\n\n    function depositETHFor(address _for) whenNotPaused payable external {\n        if (msg.value == 0) revert DepositAmountCannotBeZero();\n        if (_for== address(0)) revert CannotDepositForZeroAddress();\n        if (!tokenAllowlist[WETH_ADDRESS]) revert TokenNotAllowedForStaking();\n\n        balance[WETH_ADDRESS][_for] += msg.value;\n        emit Deposit(++eventId, _for, WETH_ADDRESS, msg.value);\n\n        IWETH(WETH_ADDRESS).deposit{value:msg.value}();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function withdraw(address _token, uint256 _amount) external {\n        if (_amount == 0) revert WithdrawAmountCannotBeZero();\n\n        balance[_token][msg.sender] -= _amount; //Will underfow if the staker has insufficient balance\n        emit Withdraw(++eventId, msg.sender, _token, _amount);\n\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrateWithSig(\n        address _user,\n        address[] calldata _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes memory _stakerSignature\n    ) onlyOwner external{\n        {\n            bytes32 structHash = keccak256(abi.encode(\n                MIGRATE_TYPEHASH, \n                _user, \n                _migratorContract,\n                _destination, \n                //The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents \n                //Ref: https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata\n                keccak256(abi.encodePacked(_tokens)),\n                _signatureExpiry, \n                _useNonce(_user)\n            ));\n            bytes32 constructedHash = _hashTypedDataV4(structHash);\n\n            if (!SignatureChecker.isValidSignatureNow(_user, constructedHash, _stakerSignature)){\n                revert SignatureInvalid();\n            }\n        }\n\n        uint256[] memory _amounts = _migrateChecks(_user, _tokens, _signatureExpiry, _migratorContract);\n        _migrate(_user, _destination, _migratorContract, _tokens, _amounts);\n\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function migrate(\n        address[] calldata  _tokens, \n        address _migratorContract, \n        address _destination, \n        uint256 _signatureExpiry, \n        bytes calldata _authorizationSignatureFromZircuit\n    ) external { \n        uint256[] memory _amounts = _migrateChecks(msg.sender, _tokens, _signatureExpiry, _migratorContract);\n\n        bytes32 constructedHash = keccak256(\n                abi.encodePacked(\n                    \'\\x19Ethereum Signed Message:\\n32\',\n                    keccak256(\n                        abi.encodePacked(\n                            _migratorContract,\n                            _signatureExpiry,\n                            address(this),\n                            block.chainid\n                        )\n                    )\n                )\n            );\n\n        // verify that the migrator’s address is signed in the authorization signature by the correct signer (zircuitSigner)\n        if (!SignatureChecker.isValidSignatureNow(zircuitSigner, constructedHash, _authorizationSignatureFromZircuit)){\n            revert SignatureInvalid();\n        }\n        \n        _migrate(msg.sender, _destination, _migratorContract, _tokens, _amounts);\n    }\n\n    function _migrateChecks(address _user, address[] calldata  _tokens, uint256 _signatureExpiry, address _migratorContract) \n        internal view returns (uint256[] memory _amounts){\n        \n        uint256 length = _tokens.length;\n        if (length == 0) revert TokenArrayCannotBeEmpty();\n\n        _amounts = new uint256[](length);\n\n        for(uint256 i; i < length; ++i){\n            _amounts[i] = balance[_tokens[i]][_user];\n            if (_amounts[i] == 0) revert UserDoesNotHaveStake();\n        }\n\n        if (block.timestamp >= _signatureExpiry) revert SignatureExpired();// allows us to invalidate signature by having it expired\n\n        if (migratorBlocklist[_migratorContract]) revert MigratorBlocked();\n    }\n\n    function _migrate(\n        address _user, \n        address _destination, \n        address _migratorContract,\n        address[] calldata  _tokens, \n        uint256[] memory _amounts) \n        internal {\n        \n        uint256 length = _tokens.length;\n       //effects for-loop (state changes)\n        for(uint256 i; i < length; ++i){\n            //if the balance has been already set to zero, then _tokens[i] is a duplicate of a previous token in the array\n            if (balance[_tokens[i]][_user] == 0) revert DuplicateToken();\n\n            balance[_tokens[i]][_user] = 0;\n        }\n\n        emit Migrate (++eventId, _user, _tokens, _destination, _migratorContract, _amounts);\n\n        //interactions for-loop (external calls)\n        for(uint256 i; i < length; ++i){\n            IERC20(_tokens[i]).approve(_migratorContract, _amounts[i]);\n        }\n       \n        IMigrator(_migratorContract).migrate(_user, _tokens, _destination, _amounts);\n\n    }\n    \n\n\n\n    /*//////////////////////////////////////////////////////////////\n                            Admin Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setZircuitSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert SignerCannotBeZeroAddress();\n        if (_signer == zircuitSigner) revert SignerAlreadySetToAddress();\n\n        zircuitSigner = _signer;\n        emit SignerChanged(_signer);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function setStakable(address _token, bool _canStake) external onlyOwner {\n        if (_token == address(0)) revert TokenCannotBeZeroAddress();\n        if (tokenAllowlist[_token] == _canStake) revert TokenAlreadyConfiguredWithState();\n\n        tokenAllowlist[_token] = _canStake;\n        emit TokenStakabilityChanged(_token, _canStake);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function blockMigrator(address _migrator, bool _blocklisted) external onlyOwner {\n        if (_migrator == address(0)) revert MigratorCannotBeZeroAddress();\n        if (migratorBlocklist[_migrator] == _blocklisted) revert MigratorAlreadyAllowedOrBlocked();\n\n        migratorBlocklist[_migrator] = _blocklisted;\n        emit BlocklistChanged(_migrator, _blocklisted);\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IZtakingPool\n     */\n    function unpause() external onlyOwner whenPaused{\n        _unpause();\n    }\n\n\n    function renounceOwnership() public override{\n        revert CannotRenounceOwnership();\n    }\n\n    \n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 1063, 'end_line': 1080, 'offset_start': 40766, 'offset_end': 41531, 'content': 'function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 1096, 'end_line': 1100, 'offset_start': 42339, 'offset_end': 42593, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 1107, 'end_line': 1114, 'offset_start': 42810, 'offset_end': 43263, 'content': 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 1119, 'end_line': 1123, 'offset_start': 43391, 'offset_end': 43640, 'content': 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 1129, 'end_line': 1155, 'offset_start': 43777, 'offset_end': 45303, 'content': 'function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 1161, 'end_line': 1165, 'offset_start': 45437, 'offset_end': 45696, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA._throwError', 'start_line': 1170, 'end_line': 1180, 'offset_start': 45830, 'offset_end': 46361, 'content': 'function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IMigrator.migrate', 'start_line': 1196, 'end_line': 1201, 'offset_start': 47060, 'offset_end': 47218, 'content': 'function migrate(\n        address _user,\n        address[] calldata _tokens,\n        address _destination, \n        uint256[] calldata _amounts\n    ) external;', 'contract_name': 'IMigrator', 'contract_code': '{\n    \n    ///@notice Function called by the Ztaking Pool to facilitate migration of staked tokens from the Ztaking Pool to Zircuit\n    ///@param _user The address of the user whose staked funds are being migrated to Zircuit\n    ///@param _tokens The tokens being migrated to Zircuit from the Ztaking Pool\n    ///@param _destination The address which will be credited the tokens on Zircuit\n    ///@param _amounts The amounts of each token to be migrated to Zircuit for the _user\n    function migrate(\n        address _user,\n        address[] calldata _tokens,\n        address _destination, \n        uint256[] calldata _amounts\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC5267.eip712Domain', 'start_line': 1218, 'end_line': 1229, 'offset_start': 47648, 'offset_end': 47957, 'content': 'function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );', 'contract_name': 'IERC5267', 'contract_code': '{\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 1297, 'end_line': 1305, 'offset_start': 50959, 'offset_end': 51141, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 1314, 'end_line': 1314, 'offset_start': 51447, 'offset_end': 51509, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 1320, 'end_line': 1320, 'offset_start': 51702, 'offset_end': 51761, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable.tor', 'start_line': 1365, 'end_line': 1367, 'offset_start': 52973, 'offset_end': 53018, 'content': 'constructor() {\n        _paused = false;\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable.paused', 'start_line': 1396, 'end_line': 1398, 'offset_start': 53616, 'offset_end': 53699, 'content': 'function paused() public view virtual returns (bool) {\n        return _paused;\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._requireNotPaused', 'start_line': 1403, 'end_line': 1407, 'offset_start': 53768, 'offset_end': 53895, 'content': 'function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._requirePaused', 'start_line': 1412, 'end_line': 1416, 'offset_start': 53968, 'offset_end': 54093, 'content': 'function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._pause', 'start_line': 1425, 'end_line': 1428, 'offset_start': 54229, 'offset_end': 54343, 'content': 'function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._unpause', 'start_line': 1437, 'end_line': 1440, 'offset_start': 54476, 'offset_end': 54592, 'content': 'function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 1480, 'end_line': 1485, 'offset_start': 55822, 'offset_end': 56008, 'content': 'constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 1498, 'end_line': 1500, 'offset_start': 56235, 'offset_end': 56319, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._checkOwner', 'start_line': 1505, 'end_line': 1509, 'offset_start': 56393, 'offset_end': 56554, 'content': 'function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 1518, 'end_line': 1520, 'offset_start': 56890, 'offset_end': 56990, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 1526, 'end_line': 1531, 'offset_start': 57140, 'offset_end': 57354, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 1537, 'end_line': 1541, 'offset_start': 57509, 'offset_end': 57695, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 1579, 'end_line': 1581, 'offset_start': 59003, 'offset_end': 59162, 'content': 'function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 1587, 'end_line': 1589, 'offset_start': 59402, 'offset_end': 59589, 'content': 'function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 1595, 'end_line': 1598, 'offset_start': 59781, 'offset_end': 60005, 'content': 'function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 1604, 'end_line': 1612, 'offset_start': 60209, 'offset_end': 60676, 'content': 'function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.forceApprove', 'start_line': 1619, 'end_line': 1626, 'offset_start': 60996, 'offset_end': 61375, 'content': 'function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 1634, 'end_line': 1643, 'offset_start': 61759, 'offset_end': 62387, 'content': "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }", 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturnBool', 'start_line': 1653, 'end_line': 1660, 'offset_start': 62889, 'offset_end': 63466, 'content': "function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }", 'contract_name': 'SafeERC20', 'contract_code': "{\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable2Step.pendingOwner', 'start_line': 1689, 'end_line': 1691, 'offset_start': 64345, 'offset_end': 64443, 'content': 'function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }', 'contract_name': 'Ownable2Step', 'contract_code': '{\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable2Step.transferOwnership', 'start_line': 1697, 'end_line': 1700, 'offset_start': 64637, 'offset_end': 64814, 'content': 'function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }', 'contract_name': 'Ownable2Step', 'contract_code': '{\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable2Step._transferOwnership', 'start_line': 1706, 'end_line': 1709, 'offset_start': 64999, 'offset_end': 65151, 'content': 'function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable2Step', 'contract_code': '{\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable2Step.acceptOwnership', 'start_line': 1714, 'end_line': 1720, 'offset_start': 65232, 'offset_end': 65460, 'content': 'function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }', 'contract_name': 'Ownable2Step', 'contract_code': '{\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712.tor', 'start_line': 1788, 'end_line': 1797, 'offset_start': 68793, 'offset_end': 69223, 'content': 'constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex"0f", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._domainSeparatorV4', 'start_line': 1802, 'end_line': 1808, 'offset_start': 69310, 'offset_end': 69571, 'content': 'function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex"0f", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._buildDomainSeparator', 'start_line': 1810, 'end_line': 1812, 'offset_start': 69578, 'offset_end': 69756, 'content': 'function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex"0f", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._hashTypedDataV4', 'start_line': 1829, 'end_line': 1831, 'offset_start': 70382, 'offset_end': 70557, 'content': 'function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex"0f", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712.eip712Domain', 'start_line': 1836, 'end_line': 1859, 'offset_start': 70609, 'offset_end': 71165, 'content': 'function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex"0f", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex"0f", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._EIP712Name', 'start_line': 1868, 'end_line': 1870, 'offset_start': 71486, 'offset_end': 71611, 'content': 'function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex"0f", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._EIP712Version', 'start_line': 1879, 'end_line': 1881, 'offset_start': 71938, 'offset_end': 72072, 'content': 'function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex"0f", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryAdd', 'start_line': 1908, 'end_line': 1914, 'offset_start': 72662, 'offset_end': 72877, 'content': 'function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.trySub', 'start_line': 1919, 'end_line': 1924, 'offset_start': 72985, 'offset_end': 73173, 'content': 'function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMul', 'start_line': 1929, 'end_line': 1939, 'offset_start': 73284, 'offset_end': 73776, 'content': "function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }", 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryDiv', 'start_line': 1944, 'end_line': 1949, 'offset_start': 73888, 'offset_end': 74077, 'content': 'function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMod', 'start_line': 1954, 'end_line': 1959, 'offset_start': 74199, 'offset_end': 74388, 'content': 'function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 1964, 'end_line': 1966, 'offset_start': 74459, 'offset_end': 74562, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 1971, 'end_line': 1973, 'offset_start': 74634, 'offset_end': 74737, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 1979, 'end_line': 1982, 'offset_start': 74851, 'offset_end': 75003, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 1990, 'end_line': 1998, 'offset_start': 75225, 'offset_end': 75555, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 2006, 'end_line': 2085, 'offset_start': 75880, 'offset_end': 79995, 'content': "function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }", 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 2090, 'end_line': 2096, 'offset_start': 80128, 'offset_end': 80429, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 2104, 'end_line': 2135, 'offset_start': 80664, 'offset_end': 82301, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 2140, 'end_line': 2145, 'offset_start': 82402, 'offset_end': 82641, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 2151, 'end_line': 2187, 'offset_start': 82772, 'offset_end': 83754, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 2193, 'end_line': 2198, 'offset_start': 83908, 'offset_end': 84155, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 2204, 'end_line': 2236, 'offset_start': 84287, 'offset_end': 85202, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 2242, 'end_line': 2247, 'offset_start': 85357, 'offset_end': 85607, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 2255, 'end_line': 2279, 'offset_start': 85865, 'offset_end': 86527, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 2285, 'end_line': 2290, 'offset_start': 86683, 'offset_end': 86941, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.unsignedRoundsUp', 'start_line': 2295, 'end_line': 2297, 'offset_start': 87066, 'offset_end': 87187, 'content': 'function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n            // benefit is lost if \'b\' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Nonces.nonces', 'start_line': 2318, 'end_line': 2320, 'offset_start': 87730, 'offset_end': 87836, 'content': 'function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }', 'contract_name': 'Nonces', 'contract_code': '{\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Nonces._useNonce', 'start_line': 2327, 'end_line': 2334, 'offset_start': 87951, 'offset_end': 88345, 'content': 'function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }', 'contract_name': 'Nonces', 'contract_code': '{\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Nonces._useCheckedNonce', 'start_line': 2339, 'end_line': 2344, 'offset_start': 88457, 'offset_end': 88678, 'content': 'function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }', 'contract_name': 'Nonces', 'contract_code': '{\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH.deposit', 'start_line': 2354, 'end_line': 2354, 'offset_start': 88852, 'offset_end': 88887, 'content': 'function deposit() external payable;', 'contract_name': 'IWETH', 'contract_code': '{\n    function deposit() external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1271.isValidSignature', 'start_line': 2371, 'end_line': 2371, 'offset_start': 89434, 'offset_end': 89539, 'content': 'function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);', 'contract_name': 'IERC1271', 'contract_code': '{\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 2414, 'end_line': 2423, 'offset_start': 91075, 'offset_end': 91405, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 2443, 'end_line': 2445, 'offset_start': 92249, 'offset_end': 92399, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 2456, 'end_line': 2462, 'offset_start': 92724, 'offset_end': 93115, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 2468, 'end_line': 2471, 'offset_start': 93255, 'offset_end': 93508, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 2477, 'end_line': 2480, 'offset_start': 93650, 'offset_end': 93902, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 2487, 'end_line': 2502, 'offset_start': 94169, 'offset_end': 94750, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 2508, 'end_line': 2514, 'offset_start': 94951, 'offset_end': 95174, 'content': 'function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 2519, 'end_line': 2531, 'offset_start': 95287, 'offset_end': 95802, 'content': 'function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\'s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\'t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 2563, 'end_line': 2570, 'offset_start': 97029, 'offset_end': 97488, 'content': 'function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `"\\x19Ethereum Signed Message:\\n32"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `"\\x19Ethereum Signed Message:\\n" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `"\\x19\\x00"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 2582, 'end_line': 2585, 'offset_start': 97955, 'offset_end': 98183, 'content': 'function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `"\\x19Ethereum Signed Message:\\n32"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `"\\x19Ethereum Signed Message:\\n" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `"\\x19\\x00"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toDataWithIntendedValidatorHash', 'start_line': 2596, 'end_line': 2598, 'offset_start': 98527, 'offset_end': 98717, 'content': 'function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `"\\x19Ethereum Signed Message:\\n32"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `"\\x19Ethereum Signed Message:\\n" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `"\\x19\\x00"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toTypedDataHash', 'start_line': 2609, 'end_line': 2618, 'offset_start': 99160, 'offset_end': 99560, 'content': 'function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `"\\x19Ethereum Signed Message:\\n32"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `"\\x19Ethereum Signed Message:\\n" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `"\\x19\\x00"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6/0xf047ab4c75cebf0eb9ed34ae2c186f3611aeafa6.sol'}
